"
I am an asset model that is usually generated by an external 3D design application. Unlike a simple model, I represent a template for a subset of a scene graph.
"
Class {
	#name : #WDSSceneAssetModel,
	#superclass : #WDCAbstractModel,
	#instVars : [
		'mainScene',
		'scenes',
		'sceneNodeNameDictionary'
	],
	#category : #'WodenEngine-Scene-Asset'
}

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> createViewer [
	| sceneModel camera hasLights sunLight skyTexture viewScene sceneBBox |
	sceneModel := WDASampleSceneModel new.
	viewScene := mainScene copy.
	sceneModel
		scene: viewScene.
	viewScene backgroundColor: Color darkGray.
	viewScene initializeWithEngine: sceneModel engine.
	
	"Try to find a camera."
	hasLights := false.
	viewScene allChildrenDo: [ :node |
		hasLights := hasLights or: [node isLightSource].
		node isCamera ifTrue: [
			node isNotControlledByTheUser: true.
			sceneModel camera: node
		]
	].

	"If not camera is found, then we have to create a camera for the scene."
	sceneModel camera ifNil: [ 
		camera := WDSGCamera new.
		sceneBBox := mainScene normalLayer globalBoundingBox.
		camera position: (sceneBBox center + (WMVector3F z: sceneBBox depth)).
		
		viewScene add: camera.
		sceneModel camera: camera.
	].

	hasLights ifFalse: [
		"Add a light"
		sunLight := WDSGLightSource new.
		sunLight
			directional; castShadows: false;
			intensity: (WMVector4F x: 1.0 y: 1.0 z: 0.8) normalized * 0.6;
			rotateDegreesOnX: -35.
		
		viewScene add: sunLight.

		viewScene ambientLighting: WMVector4F ones*0.6.
		
		skyTexture := WDASceneExamples proceduralSkySunDirection: (sunLight transform
				transformVector3:(WMVector3F z: 1.0)
			).
		skyTexture := skyTexture asSRGBTextureFor: sceneModel engine.
		viewScene createSkyWithCubeTexture: skyTexture.
	].

	^ sceneModel
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> ensureValidNameDictionaries [
	sceneNodeNameDictionary ifNotNil: [ ^ self ].

	sceneNodeNameDictionary := Dictionary new.
	scenes do: [ :scene |
		scene allChildrenDo: [ :node |
			node name ifNotNil: [
				sceneNodeNameDictionary at: node name put: node
			].
		]
	].

]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> extractConvexCollisionShapesFrom: node withTransform: nodeGlobalTransform into: convexComponents [
	node canBeRendered ifTrue: [ 
		node renderable extractConvexCollisionShapesWithTransform: nodeGlobalTransform into: convexComponents
	].

	node childrenDo: [ :child |
		self extractConvexCollisionShapesFrom: child
			withTransform: (nodeGlobalTransform transformTransform: child transform)
			into: convexComponents
	].

]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> getCollisionShapeForConvexCollisionTreeNamed: collisionTreeNodeName [
	| treeRoot convexComponents |
	self ensureValidNameDictionaries.
	treeRoot := sceneNodeNameDictionary at: collisionTreeNodeName.
	convexComponents := OrderedCollection new.
	self extractConvexCollisionShapesFrom: treeRoot withTransform: WMReversibleAffineTransformF identity into: convexComponents.
	convexComponents ifEmpty: [ ^ nil ].
	
	self flag: 'TODO: Add a cache for this collision shapes.'.
	^ WDPhyCompoundCollisionShape new components: convexComponents
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> getNodeBoundingBox: childNodeName relativeToNode: parentNodeName [
	| childNode parentNode |
	self ensureValidNameDictionaries.
	childNode := sceneNodeNameDictionary at: childNodeName.
	parentNode := sceneNodeNameDictionary at: parentNodeName.
	^ childNode globalOrientedBoundingBox transformedWith: (parentNode globalTransform inverseTransformTransform: childNode globalTransform)
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> getNodePosition: childNodeName relativeToNode: parentNodeName [
	| childNode parentNode |
	self ensureValidNameDictionaries.
	childNode := sceneNodeNameDictionary at: childNodeName.
	parentNode := sceneNodeNameDictionary at: parentNodeName.
	^ childNode globalTransform translation - parentNode globalTransform translation
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> getNodeTransform: childNodeName relativeToNode: parentNodeName [
	| childNode parentNode |
	self ensureValidNameDictionaries.
	childNode := sceneNodeNameDictionary at: childNodeName.
	parentNode := sceneNodeNameDictionary at: parentNodeName.
	^ parentNode globalTransform inverseTransformTransform: childNode globalTransform
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> instanceSceneNodeNamed: sceneNodeName [
	^ self instanceSceneNodeNamed: sceneNodeName ifAbsent: [self error: 'Requested scene node is not available in the model.']
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> instanceSceneNodeNamed: sceneNodeName ifAbsent: aBlock [
	self ensureValidNameDictionaries.
	^ (sceneNodeNameDictionary at: sceneNodeName ifAbsent: [ aBlock ]) copy
		transform: WMReversibleAffineTransformF identity;
		yourself
]

{ #category : #accessing }
WDSSceneAssetModel >> mainScene [
	^ mainScene
]

{ #category : #accessing }
WDSSceneAssetModel >> mainScene: anObject [
	mainScene := anObject
]

{ #category : #'as yet unclassified' }
WDSSceneAssetModel >> openViewer [
	^ self createViewer openWith: WDAFPSSceneView allowingVR.
]

{ #category : #accessing }
WDSSceneAssetModel >> scenes [
	^ scenes
]

{ #category : #accessing }
WDSSceneAssetModel >> scenes: anObject [
	scenes := anObject
]
