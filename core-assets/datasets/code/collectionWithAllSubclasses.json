{"classes":[{"name":"HashedCollection","instanceVariables":[{"name":"tally"},{"name":"array"}],"methods":[{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: anInteger\r\t\"Grow the elements array and reinsert the old elements\"\r\t\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: anInteger.\r\tself noCheckNoGrowFillFrom: oldElements"},{"name":"grow","linesOfCode":10,"sourceCode":"grow\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: (HashTableSizes atLeast: oldElements size * 2).\r\ttally := 0.\r\toldElements\r\t\tdo:\r\t\t\t[ :each | \r\t\t\teach ifNotNil: [ self noCheckAdd: each ] ]"},{"name":"scanFor:","linesOfCode":3,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\tself subclassResponsibility"},{"name":"rehash","linesOfCode":2,"sourceCode":"rehash\r\tself growTo: self capacity"},{"name":"add:withOccurrences:","linesOfCode":5,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject.\"\r\t\r\tanInteger < 1 ifTrue: [ ^newObject ].\r\t\"I can only store an object once.\"\r\t^ self add: newObject"},{"name":"union:","linesOfCode":3,"sourceCode":"union: aCollection\r\t\"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all.\"\r\r\t^ self copy addAll: aCollection; yourself"},{"name":"atNewIndex:put:","linesOfCode":4,"sourceCode":"atNewIndex: index put: anObject\r\tarray at: index put: anObject.\r\ttally := tally + 1.\r\tself fullCheck"},{"name":"growSize","linesOfCode":3,"sourceCode":"growSize\r\t\"Answer what my next higher table size should be\"\r\r\t^HashTableSizes atLeast: self capacity * 3 // 2 + 2\r\t"},{"name":"comeFullyUpOnReload:","linesOfCode":4,"sourceCode":"comeFullyUpOnReload: smartRefStream\r\t\"Symbols have new hashes in this image.\"\r\r\tself  compact.\r\t\"^ self\"\r"},{"name":"fullCheck","linesOfCode":4,"sourceCode":"fullCheck\r\t\"Keep array at least 1/4 free for decent hash behavior\"\r\tarray size - tally < (array size // 4 max: 1)\r\t\tifTrue: [self grow]"},{"name":"compact","linesOfCode":5,"sourceCode":"compact\r\t\"Reduce the size of array so that the load factor will be ~75%.\"\r\t\r\t| newCapacity |\r\tnewCapacity := HashTableSizes atLeast: tally * 4 // 3.\r\tself growTo: newCapacity"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey hash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"metaLinkOptions","linesOfCode":5,"sourceCode":"metaLinkOptions\r\t^{\r\t#findElementOrNil: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":3,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\t\r\tself subclassResponsibility"},{"name":"removeAll","linesOfCode":4,"sourceCode":"removeAll\r\t\"remove all elements from this collection.\r\tPreserve the capacity\"\r\t\r\tself initialize: self capacity"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ tally"},{"name":"initialize:","linesOfCode":4,"sourceCode":"initialize: n\r\t\"Initialize array to an array size of n\"\r\tarray := Array new: n.\r\ttally := 0"},{"name":"capacity","linesOfCode":3,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t^ array size"},{"name":"errorNoFreeSpace","linesOfCode":2,"sourceCode":"errorNoFreeSpace\r\r\tself error: 'There is no free space in this collection!'"},{"name":"noCheckAdd:","linesOfCode":2,"sourceCode":"noCheckAdd: anObject\r\r    self subclassResponsibility"},{"name":"array","linesOfCode":2,"sourceCode":"array\r\t^ array"},{"name":"fixCollisionsFrom:","linesOfCode":5,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\t\r\tself subclassResponsibility"},{"name":"findElementOrNil:","linesOfCode":9,"sourceCode":"findElementOrNil: anObject\r\t\"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found.\"\r\r\t| index |\r\r\tindex := self scanFor: anObject.\r\tindex > 0 ifTrue: [^index].\r\r\t\"Bad scene.  Neither have we found a matching element\r\tnor even an empty slot.  No hashed set is ever supposed to get\r\tcompletely full.\"\r\tself error: 'There is no free space in this set!'."},{"name":"fuelAfterMaterialization","linesOfCode":2,"sourceCode":"fuelAfterMaterialization\r\r\tself rehash"},{"name":"veryDeepCopyWith:","linesOfCode":6,"sourceCode":"veryDeepCopyWith: deepCopier\r\t| copyOfSelf|\r\tcopyOfSelf := super veryDeepCopyWith: deepCopier.\r\t\"force Sets and Dictionaries to rehash\"\r\tcopyOfSelf rehash.\r\t\t^ copyOfSelf"}],"meta":{"name":"HashedCollection class","instanceVariables":[],"methods":[{"name":"cleanUp:","linesOfCode":3,"sourceCode":"cleanUp: aggressive\r\t\"Rehash all instances when cleaning aggressively\"\r\r\taggressive ifTrue: [self compactAll].\r"},{"name":"new:","linesOfCode":3,"sourceCode":"new: nElements\r\t\"Create a Set large enough to hold nElements without growing\"\r\t^ self basicNew initialize: (self sizeFor: nElements)"},{"name":"compactAll","linesOfCode":4,"sourceCode":"compactAll\r\t\"HashedCollection compactAll\"\t\r\t\t\r\tself allSubclassesDo: #compactAllInstances"},{"name":"rehashAllInstances","linesOfCode":3,"sourceCode":"rehashAllInstances\r\t\"Do not use #allInstancesDo: because rehash may create new instances.\"\r\t\r\tself allInstances do: [ :each | each rehash ]"},{"name":"compactAllInstances","linesOfCode":3,"sourceCode":"compactAllInstances\r\t\"Do not use #allInstancesDo: because rehash may create new instances.\"\r\t\r\tself allInstances do: [ :each | each compact ]"},{"name":"sizeFor:","linesOfCode":4,"sourceCode":"sizeFor: nElements\r\t\"Large enough size to hold nElements with some slop (see fullCheck)\"\r\t\r\tnElements < 4 ifTrue: [ ^5 ].\r\t^ HashTableSizes atLeast: nElements +1 * 4 // 3"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\t^ self basicNew\r\t\tinitialize: 5;\r\t\tyourself"},{"name":"rehashAll","linesOfCode":4,"sourceCode":"rehashAll\r\t\"HashedCollection rehashAll\"\t\r\t\t\r\tself allSubclassesDo: #rehashAllInstances"},{"name":"newFrom:","linesOfCode":3,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t^self subclassResponsibility"},{"name":"empty","linesOfCode":4,"sourceCode":"empty\r\t^ self basicNew\r\t\tinitialize: 1;\r\t\tyourself"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #HashedCollection"}],"meta":null}},{"name":"SequenceableCollection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":12,"sourceCode":"copyWith: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver and has \r\tnewElement at the last element.\"\r\r\t| newIC |\r\tnewIC := self species new: self size + 1.\r\tnewIC \r\t\treplaceFrom: 1\r\t\tto: self size\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: newIC size put: newElement.\r\t^newIC"},{"name":"at:incrementBy:","linesOfCode":4,"sourceCode":"at: index incrementBy: value\r\t\"(#(1 2 3 4) at: 3 incrementBy: 2) >>> 5\"\r\t\"(#(1 2 3 4) at: 2 incrementBy: 2) >>> 4\"\r\t\r\t^self at: index put: (self at: index) + value"},{"name":"copyReplaceFrom:to:with:","linesOfCode":29,"sourceCode":"copyReplaceFrom: start to: stop with: replacementCollection \r\t\"Answer a copy of the receiver satisfying the following conditions: If \r\tstop is less than start, then this is an insertion; stop should be exactly \r\tstart-1, start = 1 means insert before the first character, start = size+1 \r\tmeans append after last character. Otherwise, this is a replacement; start \r\tand stop have to be within the receiver's bounds.\"\r\r\t| newSequenceableCollection newSize endReplacement |\r\tnewSize := self size - (stop - start + 1) + replacementCollection size.\r\tendReplacement := start - 1 + replacementCollection size.\r\tnewSequenceableCollection := self species new: newSize.\r\tstart > 1 ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: 1\r\t\t\tto: start - 1\r\t\t\twith: self\r\t\t\tstartingAt: 1].\r\tstart <= endReplacement ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: start\r\t\t\tto: endReplacement\r\t\t\twith: replacementCollection\r\t\t\tstartingAt: 1].\r\tendReplacement < newSize ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: endReplacement + 1\r\t\t\tto: newSize\r\t\t\twith: self\r\t\t\tstartingAt: stop + 1].\r\t^newSequenceableCollection"},{"name":"reject:thenCollect:","linesOfCode":8,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#reject:thenCollect:\"\r\t\r\t\"(#(1 2 3 4) reject: [:each | each = 3 ] thenCollect: [:each | each + 10 ]) >>> #(11 12 14)\"\r\t\r\t| each |\r\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"seventh","linesOfCode":5,"sourceCode":"seventh\r\t\"Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) seventh >>> #g\"\r\r\t^ self at: 7"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"Instances of STON listClass will be encoded directly, without a class tag.\r\tOther (sub)classes will be encoded with a class tag and will use a list representation. \"\r\r\tself class == STON listClass\r\t\tifTrue: [ stonWriter writeList: self ]\r\t\tifFalse: [ super stonOn: stonWriter ]"},{"name":"asFloatArray","linesOfCode":7,"sourceCode":"asFloatArray\r\t\"Answer a FloatArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| floatArray |\r\tfloatArray := FloatArray new: self size.\r\t1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].\r\t^floatArray"},{"name":"flatCollect:","linesOfCode":12,"sourceCode":"flatCollect: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. optimized version for Sequencable Collection and subclasses\r\timplementing #writeStream\"\r\r\t\"(#( (2 -3) (4 -5) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 4 5 6)\"\r\r\t\"(#( (2 -3) #((4 -5)) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 #(4 5) 6)\"\r\r\tself isEmpty\r\t\tifTrue: [ ^ self copy ].\r\t^self species \r\t\tnew: 0\r\t\tstreamContents: [ :stream | self do: [ :each | stream nextPutAll: (aBlock value: each) ] ]"},{"name":"splitOn:do:","linesOfCode":4,"sourceCode":"splitOn: splitter do: aBlock\r\t\"Perform an action specified as aBlock to each of the elements of the receiver that have been split using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space do: [:each | s << each ]])>>>'Pharoiscool'\"\r\t\r\t^ splitter split: self do: aBlock"},{"name":"replaceAll:with:","linesOfCode":15,"sourceCode":"replaceAll: oldObject with: newObject \r\t\"Replace all occurrences of oldObject with newObject\"\r\t\"(#(a b a d a) replaceAll: #a with: #e) >>> #(e b e d e)\"\r\t\r\t| index |\r\tindex := self\r\t\t\t\tindexOf: oldObject\r\t\t\t\tstartingAt: 1\r\t\t\t\tifAbsent: [0].\r\t[index = 0]\r\t\twhileFalse: \r\t\t\t[self at: index put: newObject.\r\t\t\tindex := self\r\t\t\t\t\t\tindexOf: oldObject\r\t\t\t\t\t\tstartingAt: index + 1\r\t\t\t\t\t\tifAbsent: [0]]"},{"name":"asGPUFloat32x2Array","linesOfCode":2,"sourceCode":"asGPUFloat32x2Array\r\t^ self asGPUArrayOfType: #Float32x2"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock \r\t\"Refer to the comment in Collection|do:.\"\r\t1 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"before:","linesOfCode":7,"sourceCode":"before: target\r\t\"Answer the receiver's element immediately before target. Raise an\r\terror if target is not an element of the receiver, or if there are no \r\telements before it (i.e. it is the first element).\"\r\t\"(#(11 22 33) before: 22) >>> 11\"\r\t\"(#(11 22 33) before: 33) >>> 22\"\r\r\t^ self before: target ifAbsent: [self errorNotFound: target]"},{"name":"allPairsDo:","linesOfCode":5,"sourceCode":"allPairsDo: aBinaryBlock\r\t\"Iterate over all the pairs of the receiver and apply the binaryBlock\r\tto each pair. \"\r\r\t\"(Array streamContents: [ :stream | #(0 1 2 3) allPairsDo: [ :first :second | stream nextPut: { first . second } ] ]) >>> #(#(0 0) #(0 1) #(0 2) #(0 3) #(1 0) #(1 1) #(1 2) #(1 3) #(2 0) #(2 1) #(2 2) #(2 3) #(3 0) #(3 1) #(3 2) #(3 3))\"\r\r\tself do: [ :first | self do: [ :second | aBinaryBlock value: first value: second ] ]"},{"name":"combinations:atATimeDo:","linesOfCode":10,"sourceCode":"combinations: kk atATimeDo: aBlock\r\t\"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations.\"\r\r\t\"(Array streamContents: [:stream | 'abcde' combinations: 3 atATimeDo: [:each | stream nextPut: each copy]]) >>> #(#($a $b $c) #($a $b $d) #($a $b $e) #($a $c $d) #($a $c $e) #($a $d $e) #($b $c $d) #($b $c $e) #($b $d $e) #($c $d $e))\"\r\r\t| aCollection |\r\taCollection := Array new: kk.\r\tself\r\t\tcombinationsAt: 1\r\t\tin: aCollection\r\t\tafter: 0\r\t\tdo: aBlock"},{"name":"putOn:","linesOfCode":5,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tReturn self.\"\r\r\tself do: [ :each | each putOn: aStream ]"},{"name":"allButFirst","linesOfCode":5,"sourceCode":"allButFirst\r\t\"Answer a copy of the receiver containing all but the first\r\telement. Raise an error if there are not enough elements.\"\t\r\t\"#(a b c) allButFirst >>> #(b c)\"\r\r\t^ self allButFirst: 1"},{"name":"split:indicesDo:","linesOfCode":15,"sourceCode":"split: aSequenceableCollection indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of aSequenceableCollection that have been identified by taking the receiver as a splitter.\"\r\t\"('||' split: 'foo||bar||2')>>>#('foo' 'bar' '2') asOrderedCollection\"\r\t\"(String streamContents: [:s | '||' split: 'foo||bar||2' indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:3 s:6 e:8 s:11 e:11 '\"\r\t\r\t| position oldPosition |\r\tposition := 1.\r\toldPosition := position.\r\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t\r\t[ position > 0 ] whileTrue: [\r\t\taBlock value: oldPosition value: position - 1.\r\t\tposition := position + self size.\r\t\toldPosition := position.\r\t\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t].\r\r\taBlock value: oldPosition value: aSequenceableCollection size.\r\r"},{"name":"reverseDo:","linesOfCode":7,"sourceCode":"reverseDo: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument, \r\tstarting with the last element and taking each in sequence up to the \r\tfirst. For SequenceableCollections, this is the reverse of the enumeration \r\tfor do:.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseDo: [:each | stream nextPut: each + 10]]) >>> #(13 12 11)\"\r\r\tself size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]"},{"name":"asGroup","linesOfCode":2,"sourceCode":"asGroup\r\t^ (RSGroup new: self size) addAll: self; yourself"},{"name":"bind:","linesOfCode":5,"sourceCode":"bind: aBlock \r\r\t\"Extract items from the receiver and use them as arguments of aBlock. Signal an error\r\t(ArgumentsCountMismatch) when the arguments count of aBlock does not match the receiver size.\" \r\t\r\t\"(#(1 2 3) bind: [ :first :second :third | first + second + third ]) >>> 6\"\r\r\t^ aBlock valueWithArguments: self"},{"name":"joinUsing:last:","linesOfCode":8,"sourceCode":"joinUsing: joiner last: last \r\t\"Append the elements of the receiver separating them with the joiner argument and handle the last elment separation using the last argument.\"\r\t\r\t\"(#(1 2 3 4) joinUsing: ', ' last: ' and ') >>> '1, 2, 3 and 4'\"\r\t\r\t(self size = 0) ifTrue: [  ^ '' ].\r\t(self size = 1) ifTrue: [  ^ self first asString ].\r\t^ last join: (Array\r\t\t\t\twith: (joiner join: self allButLast)\r\t\t\t\twith: self last)"},{"name":"asPetitStream","linesOfCode":2,"sourceCode":"asPetitStream\r\t^ PPStream on: self"},{"name":"isSortedBy:","linesOfCode":15,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a <= b ]) >>> true\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a >= b ]) >>> false\"\r\t\"(#(xa xc xz xb xy) isSortedBy: #last ascending) >>> false\"\r\t\"(#(xa xb xc xy xz) isSortedBy: #last ascending) >>> true\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"isSorted","linesOfCode":14,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\t\"#(1 2 3) isSorted >>> true\"\r\t\"#(1 2 3 0) isSorted >>> false\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"asDastrelCollectionWithContext","linesOfCode":2,"sourceCode":"asDastrelCollectionWithContext\r\t^ DASLCollectionWithContext new collection: self"},{"name":"do:separatedBy:","linesOfCode":8,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] separatedBy: [ stream nextPut: 0 ]])) >>> #(11 0 12 0 13)\"\r\r\t1 to: self size do:\r\t\t[:index |\r\t\tindex = 1 ifFalse: [separatorBlock value].\r\t\telementBlock value: (self at: index)]"},{"name":"reject:thenDo:","linesOfCode":7,"sourceCode":"reject: rejectBlock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#reject:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) reject: [:each | each = 3 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(11 12 14)\"\r\t\r\t|  each |\r\t\r\t1 to: self size do: [ :index |\r\t\t(rejectBlock value: (each := self at: index))\r\t\t\tifFalse: [ aBlock value: each ]]."},{"name":"collect:thenSelect:","linesOfCode":9,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of Collection>>#collect:thenSelect:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenSelect: [:each | each even]) >>> #(12)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"paddedWith:do:","linesOfCode":10,"sourceCode":"paddedWith: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\r\tMissing elements from either will be passed as nil.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50 60) do: [:first :second | stream nextPut: (first + second)]]) >>> #(50 70 90) \"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(30 nil)) \"\r\r\t\"(Array streamContents: [:stream | #(10 20) paddedWith: #(40 50 60) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(nil 60))\"\r\t\t\r\t1 to: (self size max: otherCollection size) do:\r\t\t[:index | twoArgBlock value: (self at: index ifAbsent: [])\r\t\t\t\tvalue: (otherCollection at: index ifAbsent: [])]"},{"name":"collectWithIndex:","linesOfCode":3,"sourceCode":"collectWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\"\r\t^ self withIndexCollect: elementAndIndexBlock"},{"name":"swap:with:","linesOfCode":7,"sourceCode":"swap: oneIndex with: anotherIndex \r\t\"Move the element at oneIndex to anotherIndex, and vice-versa.\"\r\t\"(#(a b c d e) swap: 5 with: 1) >>> #(e b c d a)\"\r\r\t| element |\r\telement := self at: oneIndex.\r\tself at: oneIndex put: (self at: anotherIndex).\r\tself at: anotherIndex put: element"},{"name":"difference:","linesOfCode":3,"sourceCode":"difference: aCollection\r\t\"Answer the difference of two sequences preserving order and collection type.\"\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"runningMax:","linesOfCode":4,"sourceCode":"runningMax: aSubsetSize\r\t\"Running max. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMax: 3) >>> {2 . 2 . 3 . 3}\"\r\r\t^ self running: [ :subset | subset max ] of: aSubsetSize"},{"name":"beginsWith:","linesOfCode":9,"sourceCode":"beginsWith: aSequenceableCollection\r\t\"Answer true if the receiver starts with the argument collection\"\r\t\r\t\"#(1 2 3 4 5) beginsWith: #() >>> false\"\r\t\"#(1 2 3) beginsWith: #(1 2 3 4 5) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(0 1 2) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(1 2 3) >>> true\"\r\t\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\taSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"findBinary:","linesOfCode":9,"sourceCode":"findBinary: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]) >>> 11 \"\r\r\t^ self findBinary: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock ]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"SequencableCollections cannot implement removing.\"\r\r\tself shouldNotImplement"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\r\tNote: it is user responsibility to provide aCollection that behaves relatevily fast when asked for includes: (like a Set)\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"asGPUFloat32x3Array","linesOfCode":2,"sourceCode":"asGPUFloat32x3Array\r\t^ self asGPUArrayOfType: #Float32x3"},{"name":"asGPUArrayOfType:","linesOfCode":2,"sourceCode":"asGPUArrayOfType: type\r\t^ SGPUCompilationEnvironment current constructArrayOfType: type with: self"},{"name":"groupsOf:atATimeDo:","linesOfCode":17,"sourceCode":"groupsOf: n atATimeDo: aBlock \r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.\r\tAllows use of a flattened \r\tarray for things that naturally group into groups of n.\r\tIf aBlock has a single argument, pass it an array of n items,\r\totherwise, pass the items as separate arguments.\r\tSee also pairsDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40 50) groupsOf: 2 atATimeDo:  [:first :second | stream nextPut: (first + second)]]) >>> #(30 70)\"\r\t\r\t| passArray |\r\tpassArray := (aBlock numArgs = 1).\r\tn\r\t\tto: self size\r\t\tby: n\r\t\tdo: [:index | | args | \r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray ifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ]]."},{"name":"overlappingPairsWithIndexDo:","linesOfCode":5,"sourceCode":"overlappingPairsWithIndexDo: aBlock \r\t\"Emit overlapping pairs of my elements into aBlock, along with an index.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) overlappingPairsWithIndexDo: [:first :second :index| stream nextPut: (first + second + index)]]) >>> #(31 52 73)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1) value: i ]"},{"name":"atPin:","linesOfCode":9,"sourceCode":"atPin: index \r\t\"Return the index'th element of me if possible.\r\tReturn the first or last element if index is out of bounds.\"\r\t\"(#(w x y z) atPin: 2) >>> #x\"\r\t\"(#(w x y z) atPin: 4) >>> #z\"\r\t\"(#(w x y z) atPin: 8) >>> #z\"\r\r\tindex < 1 ifTrue: [^ self first].\r\tindex > self size ifTrue: [^ self last].\r\t^ self at: index"},{"name":"max:","linesOfCode":11,"sourceCode":"max: aBlock\r\t| max |\r\tself ifEmpty: [ ^ nil ].\r\tmax := aBlock value: self first.\r\tself\r\t\tallButFirstDo:\r\t\t\t[ :each | \r\t\t\t| value |\r\t\t\tvalue := aBlock value: each.\r\t\t\tmax := max max: value ].\r\t^ max"},{"name":"asGPUFloat64x4Array","linesOfCode":2,"sourceCode":"asGPUFloat64x4Array\r\t^ self asGPUArrayOfType: #Float64x4"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: start ifAbsent: [0]"},{"name":"first:","linesOfCode":5,"sourceCode":"first: n\r\t\"Answer the first n elements of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e f g h ) first: 3) >>> #(a b c)\"\r\r\t^ self copyFrom: 1 to: n"},{"name":"copyReplaceAll:with:","linesOfCode":15,"sourceCode":"copyReplaceAll: oldSubCollection with: newCollection\r\t\"Answer a copy of the receiver in which all occurrences of\r\toldSubCollection have been replaced by newCollection \"\r\r\t| aString startSearch currentIndex endIndex |\r\t\r\taString := self.\r\tstartSearch := 1.\r\t[(currentIndex := aString indexOfSubCollection: oldSubCollection startingAt: startSearch) > 0]\r\t\twhileTrue: [\r\t\t\tendIndex := currentIndex + oldSubCollection size - 1.\r\t\t\taString := aString\r\t\t\t\t\tcopyReplaceFrom: currentIndex\r\t\t\t\t\tto: endIndex\r\t\t\t\t\twith: newCollection.\r\t\t\t\tstartSearch := currentIndex + newCollection size].\r\r\t^ aString"},{"name":"endsWith:","linesOfCode":7,"sourceCode":"endsWith: aSequenceableCollection\r\t\"Answer true if the receiver ends with the argument collection\"\r\t\r\t| start |\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\tstart := self size - aSequenceableCollection size.\r\taSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"permutationsStartingAt:do:","linesOfCode":9,"sourceCode":"permutationsStartingAt: anInteger do: aBlock\r\tanInteger > self size\r\t\tifTrue: [ ^ self ].\r\tanInteger = self size\r\t\tifTrue: [ ^ aBlock value: self ].\r\tanInteger to: self size do: [ :i | \r\t\tself swap: anInteger with: i.\r\t\tself permutationsStartingAt: anInteger + 1 do: aBlock.\r\t\tself swap: anInteger with: i ]"},{"name":"asPointArray","linesOfCode":7,"sourceCode":"asPointArray\r\t\"Answer an PointArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| pointArray |\r\tpointArray := PointArray new: self size.\r\t1 to: self size do:[:i| pointArray at: i put: (self at: i)].\r\t^pointArray"},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"asDigitsToPower:do:","linesOfCode":8,"sourceCode":"asDigitsToPower: anInteger do: aBlock\r\t\"Repeatedly value aBlock with a single Array.  Adjust the collection\r\tso that aBlock is presented all (self size raisedTo: anInteger) possible \r\tcombinations of the receiver's elements taken as digits of an anInteger long number.\"\r\r\t\"(Array streamContents: [:stream | (0 to: 1) asDigitsToPower: 4 do: [:each | stream nextPut: each copy]]) >>> #((0 0 0 0) (0 0 0 1) (0 0 1 0) (0 0 1 1) (0 1 0 0) (0 1 0 1) (0 1 1 0) (0 1 1 1) (1 0 0 0) (1 0 0 1) (1 0 1 0) (1 0 1 1) (1 1 1 0) (1 1 1 1))\"\r\r\t| aCollection |\r\taCollection := Array new: anInteger.\r\tself asDigitsAt: 1 in: aCollection do: aBlock"},{"name":"select:","linesOfCode":8,"sourceCode":"select: aBlock \r\t\"Optimized version of Collection>>#select:\"\r\t\r\t\"(#(1 2 3 4) select: [:each | each > 2 ]) >>> #(3 4)\"\r\t\r\t| each |\r\t^ self species new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(aBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"do:without:","linesOfCode":7,"sourceCode":"do: aBlock without: anItem\r\t\"Enumerate all elements in the receiver.\r\tExecute aBlock for those elements that are not equal to the given item\"\r\t\"Refer to the comment in Collection|do:.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] without: 2])) >>> #(11 13)\"\r\t\r\t1 to: self size do:\r\t\t[:index | anItem = (self at: index) ifFalse:[aBlock value: (self at: index)]]"},{"name":"allButLast","linesOfCode":5,"sourceCode":"allButLast\r\t\"Answer a copy of the receiver containing all but the last\r\telement. Raise an error if there are not enough elements.\"\r\t\"#(a b c d) allButLast >>> #(a b c)\"\r\r\t^ self allButLast: 1"},{"name":"after:","linesOfCode":5,"sourceCode":"after: target\r\t\"Answer the element after target.  Raise an error if target is not\r\tin the receiver, or if there are no elements after it.\"\r\t\"(#(a b c d) after: #b) >>> #c\"\r\r\t^ self after: target ifAbsent: [self errorNotFound: target]"},{"name":"reduceRight:","linesOfCode":17,"sourceCode":"reduceRight: aBlock\r\t\"Fold the result of the receiver from right to left into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> (1 - (2 - 3))\"\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> 2\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> (1 + (3 - 5))\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: arguments size put: self last.\r\tself size - arguments size + 1 to: 1 by: 1 - arguments size do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 1 to: aBlock argumentCount - 1 with: self startingAt: index;\r\t\t\tat: arguments size put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments last"},{"name":"lastIndexOf:ifAbsent:","linesOfCode":7,"sourceCode":"lastIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a ifAbsent: 7) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #c ifAbsent: 7) >>> 7\"\r\t\r\t^self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock"},{"name":"=","linesOfCode":8,"sourceCode":"= otherCollection \r\t\"Answer true if the receiver is equivalent to the otherCollection.\r\tFirst test for identity, then rule out different species and sizes of\r\tcollections. As a last resort, examine each element of the receiver\r\tand the otherCollection.\"\r\r\tself == otherCollection ifTrue: [^ true].\r\tself species == otherCollection species ifFalse: [^ false].\r\t^ self hasEqualElements: otherCollection"},{"name":"allButLastDo:","linesOfCode":5,"sourceCode":"allButLastDo: block\r\r\t\"Executes aBlock on each of the receiver's elements except for the last one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButLastDo: [:each | stream nextPut: (each + 10)]]) >>> #(11 12)\"\r\r\t1 to: self size - 1 do:\r\t\t[:index | block value: (self at: index)]"},{"name":"atAll:","linesOfCode":10,"sourceCode":"atAll: indexArray\r\t\"Answer a new collection like the receiver which contains all elements\r\tof the receiver at the indices of indexArray.\"\r\t\"(#('one' 'two' 'three' 'four') atAll: #(3 2 4)) >>> #('three' 'two' 'four')\"\r\r\t| newCollection |\r\tnewCollection := self species ofSize: indexArray size.\r\t1 to: indexArray size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (self at: (indexArray at: index))].\r\t^ newCollection"},{"name":"from:to:do:","linesOfCode":4,"sourceCode":"from: start to: stop do: aBlock\r\t\"Evaluate aBlock for all elements between start and stop (inclusive).\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) from: 2 to: 3 do: [:each | stream nextPut: each]]) >>> #(20 30)\"\r\r\tstart to: stop do: [:index | aBlock value: (self at: index)]"},{"name":"runningMin:","linesOfCode":4,"sourceCode":"runningMin: aSubsetSize\r\t\"Running min. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMin: 3) >>> {1 . 1 . 2 . 2}\"\r\r\t^ self running: [ :subset | subset min ] of: aSubsetSize"},{"name":"beginsWithAnyOf:","linesOfCode":3,"sourceCode":"beginsWithAnyOf: aCollection\r\t\"Return true if the receiver starts with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:prefix| self beginsWith: prefix]"},{"name":"asStringWithCr","linesOfCode":12,"sourceCode":"asStringWithCr\r\t\"Convert to a string with returns between items.  Elements are\rusually strings.\r\t Useful for labels for PopUpMenus.\"\r\t| labelStream |\r\tlabelStream := (String new: 200) writeStream.\r\tself do: [:each |\r\t\teach isString\r\t\t\tifTrue: [labelStream nextPutAll: each; cr]\r\t\t\tifFalse: [each printOn: labelStream. labelStream cr]].\r\tself size > 0 ifTrue: [labelStream skip: -1].\r\t^ labelStream contents"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new: 0"},{"name":"readStreamDo:","linesOfCode":4,"sourceCode":"readStreamDo: aBlock\r\t\"Evaluates the argument with the read stream of the collection. Answers the result.\"\r\t\r\t\"#(3 4 5) readStreamDo: [ :stream | stream contents ] >>> #(3 4 5)\"\r\r\t^ aBlock value: self readStream"},{"name":"with:collect:","linesOfCode":12,"sourceCode":"with: otherCollection collect: twoArgBlock \r\t\"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(#(1 2 3) with: #(4 5 6) collect: [:a :b | a + b]) >>> #(5 7 9)\"\r\t\r\t| result |\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: (otherCollection at: index))].\r\t^ result"},{"name":"groupsOf:","linesOfCode":12,"sourceCode":"groupsOf: n\r\t| groups pos |\r\r\tpos := 0.\r\tgroups := OrderedCollection new.\r\t(n to: self size by: n) do: [ :index | \r\t\t\t| args |\r\t\t\targs := self copyFrom: index - n + 1 to: index.\r\t\t\tgroups add: args.\r\t\t\tpos := pos + n ].\r\tpos < self size ifTrue: [ \r\t\tgroups add: (self copyFrom: pos + 1 to: self size) ].\r\t^ groups"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"#(a b c d e) size >>> 5\"\r\t\"#(x y z) size >>> 3\"\r\t\r\t^ self subclassResponsibility"},{"name":"collect:from:to:","linesOfCode":9,"sourceCode":"collect: aBlock from: firstIndex to: lastIndex\r\t\"Refer to the comment in Collection|collect:.\"\r\t\r\t\"(#(1 2 3 4) collect: [:each | each  + 10] from: 2 to: 3) >>> #(12 13) \"\r\r\t| size result j |\r\tsize := lastIndex - firstIndex + 1.\r\tresult := self species new: size.\r\tj := firstIndex.\r\t1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].\r\t^ result"},{"name":"indexOfAnyOf:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z) ifAbsent: 7) >>> 7\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: exceptionBlock"},{"name":"overlappingPairsCollect:","linesOfCode":8,"sourceCode":"overlappingPairsCollect: aBlock \r\r\t\"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements.\"\r\t\r\t\"(#(1 2 3 4) overlappingPairsCollect: [:first :second| first + second]) >>> #(3 5 7)\"\r\t\r\t| retval |\r\tretval := self species ofSize: self size - 1.\r\t1 to: self size - 1\r\t\tdo: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].\r\t^retval"},{"name":"asIntegerArray","linesOfCode":7,"sourceCode":"asIntegerArray\r\t\"Answer an IntegerArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| intArray |\r\tintArray := IntegerArray new: self size.\r\t1 to: self size do:[:i| intArray at: i put: (self at: i)].\r\t^intArray"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first element of the receiver\"\r\t\"#(a b c d e f g h ) first >>> #a\"\r\r\t^ self at: 1"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"permutationsDo:","linesOfCode":5,"sourceCode":"permutationsDo: aBlock\r\t\"Repeatly value aBlock with a single copy of the receiver. Reorder the copy\r\tso that aBlock is presented all (self size factorial) possible permutations.\"\r\r\t\"(Array streamContents: [:stream | (1 to: 3) permutationsDo: [:each | stream nextPut: each copy]]) >>> #(#(1 2 3) #(1 3 2) #(2 1 3) #(2 3 1) #(3 2 1) #(3 1 2))\"\r\r\tself shallowCopy permutationsStartingAt: 1 do: aBlock"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":10,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"This destructively replaces elements from start to stop in the receiver \r\tstarting at index, repStart, in the sequenceable collection, \r\treplacementCollection. Answer the receiver. No range checks are \r\tperformed.\"\r\r\t| index repOff |\r\trepOff := repStart - start.\r\tindex := start - 1.\r\t[(index := index + 1) <= stop]\r\t\twhileTrue: [self at: index put: (replacement at: repOff + index)]"},{"name":"reduce:","linesOfCode":7,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> 6\" \"1 + 2 + 3\"\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> (1 + 2 + 3)\"\r\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> 15\"\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> (1 + 2 + 3 + 4 + 5)\"\r\r\t^ self reduceLeft: aBlock"},{"name":"atLast:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1, returns the last element\"\r\t\"(#(x y z) atLast: 1) >>> #z\"\r\t\"(#(x y z) atLast: 2) >>> #y\"\r\r\t^ self atLast: indexFromEnd ifAbsent: [self error: 'index out of range']"},{"name":"rsSwapElement:withElement:","linesOfCode":6,"sourceCode":"rsSwapElement: u withElement: v\r\t| index1 index2 |\r\tindex1 := self indexOf: u.\r\tindex2 := self indexOf: v.\r\tself at: index2 put: u.\r\tself at: index1 put: v."},{"name":"gtInspectorItemsIn:","linesOfCode":21,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self ];\r\t\tbeMultiple;\r\t\tenableElementIndex;\r\t\twantsAutomaticRefresh: true;\r\t\tcolumn: 'Index' evaluated: [ :value :idex | idex asString ] width: 50;\r\t\tcolumn: 'Item' evaluated: [ :value | GTObjectPrinter asTruncatedTextFrom: value ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult ifNotNil: [ \r\t\t\t\tresult isCollection ifTrue: [ \r\t\t\t\t\tresult size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] \r\t\t\t\t] ifFalse: [ result ]\r\t\t\t]\r\t\t]"},{"name":"fasterDifferencePreservingOrder:","linesOfCode":8,"sourceCode":"fasterDifferencePreservingOrder: aCollection\r\t\" this implementation does not preserve the original species of self ! it serves ONE specific use case only \"\r\t| newCollection |\r\tnewCollection := OrderedCollection new: self size.\r\tself do: [ :each | \r\t\t(aCollection includes: each) \r\t\t\tifFalse: [ newCollection add: each ] ].\r\t^ newCollection"},{"name":"detectIndex:","linesOfCode":5,"sourceCode":"detectIndex: aBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, raise an error.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ]) >>> 2\"\r\r\t^ self detectIndex: aBlock ifNone: [ self errorNotFound: aBlock ] "},{"name":"piecesCutWhere:do:","linesOfCode":17,"sourceCode":"piecesCutWhere: binaryBlock do: pieceBlock\r\t\"Evaluate pieceBlock with substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\r\t\"(Array streamContents: [:stream |  #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]] do: [:each | stream nextPut: each size]]) >>> #(1 5 3)\"\r\r\t| size lastCut this next |\r\t(size := self size) <= 1 ifTrue:\r\t\t [size = 1 ifTrue: [pieceBlock value: self].\r\t\t^self].\r\tlastCut := 1.\r\tthis := self at: 1.\r\t2 to: size do:\r\t\t[:i|\r\t\tnext := self at: i.\r\t\t(binaryBlock value: this value: next) ifTrue:\r\t\t\t[pieceBlock value: (self copyFrom: lastCut to: i - 1).\r\t\t\tlastCut := i].\r\t\tthis := next].\r\tpieceBlock value: (self copyFrom: lastCut to: size)"},{"name":"sorted","linesOfCode":6,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\"#(8 5 3 9) sorted >>> #(3 5 8 9)\"\r\t\"#(a b z d) sorted >>> #(a b d z)\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"lastIndexOfAnyOf:startingAt:ifAbsent:","linesOfCode":9,"sourceCode":"lastIndexOfAnyOf: aCollection startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOfAnyOf: #(a b) startingAt: 1 ifAbsent: 7) >>> 1\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"reverse","linesOfCode":3,"sourceCode":"reverse\r\t\"Answer a copy of the receiver with element order reversed, as expected by ANSI.\"\r\r\t^ self reversed"},{"name":"sort","linesOfCode":5,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\t\"#(8 5 3 9) sort >>> #(3 5 8 9)\"\r\t\"#(a b z d) sort >>> #(a b d z)\"\r\t\r\tself sort: [:a :b | a <= b]"},{"name":"atWrap:","linesOfCode":8,"sourceCode":"atWrap: index\r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 2) >>> 22\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 4) >>> 11\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 5) >>> 22\"\r    \r    ^ self at: index - 1 \\\\ self size + 1"},{"name":"findBinary:do:ifNone:","linesOfCode":24,"sourceCode":"findBinary: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the found element as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements or nil as arguments.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 11\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(11 15)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(nil 1)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :foundIndex | actionBlock value: (self at: foundIndex) ]\r\t\tifNone: [ :prevIndex :nextIndex | \r\t\t\texceptionBlock\r\t\t\t\tcull:\r\t\t\t\t\t(prevIndex > 0\r\t\t\t\t\t\tifTrue: [ self at: prevIndex ])\r\t\t\t\tcull:\r\t\t\t\t\t(nextIndex <= self size\r\t\t\t\t\t\tifTrue: [ self at: nextIndex ]) ]"},{"name":"joinUsing:","linesOfCode":3,"sourceCode":"joinUsing: joiner\r\t\"Append the elements of the receiver separating them with the joiner - character, string or sequenceable collection. Return collection of the same collection class as 'joiner', or a String\"\r\t^ joiner join: self"},{"name":"piecesCutWhere:","linesOfCode":10,"sourceCode":"piecesCutWhere: binaryBlock\r\t\"Answer substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\"( #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]]) asArray >>> #(#(1) #(2 3 1 6 1) #(2 3 4))\"\r\t| pieces |\r\tpieces := OrderedCollection new.\r\tself \r\t\tpiecesCutWhere: binaryBlock\r\t\tdo: [ :piece | pieces add: piece ].\r\t^pieces\r\r   \"'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'  piecesCutWhere: [:a :b| a = $. and: [b isSeparator]]\""},{"name":"anyOne","linesOfCode":7,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t^ self first"},{"name":",","linesOfCode":7,"sourceCode":", otherCollection \r\t\"Concatenate two Strings or Collections.\"\r\t\"#(2 4 6 8) , #(who do we appreciate) >>> #(2 4 6 8 who do we appreciate)\"\r\t\"((2989 storeStringBase: 16) copyFrom: 4 to: 6) , ' boy!' >>> 'BAD boys!'\"\r\t\r\t^ self copyReplaceFrom: self size + 1\r\t\t  to: self size\r\t\t  with: otherCollection\r"},{"name":"copyUpTo:","linesOfCode":4,"sourceCode":"copyUpTo: anElement \r\t\"Answer all elements up to but not including anObject. If there\r\tis no such object, answer a copy of the receiver.\"\r\r\t^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"asPetit2Stream","linesOfCode":3,"sourceCode":"asPetit2Stream\r\t^ PP2Stream on: self\r\t\"^ PP2BufferStream on: (ReadStream on: self)\""},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"atWrap:put:","linesOfCode":8,"sourceCode":"atWrap: index put: value\r\t\"Store value into the index'th element of the receiver.  If index is out\r\tof bounds, let it wrap around from the end to the beginning until it \r\tis in bounds. Answer value.\"\r\t\"(#(11 22 33) asOrderedCollection atWrap: 2 put: 0; yourself) >>> #(11 0 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 4 put: 0; yourself) >>> #(0 22 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 6 put: 0; yourself) >>> #(11 22 0)\"\r\r\t^ self at: index  - 1 \\\\ self size + 1 put: value"},{"name":"asGPUFloat32x4Array","linesOfCode":2,"sourceCode":"asGPUFloat32x4Array\r\t^ self asGPUArrayOfType: #Float32x4"},{"name":"replace:","linesOfCode":6,"sourceCode":"replace: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into self.\"\r\t\r\t\"(#(1 2 3 4) replace: [:each | each + 1 ]) >>> #(2 3 4 5)\"\r\r\t1 to: self size do: [ :index |\r\t\tself at: index put: (aBlock value: (self at: index)) ]"},{"name":"sortedAs:","linesOfCode":20,"sourceCode":"sortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 < t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) < (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"asWordArray","linesOfCode":7,"sourceCode":"asWordArray\r\t\"Answer a WordArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| wordArray |\r\twordArray := WordArray new: self size.\r\t1 to: self size do:[:i| wordArray at: i put: (self at: i)].\r\t^wordArray"},{"name":"lastIndexOf:","linesOfCode":6,"sourceCode":"lastIndexOf: anElement\r\t\"Answer the index of the last occurrence of anElement within the \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b a d a) lastIndexOf: #a) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #a) >>> 3\"\r\r\t^ self lastIndexOf: anElement startingAt: self size ifAbsent: [0]"},{"name":"asDigitsAt:in:do:","linesOfCode":7,"sourceCode":"asDigitsAt: anInteger in: aCollection do: aBlock\r\tself\r\t\tdo: [ :each | \r\t\t\taCollection at: anInteger put: each.\r\t\t\tanInteger = aCollection size\r\t\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\t\tifFalse: [ self asDigitsAt: anInteger + 1 in: aCollection do: aBlock ] ]"},{"name":"readStream","linesOfCode":2,"sourceCode":"readStream\r\t^ ReadStream on: self"},{"name":"allButFirstDo:","linesOfCode":5,"sourceCode":"allButFirstDo: aBlock\r\r\t\"Executes aBlock on each of the receiver's elements except for the first one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButFirstDo: [:each | stream nextPut: (each + 10)]]) >>> #(12 13)\"\r\r\t2 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"lastIndexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a startingAt: 1 ifAbsent: 7) >>> 1\"\r\t\"(#(e b a d e) lastIndexOf: #a startingAt: 4 ifAbsent: 7) >>> 3\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"overlappingPairsDo:","linesOfCode":5,"sourceCode":"overlappingPairsDo: aBlock \r\r\t\"Emit overlapping pairs of my elements into aBlock\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) overlappingPairsDo: [:first :second| stream nextPut: (first + second)]]) >>> #(3 5 7)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1)]"},{"name":"second","linesOfCode":5,"sourceCode":"second\r\t\"Answer the second element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) second >>> #b\"\r\r\t^ self at: 2"},{"name":"ninth","linesOfCode":5,"sourceCode":"ninth\r\t\"Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) ninth >>> #i\"\r\r\t^ self at: 9"},{"name":"@","linesOfCode":2,"sourceCode":"@ aCollection \r\t^ self with: aCollection collect: [:a :b | a @ b]"},{"name":"writeStreamDo:","linesOfCode":4,"sourceCode":"writeStreamDo: aBlock\r\t\"Evaluates the argument with the write stream of the collection. Answers the result.\"\r\t\r\t\"(#() writeStreamDo: [ :stream | stream nextPut: '4'; space; nextPutAll: '34'. stream contents ]) >>> {'4'. Character space. $3. $4}\"\r\r\t^ aBlock value: self writeStream"},{"name":"copyWithoutFirst","linesOfCode":4,"sourceCode":"copyWithoutFirst\r\t\"Deprecatd. Return a copy of the receiver which doesn't include\r\tthe first element.\"\r\r\t^ self allButFirst"},{"name":"findBinaryIndex:do:ifNone:","linesOfCode":27,"sourceCode":"findBinaryIndex: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the index as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the indexes of the 'bounding' elements as arguments.\r\tWarning: Might give invalid indexes, see examples below\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 5\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(5 6)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(0 1)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\t\t\r\t| index low high test |\r\tlow := 1.\r\thigh := self size.\r\t[ index := high + low // 2.\r\t  low > high ] whileFalse: [\r\t\ttest := aBlock value: (self at: index).\r\t\ttest = 0 \r\t\t\tifTrue: [ ^ actionBlock value: index ]\r\t\t\tifFalse: [ test > 0\r\t\t\t\tifTrue: [ low := index + 1 ]\r\t\t\t\tifFalse: [ high := index - 1 ] ] ].\r\t^ exceptionBlock cull: high cull: low"},{"name":"combinations","linesOfCode":7,"sourceCode":"combinations\r\t\"Return all the combinations of elements of the receiver. Note that combinations does not include the empty element contrary to the mathematical definition of combinations.\"\r\r\t\"#(1 2 3 4) combinations >>> #(#(1) #(2) #(3) #(4) #(1 2) #(1 3) #(1 4) #(2 3) #(2 4) #(3 4) #(1 2 3) #(1 2 4) #(1 3 4) #(2 3 4) #(1 2 3 4))\"\r\r\t^ Array\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do:\r\t\t\t\t[ :take | self combinations: take atATimeDo: [ :combination | stream nextPut: combination copy ] ] ]"},{"name":"with:do:","linesOfCode":8,"sourceCode":"with: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) with: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(5 7 9)\"\r\t\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\t1 to: self size do:\r\t\t[:index |\r\t\ttwoArgBlock value: (self at: index)\r\t\t\t\tvalue: (otherCollection at: index)]"},{"name":"shuffle","linesOfCode":4,"sourceCode":"shuffle\r\t\"Modify the receiver but with its elements in random positions.\r\tThis method use Random class as random generator\"\r\t\r\t^ self shuffleBy: Random new"},{"name":"findBinaryIndex:","linesOfCode":12,"sourceCode":"findBinaryIndex: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]) >>> 5\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :found | found ]\r\t\tifNone: [ self errorNotFound: aBlock ]"},{"name":"findBinary:ifNone:","linesOfCode":15,"sourceCode":"findBinary: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: [:a :b | 'over ', a printString]) >>> 'over 23'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\t\r\t^ self \r\t\tfindBinary: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"reject:","linesOfCode":8,"sourceCode":"reject: rejectBlock \r\t\"Optimized version of Collection>>#reject:\"\r\t\r\t\"#(1 2 3 4) reject: [:each | each = 3 ] >>> #(1 2 4)\"\r\t\r\t| each |\r\t\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"indexOf:startingAt:","linesOfCode":5,"sourceCode":"indexOf: anElement startingAt: start\r       \"Answer the index of the first occurrence of anElement after start within the receiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4) >>> 0\"\r\r\t^self indexOf: anElement startingAt: start ifAbsent: 0"},{"name":"withIndexCollect:","linesOfCode":11,"sourceCode":"withIndexCollect: elementAndIndexBlock \r\t\"Just like with:collect: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(#(10 20 30) withIndexCollect: [:each :index | each + (index * 2)]) >>> #(12 24 36)\"\r\t\r\t| result |\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(elementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index)].\r\t^ result"},{"name":"nextToLast","linesOfCode":3,"sourceCode":"nextToLast\r\t\"(#(1 2 3 4) nextToLast) >>> 3\"\r\t^self at: self size - 1"},{"name":"withIndexSelect:","linesOfCode":10,"sourceCode":"withIndexSelect: elementAndIndexBlock\r\t\"select elements from the receiver that the block evaluates true with the element and its index.\"\r\r\t\"(#('We' 'love' 'pharo!') withIndexSelect: [:value :index | value size - 1 <= index]) >>> #('We')\"\r\r\t^ self class\r\t\tnew: self size\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do: [ :index | \r\t\t\t\t| each |\r\t\t\t\t(elementAndIndexBlock value: (each := self at: index) value: index)\r\t\t\t\t\tifTrue: [ stream nextPut: each ] ] ]"},{"name":"writeStream","linesOfCode":2,"sourceCode":"writeStream\r\t^ WriteStream on: self"},{"name":"endsWithAnyOf:","linesOfCode":3,"sourceCode":"endsWithAnyOf: aCollection\r\t\"Return true if the receiver ends with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:suffix| self endsWith: suffix]"},{"name":"findFirst:","linesOfCode":10,"sourceCode":"findFirst: aBlock\r\t\"Return the index of my first element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(1 5 10) findFirst: [ :each | each > 3 ]) >>> 2\"\r\t\"(#(1 5 10) findFirst: [ :each | each > 15 ]) >>> 0\"\r\r\t| index |\r\tindex := 0.\r\t[(index := index + 1) <= self size] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reversed","linesOfCode":9,"sourceCode":"reversed\r\t\"Answer a copy of the receiver with element order reversed.\"\r\t\"Example: 'frog' reversed\"\r\r\t| n result src |\r\tn := self size.\r\tresult := self species new: n.\r\tsrc := n + 1.\r\t1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].\r\t^ result\r"},{"name":"indexOfSubCollection:startingAt:","linesOfCode":11,"sourceCode":"indexOfSubCollection: aSubCollection startingAt: anIndex \r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of aSubCollection, and the next elements equal \r\tthe rest of the elements of aSubCollection. Begin the search at element \r\tanIndex of the receiver. If no such match is found, answer 0.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4) >>> 0\"\r\r\t^self\r\t\tindexOfSubCollection: aSubCollection\r\t\tstartingAt: anIndex\r\t\tifAbsent: [0]"},{"name":"copyAfter:","linesOfCode":5,"sourceCode":"copyAfter: anElement\r\t\"Answer a copy of the receiver from after the first occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"combinationsAt:in:after:do:","linesOfCode":12,"sourceCode":"combinationsAt: jj in: aCollection after: nn do: aBlock\r\t\"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1.\"\r\r\tnn + 1 to: self size do: [ :index | \r\t\taCollection at: jj put: (self at: index).\r\t\tjj = aCollection size\r\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\tifFalse: [ \r\t\t\t\tself\r\t\t\t\t\tcombinationsAt: jj + 1\r\t\t\t\t\tin: aCollection\r\t\t\t\t\tafter: index\r\t\t\t\t\tdo: aBlock ] ]"},{"name":"reverseSortedAs:","linesOfCode":20,"sourceCode":"reverseSortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 > t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) > (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"from:to:put:","linesOfCode":20,"sourceCode":"from: startIndex to: endIndex put: anObject\r\t\"Put anObject in all indexes between startIndex \r\tand endIndex. Very fast. Faster than to:do: for\r\tmore than 26 positions. Answer anObject\"\r\t\"(#(a b c d e) from: 3 to: 4 put: #x; yourself) >>> #(a b x x e)\"\r\r\t| written toWrite thisWrite |\r\r\tstartIndex > endIndex ifTrue: [^self].\r\tself at: startIndex put: anObject.\r\twritten := 1.\r\ttoWrite := endIndex - startIndex + 1.\r\t[written < toWrite] whileTrue:\r\t\t[\r\t\t\tthisWrite := written min: toWrite - written.\r\t\t\tself \r\t\t\t\treplaceFrom: startIndex + written\r\t\t\t\tto: startIndex + written + thisWrite - 1\r\t\t\t\twith: self startingAt: startIndex.\r\t\t\twritten := written + thisWrite\r\t\t].\r\t^anObject"},{"name":"reduceLeft:","linesOfCode":17,"sourceCode":"reduceLeft: aBlock\r\t\"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ])>>> ((1 - 2) - 3)\"\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ]) >>> -4\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> ((1 + 3) - 5)\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: 1 put: self first.\r\t2 to: self size by: arguments size - 1 do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 2 to: arguments size with: self startingAt: index;\r\t\t\tat: 1 put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments first"},{"name":"at:ifAbsent:","linesOfCode":7,"sourceCode":"at: index ifAbsent: exceptionBlock \r\t\"Answer the element at my position index. If I do not contain an element \r\tat index, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d) at: 3 ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) at: 5 ifAbsent: #z) >>> #z\"\r\r\t(index between: 1 and: self size) ifTrue: [^ self at: index].\r\t^ exceptionBlock value"},{"name":"detectIndex:ifNone:","linesOfCode":7,"sourceCode":"detectIndex: aBlock ifNone: exceptionBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, evaluate exceptionBlock.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ] ifNone: ['Not found']) >>> 2\"\r\t\"(#(1 5 10) detectIndex: [ :each | each > 15 ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\tself doWithIndex: [:each :index | (aBlock value: each) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"select:thenCollect:","linesOfCode":8,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#select:thenCollect:\"\r\t\r\t\"(#(1 2 3 4)  select: [:each | each > 2 ] thenCollect: [:each | each + 10 ]) >>> #(13 14)\"\r\t\r\t| each |\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(selectBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"asColorArray","linesOfCode":2,"sourceCode":"asColorArray\r\t^ColorArray withAll: self"},{"name":"copyWithoutIndex:","linesOfCode":7,"sourceCode":"copyWithoutIndex: index\r\t\"Return a copy containing all elements except the index-th.\"\r\r\t| copy |\r\tcopy := self species ofSize: self size - 1.\r\tcopy replaceFrom: 1 to: index-1 with: self startingAt: 1.\r\tcopy replaceFrom: index to: copy size with: self startingAt: index+1.\r\t^ copy"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ CollectionValueHolder value: self"},{"name":"middle","linesOfCode":5,"sourceCode":"middle\r\t\"Answer the middle element of the receiver.\"\r\t\"#(a b c d e) middle >>> #c\"\r\t\"#(a b c d) middle >>> #c\"\r\t\r\t^ self at: self size // 2 + 1"},{"name":"keysAndValuesDo:","linesOfCode":4,"sourceCode":"keysAndValuesDo: aBlock \r\t\"Enumerate the receiver with all the keys (aka indices) and values.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) keysAndValuesDo:  [:key :value | stream nextPut: (key * 2 + value)]]) >>> #(12 24 36)\"\r\r\t1 to: self size do: [:index | aBlock value: index value: (self at: index)]"},{"name":"pairsCollect:","linesOfCode":5,"sourceCode":"pairsCollect: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time, and return an Array with the results\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect: [:a :b | b, ' is number ', a printString]) >>> #('fred is number 1' 'charlie is number 2' 'elmer is number 3')\"\r\r\t^ (1 to: self size // 2)\r\t\tcollect: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"fourth","linesOfCode":5,"sourceCode":"fourth\r\t\"Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fourth >>> #d\"\r\r\t^ self at: 4"},{"name":"splitOn:indicesDo:","linesOfCode":4,"sourceCode":"splitOn: splitter indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of the receiver element that have been identified by splitting the receiver using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:5 s:7 e:8 s:10 e:13 '\"\r\t\r\t\r\t^ splitter split: self indicesDo: aBlock"},{"name":"asGPUFloat32Array","linesOfCode":2,"sourceCode":"asGPUFloat32Array\r\t^ self asGPUArrayOfType: #Float32"},{"name":"atAllPut:","linesOfCode":7,"sourceCode":"atAllPut: anObject \r\t\"Put anObject at every one of the receiver's indices.\"\r\t\"(#(x y z) atAllPut: #a) >>> #(a a a)\"\r\r\t| size |\r\t(size := self size) > 26 \"first method faster from 27 accesses and on\"\r\t\tifTrue: [self from: 1 to: size put: anObject]\r\t\tifFalse: [1 to: size do: [:index | self at: index put: anObject]]"},{"name":"after:ifAbsent:","linesOfCode":11,"sourceCode":"after: target ifAbsent: exceptionBlock\r\t\"Answer the element after target.  Answer the result of evaluation\r\tthe exceptionBlock if target is not in the receiver, or if there are \r\tno elements after it.\"\r\t\"(#(a b c d) after: #b ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) after: #x ifAbsent: #z) >>> #z\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = self size])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index + 1]"},{"name":"identityIndexOf:ifAbsent:","linesOfCode":9,"sourceCode":"identityIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer the result of evaluating the argument, \r\texceptionBlock.\"\r\t\"(#(a b c d e) identityIndexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x ifAbsent: 7) >>> 7\"\r\t\r\t1 to: self size do:\r\t\t[:i | (self at: i) == anElement ifTrue: [^ i]].\r\t^ exceptionBlock value"},{"name":"replaceFrom:to:with:","linesOfCode":8,"sourceCode":"replaceFrom: start to: stop with: replacement \r\t\"This destructively replaces elements from start to stop in the receiver. \r\tAnswer the receiver itself. Use copyReplaceFrom:to:with: for \r\tinsertion/deletion which may alter the size of the result.\"\r\t\"(#(a b c d e) replaceFrom: 3 to: 4 with: #(x y)) >>> #(a b x y e)\"\r\r\treplacement size = (stop - start + 1)\r\t\tifFalse: [self error: 'Size of replacement doesnt match'].\r\t^self replaceFrom: start to: stop with: replacement startingAt: 1"},{"name":"shuffled","linesOfCode":2,"sourceCode":"shuffled\r\t^ self copy shuffle"},{"name":"mergeSortFrom:to:by:","linesOfCode":21,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\t\"(#(a b z d i l) mergeSortFrom: 3 to: 5 by: [ :a :b | a<=b ]) >>> #(a b d i z l)\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"},{"name":"sort:","linesOfCode":10,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\t\"(#(3 9 1) sort: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sort: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sort: #last ascending) >>> #(xa xb xc xy xz)\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"indexOf:","linesOfCode":6,"sourceCode":"indexOf: anElement\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x) >>> 0\"\r\r\t^ self indexOf: anElement ifAbsent: 0"},{"name":"groupsOf:atATimeCollect:","linesOfCode":16,"sourceCode":"groupsOf: n atATimeCollect: aBlock\r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end. \r\tAllows use of a flattened array for things that naturally group into groups of n. \r\tIf aBlock has a single argument, pass it an array of n items, otherwise, pass the items as separate arguments. See also pairsDo:\"\r\r\t\"(#(16 17 17 16 18 17 18   19 19 19 18 19 19 20   19 20 19 20 20 20 19   20) groupsOf: 7 atATimeCollect: [ :x | x ]) >>> #(#(16 17 17 16 18 17 18) #(19 19 19 18 19 19 20) #(19 20 19 20 20 20 19))\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x :y :z | x + y + z]) >>> #(3 30 300)\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x | x ]) >>> #(#(1 1 1) #(10 10 10) #(100 100 100))\"\r\r\t| passArray |\r\tpassArray := aBlock numArgs <= 1.\r\t^ (n to: self size by: n)\r\t\tcollect: [ :index | \r\t\t\t| args |\r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray\r\t\t\t\tifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ] ]"},{"name":"collect:thenReject:","linesOfCode":9,"sourceCode":"collect: collectBlock thenReject: rejectBlock\r\t\"Optimized version of Collection>>#thenReject:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenReject: [:each | each even]) >>> #(11 13)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"copyFrom:to:","linesOfCode":10,"sourceCode":"copyFrom: start to: stop \r\t\"Answer a copy of a subset of the receiver, starting from element at \r\tindex start until element at index stop.\"\r\r\t| newSize |\r\tnewSize := stop - start + 1.\r\t^(self species new: newSize)\r\t\treplaceFrom: 1\r\t\tto: newSize\r\t\twith: self\r\t\tstartingAt: start"},{"name":"copyWithFirst:","linesOfCode":11,"sourceCode":"copyWithFirst: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element.\"\r\r\t| newIC |\r\tnewIC := self species ofSize: self size + 1.\r\tnewIC \r\t\treplaceFrom: 2\r\t\tto: self size + 1\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: 1 put: newElement.\r\t^ newIC"},{"name":"copyUpThrough:","linesOfCode":4,"sourceCode":"copyUpThrough: anElement\r    \"Answer all elements up to and including anObject. If there\r     is no such object, answer a copy of the receiver.\"\r\r\t^self first: (self indexOf: anElement ifAbsent: [^ self copy])"},{"name":"asPetit2Context","linesOfCode":2,"sourceCode":"asPetit2Context\r\t^ PP2InMemoryContext on: self position: 0"},{"name":"sixth","linesOfCode":5,"sourceCode":"sixth\r\t\"Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) sixth >>> #f\"\r\r\t^ self at: 6"},{"name":"atLast:ifAbsent:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd ifAbsent: block\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1 ifAbsent: [] returns the last element\"\r\t\"(#(x y z) atLast: 1 ifAbsent: #a) >>> #z\"\r\t\"(#(x y z) atLast: 4 ifAbsent: #a) >>> #a\"\r\r\t^ self at: self size + 1 - indexFromEnd ifAbsent: block"},{"name":"grownBy:","linesOfCode":7,"sourceCode":"grownBy: length\r\t\"Answer a copy of receiver collection with size grown by length\"\r\r\t| newCollection size |\r\tsize := self size.\r\tnewCollection := self species ofSize: size + length.\r\tnewCollection replaceFrom: 1 to: size with: self startingAt: 1.\r\t^ newCollection"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2 ifAbsent: 7) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ (self indexOf: anObject) ~= 0"},{"name":"asGPUFloat64Array","linesOfCode":2,"sourceCode":"asGPUFloat64Array\r\t^ self asGPUArrayOfType: #Float64"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\t\r\t\"#(1 2 3) collect: [:each | each  + 10] >>> #(11 12 13) \"\r\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\t1 to: self size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (aBlock value: (self at: index))].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last element of the receiver\"\r\t\"#(a b c d e) last >>> #e\"\r\r\t^ self at: self size"},{"name":"copyUpToLast:","linesOfCode":4,"sourceCode":"copyUpToLast: anElement\r\t\"Answer a copy of the receiver from index 1 to the last occurrence of \r\tanElement, not including anElement.\"\r\r\t^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"last:","linesOfCode":8,"sourceCode":"last: n\r\t\"Answer the last n elements of the receiver.  \r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e) last: 2) >>> #(d e)\"\r\t\"(#(a b c d e) last: 3) >>> #(c d e)\"\r\r\t| size |\r\tsize := self size.\r\t^ self copyFrom: size - n + 1 to: size"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\"\r\r\t^ Array withAll: self"},{"name":"findLast:","linesOfCode":10,"sourceCode":"findLast: aBlock\r\t\"Return the index of my last element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 10 ]) >>> 5\"\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 60 ]) >>> 0\"\r\t\r\t| index |\r\tindex := self size + 1.\r\t[(index := index - 1) >= 1] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reverseWith:do:","linesOfCode":10,"sourceCode":"reverseWith: aSequenceableCollection do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements, in reverse order, \r\talong with the  corresponding element, also in reverse order, from \r\taSequencableCollection. \"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseWith: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(9 7 5)\"\r\r\tself size ~= aSequenceableCollection size ifTrue: [^ self errorSizeMismatch].\r\tself size to: 1 by: -1 do: [:index | \r\t\t\taBlock \r\t\t\t\tvalue: (self at: index)\r\t\t\t\tvalue: (aSequenceableCollection at: index)]"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#select:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) select: [:each | each > 2 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(13 14)\"\r\t\r\t| each |\r\t1 to: self size do: [ :index |\r\t\t(selectBock value: (each := self at: index))\r\t\t\tifTrue: [ aBlock value: each ]]."},{"name":"before:ifAbsent:","linesOfCode":11,"sourceCode":"before: target ifAbsent: exceptionBlock\r\t\"Answer the receiver's element immediately before target. Answer\r\tthe result of evaluating the exceptionBlock if target is not an element\r\tof the receiver, or if there are no elements before it.\"\r\t\"(#(11 22 33) before: 22 ifAbsent: 55) >>> 11\"\r\t\"(#(11 22 33) before: 44 ifAbsent: 55) >>> 55\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = 1])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index - 1]"},{"name":"asMoebiusBandCollectionWithContext","linesOfCode":2,"sourceCode":"asMoebiusBandCollectionWithContext\r\t^ MbndCollectionWithContext new collection: self"},{"name":"atRandom:","linesOfCode":7,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver.  Uses aGenerator which\r\tshould be kept by the user in a variable and used every time. Use\r\tthis instead of #atRandom for better uniformity of random numbers \r\tbecause only you use the generator.  Causes an error if self has no \r\telements.\"\r\r\t^ self at: (aGenerator nextInteger: self size)"},{"name":"findBinaryIndex:ifNone:","linesOfCode":14,"sourceCode":"findBinaryIndex: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'over index: ', a printString ]) >>> 'over index: 7' \"\r\r\t^ self \r\t\tfindBinaryIndex: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"copyAfterLast:","linesOfCode":5,"sourceCode":"copyAfterLast: anElement\r\t\"Answer a copy of the receiver from after the last occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"takeFirst:","linesOfCode":2,"sourceCode":"takeFirst: anInteger\r\t^ self first: (self size min: anInteger)"},{"name":"withIndexDo:","linesOfCode":4,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\r\t\"(Array streamContents: [:stream| #(11 22 13) withIndexDo: [ :each :i | stream nextPut: (each * each + i)]]) >>> #(122 486 172)\"\r\r\t1 to: self size do: [ :index | elementAndIndexBlock value: (self at: index) value: index ]"},{"name":"groupByRuns:","linesOfCode":21,"sourceCode":"groupByRuns: aBlock\r\t\"Answer a new collection of the same species as the receiver with elements being collections (of the receiver species) containing those elements of the receiver for which the given block consecutively evaluates to the same object.\"\r\r\t\"(#(1 2 3 4 4 1 2 3 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4 4) #(1 2 3 5 6))\"\r\r\t\"(#(1 2 3 4 1 2 3 4 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4) #(1 2 3) #(4) #(5 6))\"\r\r\t\"((1 to: 12) groupByRuns: [ :each | (each \\\\ 3) = 0]) >>> #(#(1 2) #(3) #(4 5) #(6) #(7 8) #(9) #(10 11) #(12))\"\r\r\t| str eStr r |\r\tstr := Array new writeStream.\r\tr := nil.\r\teStr := Array new writeStream.\r\tself\r\t\tdo: [ :e | \r\t\t\t| t |\r\t\t\t(t := aBlock value: e) = r\r\t\t\t\tifFalse: [ r := t.\r\t\t\t\t\teStr isEmpty\r\t\t\t\t\t\tifFalse: [ str nextPut: (eStr contents as: self species).\r\t\t\t\t\t\t\teStr reset ] ].\r\t\t\teStr nextPut: e ].\r\teStr isEmpty\r\t\tifFalse: [ str nextPut: (eStr contents as: self species) ].\r\t^ str contents as: self species"},{"name":"running:of:","linesOfCode":14,"sourceCode":"running: aBlock of: aSubsetSize\r\t\"This is a generalization of a running average (a.k.a. moving average, rolling average) which allows you to apply any given block to the shifting subsets of a given size.\r\t\r\tFor example, given a collection #(1 2 3 4 5) and a window size 2, we collect subsets of this collection by starting with first 2 elements and shifting the window 1 element to the right: #((1 2)(2 3)(3 4)(4 5)), then we apply aBlock to each subset and collect the results. For example, if aBlock is [ :subset | subset average ], this will give us #(1.5 2.5 3.5 4.5)\"\r\t| result |\r\t\r\taSubsetSize > self size ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size can not exceed the size of a collection' ].\r\t\t\r\taSubsetSize < 0 ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size must be positive' ].\r\t\r\tresult := (1 to: self size - aSubsetSize + 1) collect: [ :i |\r\t\taBlock value: (self copyFrom: i to: i + aSubsetSize - 1) ].\r\t\r\t^ self species withAll: result"},{"name":"indexOfAnyOf:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c)) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z)) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: [0]"},{"name":"join:","linesOfCode":8,"sourceCode":"join: aCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\r\t\"({Character space. Character space} join: #('Pharo' 'is' 'cool')) >>>  {$P. $h. $a. $r. $o. Character space. Character space. $i. $s. Character space. Character space. $c. $o. $o. $l}\"\r\r\t\"NB: this implementation only works for Array, since WriteStreams only work for Arrays and Strings. (!) Overridden in OrderedCollection and SortedCollection.\"\r\t\r\t^ self class\r\t\tstreamContents: [:stream | aCollection\r\t\t\t\tdo: [:each | each joinTo: stream]\r\t\t\t\tseparatedBy: [stream nextPutAll: self]]"},{"name":"indexOfSubCollection:startingAt:ifAbsent:","linesOfCode":20,"sourceCode":"indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of sub, and the next elements equal \r\tthe rest of the elements of sub. Begin the search at element \r\tstart of the receiver. If no such match is found, answer the result of \r\tevaluating argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4 ifAbsent: 7) >>> 7\"\r\t\r\t| first index |\r\tsub isEmpty ifTrue: [^ exceptionBlock value].\r\tfirst := sub first.\r\tstart to: self size - sub size + 1 do:\r\t\t[:startIndex |\r\t\t(self at: startIndex) = first ifTrue:\r\t\t\t[index := 1.\r\t\t\t[(self at: startIndex+index-1) = (sub at: index)]\r\t\t\t\twhileTrue:\r\t\t\t\t[index = sub size ifTrue: [^startIndex].\r\t\t\t\tindex := index+1]]].\r\t^ exceptionBlock value"},{"name":"eighth","linesOfCode":5,"sourceCode":"eighth\r\t\"Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) eighth  >>> #h\"\r\r\t^ self at: 8"},{"name":"asByteArray","linesOfCode":3,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\"\r\r\t^ ByteArray withAll: self"},{"name":"atAll:put:","linesOfCode":5,"sourceCode":"atAll: aCollection put: anObject \r\t\"Put anObject at every index specified by the elements of aCollection.\"\r\t\"(#(x y z) atAll: #(1 3) put: #e; yourself) >>> #(e y e)\"\r\r\taCollection do: [:index | self at: index put: anObject].\r\t^ anObject"},{"name":"indexOf:ifAbsent:","linesOfCode":7,"sourceCode":"indexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the \r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x ifAbsent: 7) >>> 7\"\r\r\t^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock"},{"name":"fifth","linesOfCode":5,"sourceCode":"fifth\r\t\"Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fifth >>> #e\"\r\r\t^ self at: 5"},{"name":"errorOutOfBounds","linesOfCode":2,"sourceCode":"errorOutOfBounds\r\r\tSubscriptOutOfBounds signal"},{"name":"allButFirst:","linesOfCode":6,"sourceCode":"allButFirst: n\r\t\"Answer a copy of the receiver containing all but the first n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButFirst: 2) >>> #(c d)\"\r\t\"(#(a b c d) allButFirst: 3) >>> #(d)\"\r\t\r\t^ self copyFrom: n + 1 to: self size"},{"name":"atLast:put:","linesOfCode":5,"sourceCode":"atLast: indexFromEnd put: obj\r\t\"Set the element at indexFromEnd from the last position.\r\t atLast: 1 put: obj, sets the last element\"\r\t\"(#(x y z) atLast: 2 put: #e; yourself) >>> #(x e z)\"\r\r\t^ self at: self size + 1 - indexFromEnd put: obj"},{"name":"reverseWithIndexDo:","linesOfCode":7,"sourceCode":"reverseWithIndexDo: elementAndIndexBlock \r\t\"Just like reverseWith:do: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) reverseWithIndexDo: [:each :index | stream nextPut: each + index]]) >>> #(33 22 11)\"\r\t\r\tself size to: 1 by: -1 do: [:index |\r\t\telementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index]"},{"name":"forceTo:paddingStartWith:","linesOfCode":17,"sourceCode":"forceTo: length paddingStartWith: elem \r\t\"Force the length of the collection to length, padding  \r\tthe beginning of the result if necessary with elem.  \r\tNote that this makes a copy.\"\r\t| newCollection padLen |\r\tnewCollection := self species ofSize: length.\r\tpadLen := length - self size max: 0.\r\tnewCollection\r\t\tfrom: 1\r\t\tto: padLen\r\t\tput: elem.\r\tnewCollection\r\t\treplaceFrom: padLen + 1\r\t\tto: ((padLen + self size) min: length)\r\t\twith: self\r\t\tstartingAt:  1.\r\t^ newCollection"},{"name":"appendTo:","linesOfCode":3,"sourceCode":"appendTo: aCollection\r\t\"double dispatch for join:\"\r\t^ aCollection addAllLast: self"},{"name":"shuffleBy:","linesOfCode":5,"sourceCode":"shuffleBy: aRandom\r\t\"Durstenfeld's version of the Fisher-Yates shuffle\"\r\t\"#(1 2 3 4 5) shuffleBy: (Random seed: 42) >>> #(2 5 4 3 1)\"\r\r\tself size to: 2 by: -1 do: [ :i | \r\t\tself swap: i with: (aRandom nextInteger: i) ]"},{"name":"pairsDo:","linesOfCode":4,"sourceCode":"pairsDo: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsDo: [:a :b | Transcript cr; show: b, ' is number ', a printString]) >>> #(1 'fred' 2 'charlie' 3 'elmer')\"\r\r\t1 to: self size // 2 do: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"hasEqualElements:","linesOfCode":12,"sourceCode":"hasEqualElements: otherCollection\r\t\"Answer whether the receiver's size is the same as otherCollection's\r\tsize, and each of the receiver's elements equal the corresponding \r\telement of otherCollection.\r\tThis should probably replace the current definition of #= .\"\r\r\t| size |\r\t(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].\r\t(size := self size) = otherCollection size ifFalse: [^ false].\r\t1 to: size do:\r\t\t[:index |\r\t\t(self at: index) = (otherCollection at: index) ifFalse: [^ false]].\r\t^ true"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t| hash |\r\r\thash := self species hash.\r\t1 to: self size do: [:i | hash := (hash + (self at: i) hash) hashMultiply].\r\t^hash"},{"name":"joinTo:","linesOfCode":3,"sourceCode":"joinTo: stream\r\t\"double dispatch for join:\"\r\t^ stream nextPutAll: self"},{"name":"atAll:putAll:","linesOfCode":6,"sourceCode":"atAll: indexArray putAll: valueArray\r\t\"Store the elements of valueArray into the slots\r\tof this collection selected by indexArray.\"\r\t\"(#(x y z) atAll: #(1 3) putAll: #(a e); yourself) >>> #(a y e)\"\r\r\tindexArray with: valueArray do: [:index :value | self at: index put: value].\r\t^ valueArray"},{"name":"sorted:","linesOfCode":9,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\"(#(3 9 1) sorted: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sorted: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sorted: #last ascending) >>> #(xa xb xc xy xz)\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"third","linesOfCode":5,"sourceCode":"third\r\t\"Answer the third element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) third >>> #c\"\r\r\t^ self at: 3"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ true"},{"name":"forceTo:paddingWith:","linesOfCode":7,"sourceCode":"forceTo: length paddingWith: elem\r\t\"Force the length of the collection to length, padding\r\tif necessary with elem.  Note that this makes a copy.\"\r\r\t| newCollection |\r\tnewCollection := self species new: length withAll: elem.\r\tnewCollection replaceFrom: 1 to: (self size min: length) with: self startingAt: 1.\r\t^ newCollection"},{"name":"asGPUFloat64x3Array","linesOfCode":2,"sourceCode":"asGPUFloat64x3Array\r\t^ self asGPUArrayOfType: #Float64x3"},{"name":"allButLast:","linesOfCode":6,"sourceCode":"allButLast: n\r\t\"Answer a copy of the receiver containing all but the last n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButLast: 2) >>> #(a b)\"\r\t\"(#(a b c d) allButLast: 3) >>> #(a)\"\r\r\t^ self copyFrom: 1 to: self size - n"},{"name":"splitOn:","linesOfCode":6,"sourceCode":"splitOn: splitter\r\t\"Split a collection of objects based on a splitter. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\r\t\"(#(1 2 3 3 4 1 2 3 5 4 6) splitOn: 4) >>> #(#(1 2 3 3) #(1 2 3 5) #(6))asOrderedCollection\"\r\t\"(#(1 2 3 3 4 1 2 3 3 5 6) splitOn: #(3 3)) >>> #(#(1 2) #(4 1 2) #(5 6)) asOrderedCollection\"\r\t\"(#(2 2 3 3 4 1 2 3 3 5) splitOn: [:each | each > 3])>>> #(#(2 2 3 3) #(1 2 3 3) #()) asOrderedCollection\"\r\r\t^ splitter split: self"},{"name":"identityIndexOf:","linesOfCode":6,"sourceCode":"identityIndexOf: anElement \r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer 0.\"\r\t\"(#(a b c d e) identityIndexOf: #c) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x) >>> 0\"\r\r\t^self identityIndexOf: anElement ifAbsent: [0]"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeArray: self"},{"name":"asGPUFloat64x2Array","linesOfCode":2,"sourceCode":"asGPUFloat64x2Array\r\t^ self asGPUArrayOfType: #Float64x2"},{"name":"runningAverage:","linesOfCode":4,"sourceCode":"runningAverage: aSubsetSize\r\t\"Running average (a.k.a. moving average, rolling average). See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningAverage: 2) >>> {1 . (3/2) . 2 . (5/2) . 3}\"\r\r\t^ self running: [ :subset | subset average ] of: aSubsetSize"},{"name":"polynomialEval:","linesOfCode":11,"sourceCode":"polynomialEval: thisX\r\t\"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power.\r\t#(1 2 3) polynomialEval: 2  is 3*X^2 + 2*X + 1 with X = 2\"\r\r\t\"(#(1 2 3) polynomialEval: 2) >>> 17\"\r\r\t| sum valToPower |\r\tsum := self first.\r\tvalToPower := thisX.\r\t2 to: self size do: [ :ind | \r\t\tsum := sum + ((self at: ind) * valToPower).\r\t\tvalToPower := valToPower * thisX ].\r\t^ sum"}],"meta":{"name":"SequenceableCollection class","instanceVariables":[],"methods":[{"name":"streamContents:limitedTo:","linesOfCode":10,"sourceCode":"streamContents: blockWithArg limitedTo: sizeLimit\r\t\"A variant of #streamContents: with a strict size limit\"\r\r\t\"(String streamContents: [:s | 10 timesRepeat: [s nextPutAll: 'foo']] limitedTo: 9) >>> 'foofoofoo'\"\r\r\t| stream |\r\tstream := LimitedWriteStream\r\t\ton: (self streamSpecies new: (100 min: sizeLimit))\r\t\tlimit: sizeLimit\r\t\tlimitBlock: [ ^ stream contents ].\r\tblockWithArg value: stream.\r\t^ stream contents"},{"name":"new:streamContents:","linesOfCode":11,"sourceCode":"new: newSize streamContents: blockWithArg\r\t\"A variant of #streamContents: where the initial or even final size is given to optimize memory consumption\"\r\t\r\t\"(Array new: 3 streamContents: [ :out | 3 timesRepeat: [ out nextPut: 42 ] ]) >>> #(42 42 42)\"\r\t\r\t| stream |\r\tstream := WriteStream on: (self streamSpecies new: newSize).\r\tblockWithArg value: stream.\r\t\"If the write position of stream is at the end of the internal buffer of stream (originalContents),\r\twe can return it directly instead of making a copy as contents would do\"\r\t^ stream position = stream originalContents size\r\t\tifTrue: [ stream originalContents ]\r\t\tifFalse: [ stream contents ]"},{"name":"streamSpecies","linesOfCode":3,"sourceCode":"streamSpecies\r\t\"I return the class that is used for streaming. If override consider overriding #new:streamContents:\"\r\t^ self"},{"name":"ofSize:","linesOfCode":5,"sourceCode":"ofSize: n\r\t\"Create a new collection of size n with nil as its elements.\r\tThis method exists because OrderedCollection new: n creates an\r\tempty collection,  not one of size n.\"\r\t^ self new: n"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCollectionInspector"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to use #streamContents: and #nextPut:\"\r\t\r\t^ self streamContents: [ :stream |\r\t\tstonReader parseListDo: [ :each |\r\t\t\tstream nextPut: each ] ]"},{"name":"<<","linesOfCode":4,"sourceCode":"<< blockWithArg\r\t\"An alias to #streamContents:\"\r\t\r\t\"Array << [ :stream | 0 to: 100 by: 25 do: [ :each | stream nextPut: each ] ] >>> #(0 25 50 75 100)\"\r\t\r\t^ self streamContents: blockWithArg"},{"name":"streamContents:","linesOfCode":8,"sourceCode":"streamContents: blockWithArg\r\t\"Build an instance of the receiver by writing elements to a stream.\r\tMore specifically: blockWithArg will be given a WriteStream on an instance of the receiver.\r\tInside blockWithArg you write elements to the stream to build up the collection.\r\tAt the end, the contents of the stream up to that point will be returned.\r\tNote that the underlying collection grows as needed.\"\r\t\r\t\"(Array streamContents: [ :out | out nextPut: 1; nextPutAll: #(2 3 4); nextPut: 5 ]) >>> #(1 2 3 4 5)\"\r\r\t^ self new: 100 streamContents: blockWithArg"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #SequenceableCollection"}],"meta":null}},{"name":"Array2D","instanceVariables":[{"name":"contents"},{"name":"numberOfColumns"},{"name":"numberOfRows"}],"methods":[{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject\r\t^ contents includes: anObject"},{"name":"intersection:","linesOfCode":5,"sourceCode":"intersection: aCollection\r\t\"Union is in because the result is always a Set.\r\t Difference and intersection are out because the result is like the receiver,\r\t and with irregular seleection that cannot be.\"\r\tself shouldNotImplement"},{"name":"occurrencesOf:","linesOfCode":2,"sourceCode":"occurrencesOf: anObject\r\t^ contents occurrencesOf: anObject"},{"name":"preMultiplyByArray:","linesOfCode":5,"sourceCode":"preMultiplyByArray: a\r\t\"Answer a +* self where a is an Array.\"\r\r\tnumberOfRows = 1 ifFalse: [self error: 'dimensions do not conform'].\r\t^Array2D rows: a size columns: numberOfColumns tabulate: [:row :col |\r\t\t(a at: row) * (contents at: col)]\r"},{"name":"rows:columns:contents:","linesOfCode":8,"sourceCode":"rows: rows columns: columns contents: anArray\r\t[rows isInteger and: [rows >= 0]] assert.\r\t[columns isInteger and: [columns >= 0]] assert.\r\t[rows * columns = anArray size] assert.\r\tnumberOfRows := rows.\r\tnumberOfColumns := columns.\r\tcontents := anArray.\r\t^self"},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^ contents asFloatArray"},{"name":"collect:","linesOfCode":6,"sourceCode":"collect: aBlock\r\t\"Answer a new matrix with transformed elements; transformations should be independent.\"\r\r\t^self class \r\t\trows: numberOfRows \r\t\tcolumns: numberOfColumns \r\t\tcontents: (contents collect: aBlock)"},{"name":"numberOfRows","linesOfCode":2,"sourceCode":"numberOfRows\r\t^ numberOfRows"},{"name":"=","linesOfCode":5,"sourceCode":"= aMatrix\r\t^ aMatrix class == self class\r\t\tand: [ aMatrix numberOfRows = numberOfRows\r\t\t\t\tand: [ aMatrix numberOfColumns = numberOfColumns \r\t\t\t\t\tand: [ aMatrix privateContents = contents ] ] ]"},{"name":"atRows:to:columns:to:ifInvalid:","linesOfCode":7,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element\r\t\"Answer a submatrix [r1..r2][c1..c2] of the receiver.\r\t Portions of the result outside the bounds of the original matrix are filled in with element.\"\r\t|rd cd|\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\t^self class rows: r2-rd columns: c2-cd tabulate: [ :r :c| self at: r+rd at: c+cd ifInvalid: element]\r"},{"name":"asArray","linesOfCode":2,"sourceCode":"asArray\r\t^ contents shallowCopy"},{"name":"asCharacterSet","linesOfCode":2,"sourceCode":"asCharacterSet\r\t^ contents asCharacterSet"},{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^ contents asSet"},{"name":"at:at:ifInvalid:","linesOfCode":5,"sourceCode":"at: rowNumber at: columnNumber ifInvalid: value\r\t\"If rowNumber,columnNumber is a valid index for the receiver, answer the corresponding element. Otherwise, answer value.\"\r\r\t(rowNumber between: 1 and: numberOfRows) ifFalse: [ ^ value ].\r\t(columnNumber between: 1 and: numberOfColumns) ifFalse: [ ^ value ].\r\t^contents at: (rowNumber - 1) * numberOfColumns + columnNumber\r"},{"name":"reject:","linesOfCode":2,"sourceCode":"reject: aBlock\r\tself shouldNotImplement"},{"name":"replaceAll:with:","linesOfCode":3,"sourceCode":"replaceAll: oldObject with: newObject\r\t\"Replace all occurrences of oldObject with newObject in the receiver.\"\r\tcontents replaceAll: oldObject with: newObject"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock\r\t\"Pass elements to aBlock one at a time in row-major order.\"\r\tcontents do: aBlock"},{"name":"with:do:","linesOfCode":4,"sourceCode":"with: aCollection do: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\tself withIndicesDo: [:each :row :column |\r\t\taBlock value: each value: (aCollection at: row at: column)].\r"},{"name":"withIndicesDo:","linesOfCode":6,"sourceCode":"withIndicesDo: aBlock\r\t\r\t| i |\r\ti := 0.\r\t1 to: numberOfRows do: [:row |\r\t\t1 to: numberOfColumns do: [:column |\r\t\t\taBlock value: (contents at: (i := i+1)) value: row value: column]].\r"},{"name":",,","linesOfCode":8,"sourceCode":",, aMatrix\r\t\"Answer a new matrix having the same number of columns as the receiver and aMatrix,\r\t its rows being the rows of the receiver followed by the rows of aMatrix.\"\r\r\t[numberOfColumns = aMatrix numberOfColumns] assert.\r\t^self class \r\t\t\trows: numberOfRows + aMatrix numberOfRows \r\t\t\tcolumns: numberOfColumns\r\t\t\tcontents: contents , aMatrix privateContents\r"},{"name":"asOrderedCollection","linesOfCode":2,"sourceCode":"asOrderedCollection\r\t^ contents asOrderedCollection"},{"name":"with:collect:","linesOfCode":4,"sourceCode":"with: aCollection collect: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\t^self withIndicesCollect: [:each :row :column |\r\t\taBlock value: each value: (aCollection at: row at: column)]\r"},{"name":"rowCount","linesOfCode":2,"sourceCode":"rowCount\r\t^numberOfRows"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ contents size"},{"name":"swapColumn:withColumn:","linesOfCode":8,"sourceCode":"swapColumn: anIndex withColumn: anotherIndex\r\t|a b|\r\r\ta := self indexForRow: 1 andColumn: anIndex.\r\tb := self indexForRow: 1 andColumn: anotherIndex.\r\tnumberOfRows timesRepeat: [\r\t\tcontents swap: a with: b.\r\t\ta := a + numberOfColumns.\r\t\tb := b + numberOfColumns].\r"},{"name":"atRandom:","linesOfCode":2,"sourceCode":"atRandom: aGenerator\r\t^ contents atRandom: aGenerator"},{"name":"identityIncludes:","linesOfCode":2,"sourceCode":"identityIncludes: anObject\r\t^ contents identityIncludes: anObject"},{"name":"atRow:","linesOfCode":6,"sourceCode":"atRow: rowNumber\r\t(rowNumber between: 1 and: numberOfRows)\r\t\tifFalse: [self error: '1st subscript out of range'].\r\t^ contents \r\t\t\tcopyFrom: (rowNumber - 1) * numberOfColumns + 1 \r\t\t\tto: rowNumber*numberOfColumns"},{"name":"asIntegerArray","linesOfCode":2,"sourceCode":"asIntegerArray\r\t^ contents asIntegerArray"},{"name":"printOn:","linesOfCode":9,"sourceCode":"printOn: aStream\r\r\taStream nextPutAll: '('.\r\t(1 to: self numberOfRows) \r\t\tdo: [ :r | \r\t\t\t\t(self atRow: r) \r\t\t\t\t\tdo: [ :each | aStream print: each ] \r\t\t\t\t\tseparatedBy: [ aStream space ]]\r\t\tseparatedBy: [ aStream cr ].\r\taStream nextPutAll: ' )'."},{"name":"shuffledBy:","linesOfCode":2,"sourceCode":"shuffledBy: aRandom\r\t^self class rows: numberOfRows columns: numberOfColumns contents: (contents copy shuffleBy: aRandom)"},{"name":"atRows:to:columns:to:","linesOfCode":6,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2\r\t\"Answer a submatrix [r1..r2][c1..c2] of the receiver.\"\r\t|rd cd|\r\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\t^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]\r"},{"name":"withIndicesInject:into:","linesOfCode":11,"sourceCode":"withIndicesInject: start into: aBlock\r\t\r\t| i current |\r\ti := 0.\r\tcurrent := start.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\tcurrent := aBlock \r\t\t\t\t\t\t\t\tvalue: current \r\t\t\t\t\t\t\t\tvalue: (contents at: (i := i+1)) \r\t\t\t\t\t\t\t\tvalue: row value: column ] ].\r\t^ current"},{"name":"swapRow:withRow:","linesOfCode":8,"sourceCode":"swapRow: anIndex withRow: anotherIndex\r\t| a b |\r\ta := self indexForRow: anIndex andColumn: 1.\r\tb := self indexForRow: anotherIndex andColumn: 1.\r\tnumberOfColumns timesRepeat: [\r\t\tcontents swap: a with: b.\r\t\ta := a + 1.\r\t\tb := b + 1].\r"},{"name":"at:at:incrementBy:","linesOfCode":3,"sourceCode":"at: rowNumber at: columnNumber incrementBy: value\r\t\"Add a value to the element available at rowNumber,columNumber.\"\r\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber) incrementBy: value"},{"name":"indicesInject:into:","linesOfCode":7,"sourceCode":"indicesInject: start into: aBlock\r\r\t|current|\r\tcurrent := start.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\tcurrent := aBlock value: current value: row value: column ] ].\r\t^ current"},{"name":"indicesCollect:","linesOfCode":8,"sourceCode":"indicesCollect: aBlock\r\t\r\t| r i |\r\tr := Array new: numberOfRows * numberOfColumns.\r\ti := 0.\r\t1 to: numberOfRows do: [:row |\r\t\t1 to: numberOfColumns do: [:column |\r\t\t\tr at: (i := i+1) put: (aBlock value: row value: column)]].\r\t^ self class rows: numberOfRows columns: numberOfColumns contents: r"},{"name":"atRandom","linesOfCode":3,"sourceCode":"atRandom\r\t\"Return the contents of the receiver in a random order.\"\r\t^ contents atRandom\r"},{"name":"diagonal","linesOfCode":5,"sourceCode":"diagonal\r\t\"Answer (1 to: (numberOfRows min: numberOfColumns)) collect: [:i | self at: i at: i]\"\r\t|i|\r\ti := numberOfColumns negated.\r\t^ (1 to: (numberOfRows min: numberOfColumns)) collect: [:j | contents at: (i := i + numberOfColumns + 1)]"},{"name":"with:inject:into:","linesOfCode":4,"sourceCode":"with: aCollection inject: startingValue into: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\t^ self withIndicesInject: startingValue into: [:value :each :row :column |\r\t\t\taBlock value: value value: each value: (aCollection at: row at: column)]"},{"name":"includesAll:","linesOfCode":2,"sourceCode":"includesAll: aCollection\r\t^ contents includesAll: aCollection"},{"name":"atRow:put:","linesOfCode":6,"sourceCode":"atRow: row put: aCollection\r\t|p|\r\r\taCollection size = numberOfColumns ifFalse: [self error: 'wrong row size'].\r\tp := (self indexForRow: row andColumn: 1)-1.\r\taCollection do: [:each | contents at: (p := p+1) put: each].\r\t^aCollection"},{"name":"numberOfColumns:","linesOfCode":2,"sourceCode":"numberOfColumns: anObject\r\tnumberOfColumns := anObject"},{"name":"asByteArray","linesOfCode":2,"sourceCode":"asByteArray\r\t^ contents asByteArray"},{"name":"indexOf:ifAbsent:","linesOfCode":4,"sourceCode":"indexOf: anElement ifAbsent: anExceptionBlock\r\t\"If there are integers r, c such that (self at: r at: c) = anElement, answer some such r@c, otherwise answer the result of anExceptionBlock.\"\r\r\t^self rowAndColumnForIndex:\r\t\t (contents indexOf: anElement ifAbsent: [^ anExceptionBlock value])\r"},{"name":"atRows:columns:","linesOfCode":5,"sourceCode":"atRows: rs columns: cs\r\t\"Answer a Matrix obtained by slicing the receiver.\r\t rs and cs should be sequenceable collections of positive integers.\"\r\r\t^self class rows: rs size columns: cs size tabulate: [:r :c |\r\t\tself at: (rs at: r) at: (cs at: c)]"},{"name":"anyOne","linesOfCode":3,"sourceCode":"anyOne\r\t\"Return one element from the receiver\"\r\t^ contents anyOne"},{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\tself shouldNotImplement"},{"name":",","linesOfCode":18,"sourceCode":", aMatrix\r\t\"Answer a new matrix having the same number of rows as the receiver and aMatrix,\r\t its columns being the columns of the receiver followed by the columns of aMatrix.\"\r\t|newCont newCols anArray oldCols a b c|\r\r\t[numberOfRows = aMatrix numberOfRows] assert.\r\tnewCont := Array new: self size + aMatrix size.\r\tanArray := aMatrix privateContents.\r\toldCols := aMatrix numberOfColumns.\r\tnewCols := numberOfColumns + oldCols.\r\ta := b := c := 1.\r\t1 to: numberOfRows do: [:r |\r\t\tnewCont replaceFrom: a to: a + numberOfColumns - 1 with: contents startingAt: b.\r\t\tnewCont replaceFrom: a+numberOfColumns to: a + newCols - 1 with: anArray startingAt: c.\r\t\ta := a + newCols.\r\t\tb := b + numberOfColumns.\r\t\tc := c + oldCols].\r\t^self class rows: numberOfRows columns: newCols contents: newCont\r\t\t\r"},{"name":"difference:","linesOfCode":5,"sourceCode":"difference: aCollection\r\t\"Union is in because the result is always a Set.\r\t Difference and intersection are out because the result is like the receiver,\r\t and with irregular seleection that cannot be.\"\r\tself shouldNotImplement"},{"name":"numberOfRows:","linesOfCode":2,"sourceCode":"numberOfRows: anObject\r\tnumberOfRows := anObject"},{"name":"asSortedCollection:","linesOfCode":2,"sourceCode":"asSortedCollection: aBlock\r\t^ contents asSortedCollection: aBlock"},{"name":"includesAny:","linesOfCode":2,"sourceCode":"includesAny: aCollection\r\t^ contents includesAny: aCollection"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tcontents := contents copy"},{"name":"asBag","linesOfCode":2,"sourceCode":"asBag\r\t^ contents asBag"},{"name":"preMultiplyByMatrix:","linesOfCode":11,"sourceCode":"preMultiplyByMatrix: m\r\t\"Answer m +* self where m is a Matrix.\"\r\t|s|\r\tnumberOfRows = m numberOfColumns ifFalse: [self error: 'dimensions do not conform'].\r\t^ Array2D \r\t\trows: m numberOfRows \r\t\tcolumns: numberOfColumns \r\t\ttabulate: [:row :col |\r\t\t\ts := 0.\r\t\t\t1 to: numberOfRows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].\r\t\t\ts ]"},{"name":"indexForRow:andColumn:","linesOfCode":6,"sourceCode":"indexForRow: row andColumn: column\r\t(row between: 1 and: numberOfRows)\r\t\tifFalse: [self error: '1st subscript out of range'].\r\t(column between: 1 and: numberOfColumns)\r\t\tifFalse: [self error: '2nd subscript out of range'].\r\t^(row-1) * numberOfColumns + column"},{"name":"at:at:","linesOfCode":2,"sourceCode":"at: rowNumber at: columnNumber\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber)"},{"name":"atColumn:put:","linesOfCode":6,"sourceCode":"atColumn: column put: aCollection\r\t| p |\r\taCollection size = numberOfRows ifFalse: [ self error: 'wrong column size' ].\r\tp := (self indexForRow: 1 andColumn: column) - numberOfColumns.\r\taCollection do: [ :each | contents at: (p := p + numberOfColumns) put: each ].\r\t^ aCollection\r"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t\"I'm really not sure what would be a good hash function here.\r\t The essential thing is that it must be compatible with #=, and\r\t this satisfies that requirement.\"\r\r\t^contents hash"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: anExceptionBlock\r\tself shouldNotImplement"},{"name":"rowAndColumnForIndex:","linesOfCode":4,"sourceCode":"rowAndColumnForIndex: index\r\t|t|\r\r\tt := index - 1.\r\t^(t // numberOfColumns + 1)@(t \\\\ numberOfColumns + 1)"},{"name":"atAllPut:","linesOfCode":3,"sourceCode":"atAllPut: value\r\t\"Put value as value of all the receiver elements.\"\r\tcontents atAllPut: value"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tself shouldNotImplement"},{"name":"identityIndexOf:ifAbsent:","linesOfCode":3,"sourceCode":"identityIndexOf: anElement ifAbsent: anExceptionBlock\r\t^self rowAndColumnForIndex:\r\t\t (contents identityIndexOf: anElement ifAbsent: [^anExceptionBlock value])\r"},{"name":"isSequenceable","linesOfCode":6,"sourceCode":"isSequenceable\r\t\"LIE so that arithmetic on matrices will work.\r\t What matters for arithmetic is not that there should be random indexing\r\t but that the structure should be stable and independent of the values of\r\t the elements.  #isSequenceable is simply the wrong question to ask.\"\r\t^ true"},{"name":"numberOfColumns","linesOfCode":2,"sourceCode":"numberOfColumns\r\t^ numberOfColumns"},{"name":"asWordArray","linesOfCode":2,"sourceCode":"asWordArray\r\t^ contents asWordArray"},{"name":"atRows:to:columns:to:put:","linesOfCode":12,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix\r\t\"Set the [r1..r2][c1..c2] submatrix of the receiver\r\t from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.\r\t As long as aMatrix responds to at:at: and accepts arguments in the range shown,\r\t we don't care if it is bigger or even if it is a Matrix at all.\"\r\t|rd cd|\r\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\tr1 to: r2 do: [:r |\r\t\tc1 to: c2 do: [:c |\r\t\t\tself at: r at: c put: (aMatrix at: r-rd at: c-cd)]].\r\t^aMatrix\r"},{"name":"shuffled","linesOfCode":2,"sourceCode":"shuffled\r\t^self class rows: numberOfRows columns: numberOfColumns contents: (contents shuffled)"},{"name":"asSortedCollection","linesOfCode":2,"sourceCode":"asSortedCollection\r\t^ contents asSortedCollection"},{"name":"+*","linesOfCode":4,"sourceCode":"+* aCollection\r\t\"Premultiply aCollection by self.  aCollection should be an Array or Matrix.\r\t The name of this method is APL's +.x squished into Smalltalk syntax.\"\r\r\t^aCollection preMultiplyByMatrix: self\r"},{"name":"indexOf:","linesOfCode":3,"sourceCode":"indexOf: anElement\r\t\"If there are integers r, c such that (self at: r at: c) = anElement, answer some such r@c, otherwise answer 0@0. The order in which the receiver are searched is UNSPECIFIED except that it is the same as the order used by #indexOf:ifAbsent: and #readStream.\"\r\r\t^self indexOf: anElement ifAbsent: [0@0]\r"},{"name":"transposed","linesOfCode":3,"sourceCode":"transposed\r\t[numberOfRows = numberOfColumns] assert.\r\t^ self indicesCollect: [ :row :column | self at: column at: row ]"},{"name":"at:at:put:","linesOfCode":3,"sourceCode":"at: rowNumber at: columnNumber put: value\r\t\"Put value at rowNumber,columnNumber\"\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber) put: value"},{"name":"columnCount","linesOfCode":2,"sourceCode":"columnCount\r\t^ numberOfColumns"},{"name":"identityIndexOf:","linesOfCode":2,"sourceCode":"identityIndexOf: anElement\r\t\r\t^ self identityIndexOf: anElement ifAbsent: [ 0@0 ]\r"},{"name":"readStream","linesOfCode":3,"sourceCode":"readStream\r\t\"Answer a ReadStream that returns all the elements of the receiver in some UNSPECIFIED order.\"\r\t^ contents readStream"},{"name":"withIndicesCollect:","linesOfCode":9,"sourceCode":"withIndicesCollect: aBlock\r\t\r\t|i r|\r\ti := 0.\r\tr := contents shallowCopy.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\ti := i+1.\r\t\t\tr at: i put: (aBlock value: (r at: i) value: row value: column)]].\r\t^ self class rows: numberOfRows columns: numberOfColumns contents: r\r"},{"name":"storeOn:","linesOfCode":6,"sourceCode":"storeOn: aStream\r\taStream nextPut: $(; nextPutAll: self class name;\r\t\tnextPutAll: ' rows: '; store: numberOfRows;\r\t\tnextPutAll: ' columns: '; store: numberOfColumns;\r\t\tnextPutAll: ' contents: '; store: contents;\r\t\tnextPut: $)"},{"name":"swap:at:with:at:","linesOfCode":3,"sourceCode":"swap: r1 at: c1 with: r2 at: c2\r\tcontents swap: (self indexForRow: r1 andColumn: c1)\r\t\t\t with: (self indexForRow: r2 andColumn: c2)"},{"name":"extent","linesOfCode":3,"sourceCode":"extent\r    \"Answer the receiver's dimensions as point.\"\r\r    ^ self numberOfColumns @ self numberOfRows"},{"name":"privateContents","linesOfCode":4,"sourceCode":"privateContents\r\t\"Only used in #, #,, and #= so far.\r\t It used to be called #contents, but that clashes with Collection>>contents.\"\r\r\t^ contents"},{"name":"select:","linesOfCode":2,"sourceCode":"select: aBlock\r\tself shouldNotImplement"},{"name":"atColumn:","linesOfCode":4,"sourceCode":"atColumn: column\r\r\t|p|\r\tp := (self indexForRow: 1 andColumn: column)-numberOfColumns.\r\t^(1 to: numberOfRows) collect: [:row | contents at: (p := p+numberOfColumns)]\r"},{"name":"indicesDo:","linesOfCode":4,"sourceCode":"indicesDo: aBlock\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\taBlock value: row value: column]]."},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^ contents asIdentitySet"}],"meta":{"name":"Array2D class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: dimension\r\t\"Answer a dimension*dimension matrix.\"\r\t^ self rows: dimension columns: dimension"},{"name":"rows:columns:tabulate:","linesOfCode":10,"sourceCode":"rows: rowNumber columns: columnNumber tabulate: aTwoArgumentBlock\r\t\"Answer a new Matrix of the given dimensions where\r\t result at: i at: j is aTwoArgumentBlock value: i value: j\"\r\t|a i|\r\ta := Array new: rowNumber*columnNumber.\r\ti := 0.\r\t1 to: rowNumber do: [:row |\r\t\t1 to: columnNumber do: [:column |\r\t\t\ta at: (i := i + 1) put: (aTwoArgumentBlock value: row value: column)]].\r\t^ self rows: rowNumber columns: columnNumber contents: a\r"},{"name":"columnVector:","linesOfCode":3,"sourceCode":"columnVector: aCollection\r\t\"Create a matrix of one column having aCollection as contents\"\r\r\t^ self rows: aCollection size columns: 1 contents: aCollection asArray shallowCopy"},{"name":"zeros:","linesOfCode":3,"sourceCode":"zeros: dimension\r\t\"Create a Matrix of dimensionxdimemsion\"\r\t^ self new: dimension element: 0"},{"name":"rows:columns:contents:","linesOfCode":3,"sourceCode":"rows: rowNumber columns: columnNumber contents: contents\r\t\"Private! Creates a Matrix of the given size with an adequate contents.\"\r\t^ self new rows: rowNumber columns: columnNumber contents: contents"},{"name":"new:tabulate:","linesOfCode":3,"sourceCode":"new: dimension tabulate: aTwoArgumentBlock\r\t\"Answer a dimension*dimension matrix where it at: i at: j is aBlock value: i value: j.\"\r\t^ self rows: dimension columns: dimension tabulate: aTwoArgumentBlock"},{"name":"identity:","linesOfCode":5,"sourceCode":"identity: n\r\t| r |\r\tr := self zeros: n.\r\t1 to: n do: [ :i | r at: i at: i put: 1 ].\r\t^ r"},{"name":"new:element:","linesOfCode":3,"sourceCode":"new: dimemsion element: element\r\t\"Answer a dimemsion*dimemsion matrix with all elements set to element.\"\r\r\t^ self rows: dimemsion columns: dimemsion element: element"},{"name":"diagonal:","linesOfCode":6,"sourceCode":"diagonal: aCollection\r\t|r i|\r\tr := self zeros: aCollection size.\r\ti := 0.\r\taCollection do: [:each | i := i+1. r at: i at: i put: each].\r\t^r"},{"name":"rows:columns:","linesOfCode":6,"sourceCode":"rows: rowNumber columns: columnNumber\r\t\"Create a Matrix of rowNUmber rows and columnNumber columns.\"\r\t^ self \r\t\trows: rowNumber \r\t\tcolumns: columnNumber \r\t\tcontents: (Array new: rowNumber*columnNumber)"},{"name":"rows:columns:element:","linesOfCode":6,"sourceCode":"rows: rowNumber columns: columnNumber element: element\r\t\"Create a Matrix of rowNumber rows and columnNumber columns filled with element.\"\r\t^ self \r\t\trows: rowNumber \r\t\tcolumns: columnNumber\r\t\tcontents: ((Array new: rowNumber * columnNumber) atAllPut: element; yourself)"},{"name":"rowVector:","linesOfCode":3,"sourceCode":"rowVector: aCollection\r\t\"Create a matrix of one row having aCollection as contents\"\r\r\t^self rows: 1 columns: aCollection size contents: aCollection asArray shallowCopy"},{"name":"ones:","linesOfCode":3,"sourceCode":"ones: dimension\r\t\"Create a squared matrix of dimension full of 1\"\r\t^ self new: dimension element: 1\r"}],"meta":null}},{"name":"Bag","instanceVariables":[{"name":"contents"}],"methods":[{"name":"add:","linesOfCode":3,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject.\"\r\r\t^ self add: newObject withOccurrences: 1"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t\"(#(1 2 2 3 1 1 1) includes: 5) >>> false\"\r\t\"(#(1 2 2 3 1 1 1) includes: 1) >>> true\"\r\t\r\t^ contents includesKey: anObject"},{"name":"add:withOccurrences:","linesOfCode":4,"sourceCode":"add: newObject withOccurrences: anInteger \r\t\"Add newObject anInteger times to the receiver. Answer newObject.\"\r\r\tcontents at: newObject put: (contents at: newObject ifAbsent: [0]) + anInteger.\r\t^ newObject"},{"name":"associationsDo:","linesOfCode":4,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).  Provided for compatibility with Dictionaries\"\r\r\tcontents associationsDo: aBlock"},{"name":"occurrencesOf:","linesOfCode":6,"sourceCode":"occurrencesOf: anObject \r\t\"Answer how many of the receiver's elements are equal to anObject.\"\r\t\r\t\"(#(1 2 2 3 1 1 1) asBag occurrencesOf: 1) >>> 4\"\r\t\r\t^ (self includes: anObject)\r\t\tifTrue: [ contents at: anObject]\r\t\tifFalse: [ 0 ]"},{"name":"keysAndValuesDo:","linesOfCode":4,"sourceCode":"keysAndValuesDo: aTwoArgBlock \r    \"Iterate over the receiver and apply a two argument block on the element and its occurrences.\"\r     \r    contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]"},{"name":"stonOn:","linesOfCode":5,"sourceCode":"stonOn: stonWriter\r\t\"Use a map with element-occurrences pairs as representation\"\r\r\tstonWriter \r\t\twriteObject: self \r\t\tdo: [ stonWriter encodeMap: contents ]"},{"name":"=","linesOfCode":11,"sourceCode":"= aBag\r\t\"Two bags are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same size.\r\t (c) each element occurs the same number of times in both of them\"\r\r\t(aBag isKindOf: Bag) ifFalse: [^false].\r\tself size = aBag size ifFalse: [^false].\r\tcontents associationsDo: [:assoc|\r\t\t(aBag occurrencesOf: assoc key) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true\r\r"},{"name":"asSet","linesOfCode":4,"sourceCode":"asSet\r\t\"Answer a set with the elements of the receiver.\"\r\t\"#(1 2 2 3 1 1 1) asBag asSet >>> #(1 2 2 3 1 1 1) asSet\"\r\t\r\t^ contents keys asSet"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tcontents := contents copy"},{"name":"asBag","linesOfCode":2,"sourceCode":"asBag\r\t^ self"},{"name":"cumulativeCounts","linesOfCode":7,"sourceCode":"cumulativeCounts\r\t\"Answer with a collection of cumulative percents covered by elements so far.\"\r\t\r\t\"#(1 2 2 3 1 1 1) asBag cumulativeCounts >>> {57.1->1 . 85.7->2 . 100.0->3}\"\r\t\r\t| s n |\r\ts := self size / 100.0. n := 0.\r\t^ self sortedCounts asArray collect:\r\t\t[:a | n := n + a key. (n / s roundTo: 0.1) -> a value]"},{"name":"sortedCounts","linesOfCode":9,"sourceCode":"sortedCounts\r\t\"Answer with a collection of counts with elements, sorted by decreasing\r\tcount.\"\r\t\"Suggested by l. Uzonyi\"\r\r\t^(Array new: contents size streamContents: [ :stream |\r \t\t\tcontents associationsDo: [ :each |\r \t\t\t\tstream nextPut: each value -> each key ] ])\r \t\tsort: [:x :y | x >= y ];\r \t\tyourself"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tcontents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]"},{"name":"valuesAndCounts","linesOfCode":2,"sourceCode":"valuesAndCounts\r\r\t^ contents"},{"name":"remove:ifAbsent:","linesOfCode":11,"sourceCode":"remove: oldObject ifAbsent: exceptionBlock \r\t\"Remove oldObject from the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject.\"\r\r\t| count |\r\tcount := contents at: oldObject ifAbsent: [^ exceptionBlock value].\r\tcount = 1\r\t\tifTrue: [contents removeKey: oldObject]\r\t\tifFalse: [contents at: oldObject put: count - 1].\r\t^ oldObject"},{"name":"sortedElements","linesOfCode":6,"sourceCode":"sortedElements\r\t\"Answer with a collection of elements with counts, sorted by element.\"\r\t\r\t\"#(1 2 2 3 1 1 1) asBag sortedElements >>> {1->4. 2->2. 3->1}\"\r\t\r\t^contents associations\r \t\tsort;\r \t\tyourself"},{"name":"removeAll","linesOfCode":5,"sourceCode":"removeAll\r\t\"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.\r\tAn alternative implementation preserving capacity would be to create a new contents:\r\tself setContents: (self class contentsClass new: contents size).\"\r\t\r\tcontents removeAll"},{"name":"size","linesOfCode":7,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t\"#(1 2 2 3 1 1 1) asBag size >>> 7\"\r\t\r\t| tally |\r\ttally := 0.\r\tcontents do: [:each | tally := tally + each].\r\t^ tally"},{"name":"sum","linesOfCode":12,"sourceCode":"sum\r\t\"Return the sum (+) of the elements held in the receiver.\"\r\t\"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag).\"\r\t\r\t\"#(1 2 2 3 1 1 1) sum >>> 11\"\r\t\r\t| sum first |\r\tfirst := true.\r\tcontents keysAndValuesDo: [ :value :count |\r\t\tfirst \r\t\t\tifTrue: [ sum := value * count. first := false ]\r\t\t\tifFalse: [ sum := sum + (value * count) ] ].\r\tfirst ifTrue: [ self errorEmptyCollection ].\r\t^ sum"},{"name":"atRandom:","linesOfCode":11,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\r\tshould be kept by the user in a variable and used every time. Use\r\tthis instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\r\t| index |\r \tself emptyCheck.\r \tindex := aGenerator nextInteger: self size.\r \t\"overwritten to use a faster enumeration\"\r \tself doWithOccurrences: [ :key :count | \r \t\t(index := index - count) <= 0 ifTrue: [ ^key ] ]"},{"name":"setContents:","linesOfCode":2,"sourceCode":"setContents: aDictionary\r\tcontents := aDictionary"},{"name":"gtInspectorOccurrencesIn:","linesOfCode":16,"sourceCode":"gtInspectorOccurrencesIn: composite\r\t<gtInspectorPresentationOrder: 1>  \r\t^ (composite fastTable)\r\t\ttitle: 'Occurrences';\r\t\tdisplay: [ :aCollection | self asSet asOrderedCollection ];\r\t\tcolumn: 'Item' \r\t\t\tevaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tcolumn: 'Occurrences' \r\t\t\tevaluated: [ :each | self occurrencesOf: each ]\r\t\t\tsortedBy: [ :a :b | (self occurrencesOf: a) > (self occurrencesOf: b)];\r\t\tbeMultiple;\r\t\t\"withSmalltalkSearch;\"\r\t\tshowOnly: 50;\r\t\tsend: [ :result |\r\t\t\t\tresult ];\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'."},{"name":"gtInspectorItemsIn:","linesOfCode":3,"sourceCode":"gtInspectorItemsIn: composite\r\t\"Disable the Items presentation for a bag.\r\tThis avoid showing all duplicated items.\""},{"name":"doWithOccurrences:","linesOfCode":4,"sourceCode":"doWithOccurrences: aTwoArgBlock \r    \"Iterate over the receiver and apply a two argument block on the element and its occurrences.\"\r        \r    contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]"}],"meta":{"name":"Bag class","instanceVariables":[],"methods":[{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"Read a map representation containing element/occurrences pairs\"\r\t\r\t| bag |\r\tbag := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tbag add: key withOccurrences: value ].\r\t^ bag"},{"name":"new:","linesOfCode":2,"sourceCode":"new: nElements\r\t^ super new setContents: (self contentsClass new: nElements)"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 4"},{"name":"newFrom:","linesOfCode":6,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t^ self withAll: aCollection\r\r\"Examples:\r\tBag newFrom: {1. 2. 3. 3}\r\t{1. 2. 3. 3} as: Bag\r\""},{"name":"contentsClass","linesOfCode":2,"sourceCode":"contentsClass\r\t^Dictionary"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeBagInspector"}],"meta":null}},{"name":"CharacterSet","instanceVariables":[{"name":"map"}],"methods":[{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tmap atAllPut: 0"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^map sum"},{"name":"byteComplement","linesOfCode":6,"sourceCode":"byteComplement\r\t\"return a character set containing precisely the single byte characters the receiver does not\"\r\t\r\t| set |\r\tset := self class allCharacters.\r\tself do: [ :c | set remove: c ].\r\t^set"},{"name":"add:","linesOfCode":11,"sourceCode":"add: aCharacter\r\t\"I automatically become a WideCharacterSet if you add a wide character to myself\"\r\t\r\taCharacter asciiValue >= 256\r\t\tifTrue: [| wide |\r\t\t\twide := WideCharacterSet new.\r\t\t\twide addAll: self.\r\t\t\twide add: aCharacter.\r\t\t\tself becomeForward: wide.\r\t\t\t^aCharacter].\r\tmap at: aCharacter asciiValue + 1 put: 1.\r\t^aCharacter"},{"name":"byteArrayMap","linesOfCode":3,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only\"\r\t^map"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: aCharacter\r\t\"Guard against wide characters\"\r\t^aCharacter asciiValue >= 256\r\t\tifTrue: [ false ]\r\t\tifFalse: [ (map at: aCharacter asciiValue + 1) > 0 ]"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tmap := ByteArray new: 256 withAll: 0."},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: aCharacter\r\taCharacter asciiValue >= 256\r\t\tifFalse: [\"Guard against wide characters\"\r\t\t\tmap at: aCharacter asciiValue + 1 put: 0].\r\t^aCharacter"},{"name":"=","linesOfCode":3,"sourceCode":"= anObject\r\t^self species == anObject species and: [\r\t\tself byteArrayMap = anObject byteArrayMap ]"},{"name":"asString","linesOfCode":6,"sourceCode":"asString\r\t\"Convert the receiver into a String\"\r\r\t^String \r\t\tnew: self size \r\t\tstreamContents: \r\t\t\t[ :s | self do: [ :ch | s nextPut: ch]]."},{"name":"hasWideCharacters","linesOfCode":2,"sourceCode":"hasWideCharacters\r\t^false"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tmap := map copy"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^CharacterSetComplement of: self copy"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t\"evaluate aBlock with each character in the set\"\r\r\tCharacter allByteCharacters do: [ :c |\r\t\t(self includes: c) ifTrue: [ aBlock value: c ] ]\r"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^self byteArrayMap hash"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"wideCharacterMap","linesOfCode":6,"sourceCode":"wideCharacterMap\r\t\"used for comparing with WideCharacterSet\"\r\t\r\t| wide |\r\twide := WideCharacterSet new.\r\twide addAll: self.\r\t^wide wideCharacterMap"}],"meta":{"name":"CharacterSet class","instanceVariables":[],"methods":[{"name":"nonSeparators","linesOfCode":3,"sourceCode":"nonSeparators\r\t\"return a set containing everything but the whitespace characters\"\r\r\t^self separators complement"},{"name":"separators","linesOfCode":6,"sourceCode":"separators\r\t\"return a set containing just the whitespace characters\"\r\r\t| set |\r\tset := self empty.\r\tset addAll: Character separators.\r\t^set"},{"name":"crlf","linesOfCode":3,"sourceCode":"crlf\r\tCrLf ifNil: [CrLf := self with: Character cr with: Character lf].\r\t^CrLf"},{"name":"allCharacters","linesOfCode":6,"sourceCode":"allCharacters\r\t\"return a set containing all characters\"\r\r\t| set |\r\tset := self empty.\r\t0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].\r\t^set"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t| newCollection |\r\tnewCollection := self new.\r\tnewCollection addAll: aCollection.\r\t^newCollection"}],"meta":null}},{"name":"CharacterSetComplement","instanceVariables":[{"name":"absent"},{"name":"byteArrayMapCache"}],"methods":[{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\tself becomeForward: CharacterSet new"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"The size is all characters minus those explicitly excluded\"\r\r\t\"Character values include 0, so we need to add 1.\"\r\t^Character maxVal + 1 - absent size"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\t\"Print a description of the complement rather than self.\r\tRationale: self would be too long to print.\"\r\t\r\taStream nextPut: $(.\r\tabsent printOn: aStream.\r\taStream nextPut: $); space; nextPutAll: #complement."},{"name":"add:","linesOfCode":7,"sourceCode":"add: aCharacter \r\t\"a character is present if not absent, so adding a character is removing it from the absent\"\r\t\r\t(absent includes: aCharacter)\r\t\tifTrue:\r\t\t\t[byteArrayMapCache := nil.\r\t\t\tabsent remove: aCharacter].\r\t^ aCharacter"},{"name":"byteArrayMap","linesOfCode":3,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only\"\r\r\t^byteArrayMapCache ifNil: [byteArrayMapCache := absent byteArrayMap collect: [:i | 1 - i]]"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: aCharacter\r\t^(absent includes: aCharacter) not"},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: aCharacter\r\t\"This means aCharacter is now absent from myself.\r\tIt must be added to my absent.\"\r\t\r\tbyteArrayMapCache := nil.\r\t^absent add: aCharacter"},{"name":"=","linesOfCode":5,"sourceCode":"= anObject\r\t\"Implementation note: we do not test if equal to a WideCharacterSet,\r\tbecause it is unlikely that WideCharacterSet is as complete as self\"\r\t\r\t^self class == anObject class and: [\r\t\tabsent = anObject complement ]"},{"name":"hasWideCharacters","linesOfCode":3,"sourceCode":"hasWideCharacters\r\t\"This is a guess that absent is not holding each and every possible wideCharacter...\"\r\t\r\t^true"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tabsent := absent copy"},{"name":"reject:","linesOfCode":3,"sourceCode":"reject: aBlock\r\t\"Implementation note: rejecting present is selecting absent\"\r\t\r\t^(absent select: aBlock) complement"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^absent copy"},{"name":"storeOn:","linesOfCode":5,"sourceCode":"storeOn: aStream\r\t\"Store a description of the elements of the complement rather than self.\"\r\t\r\taStream nextPut: $(.\r\tabsent storeOn: aStream.\r\taStream nextPut: $); space; nextPutAll: #complement."},{"name":"gtInspectorItemsIn:","linesOfCode":15,"sourceCode":"gtInspectorItemsIn: composite\r\t\"The default set is huge, inspect the Absent list, which is typically a manageable size\"\r\r\t^ composite fastList\r\t\ttitle: 'Absent';\r\t\tdisplay: [ absent asArray ];\r\t\tbeMultiple;\r\t\tformat: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\t\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult\r\t\t\t\tifNotNil: [ result size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] ] ]"},{"name":"do:","linesOfCode":5,"sourceCode":"do: aBlock\r\t\"evaluate aBlock with each character in the set\"\r\r\t0 to: self size - 1 do: [ :codePoint | | ch |\r\t\tch := Character value: codePoint.\r\t\t(self includes: ch) ifTrue: [ aBlock value: ch ] ]"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^absent hash bitXor: self class hash"},{"name":"complement:","linesOfCode":4,"sourceCode":"complement: aCharacterSet\r\t\"initialize with the complement\"\r\t\r\tbyteArrayMapCache := nil.\r\tabsent := aCharacterSet.\r\t"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"select:","linesOfCode":3,"sourceCode":"select: aBlock\r\t\"Implementation note: selecting present is rejecting absent\"\r\t\r\t^(absent reject: aBlock) complement"}],"meta":{"name":"CharacterSetComplement class","instanceVariables":[],"methods":[{"name":"of:","linesOfCode":3,"sourceCode":"of: aCharacterSet\r\t\"answer the complement of aCharacterSet\"\r\t\r\t^ super new complement: aCharacterSet"}],"meta":null}},{"name":"DependentsArray","instanceVariables":[],"methods":[{"name":"last","linesOfCode":3,"sourceCode":"last\r\tself reverseDo: [:dep | ^dep].\r\tself error: 'this collection is empty'"},{"name":"copyWith:","linesOfCode":8,"sourceCode":"copyWith: newElement \r\t\"Re-implemented to not copy any niled out dependents.\"\r\t| copy i |\r\tcopy := self class new: self size + 1.\r\ti := 0.\r\tself do: [:item | copy basicAt: (i:=i+1) put: item].\r\tcopy basicAt: (i:=i+1) put: newElement.\r\t^copy"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"count each non nil elements in self.\r\tNote: count: will use do: which will already have filtered out nil elements\"\r\t\r\t^self count: [:each | true]"},{"name":"basicReplaceFrom:to:with:startingAt:","linesOfCode":5,"sourceCode":"basicReplaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tstart to: stop do: [:i |\r\t\tself basicAt: i put: (replacement basicAt: repStart - start + i)]"},{"name":"at:","linesOfCode":10,"sourceCode":"at: anIndex\r\t| basicSize counter dep |\r\tanIndex > 0 ifTrue: [\r\t\tbasicSize := self basicSize.\r\t\tanIndex <= basicSize ifTrue: [\r\t\t\tcounter := 0.\r\t\t\t1 to: basicSize do: [:i |\r\t\t\t\t(dep := self basicAt: i) == nil\r\t\t\t\t\tifFalse: [(counter := counter + 1) = anIndex ifTrue: [^dep]]]]].\r\tself error: 'access with an index out of bounds'"},{"name":"reverseDo:","linesOfCode":5,"sourceCode":"reverseDo: aBlock\r\t\"Refer to the comment in Collection|do:.\"\r\t| dep |\r\tself basicSize to: 1 by: -1 do: [:i |\r\t\t(dep := self basicAt: i) ifNotNil: [aBlock value: dep]]"},{"name":"do:","linesOfCode":5,"sourceCode":"do: aBlock\r\t\"Evaluate a Block on non nil elements of the receiver\"\r\t| dep |\r\t1 to: self basicSize do:[:i|\r\t\t(dep := self basicAt: i) ifNotNil:[aBlock value: dep]]."},{"name":"first","linesOfCode":3,"sourceCode":"first\r\tself do: [:dep | ^dep].\r\tself error: 'this collection is empty'"},{"name":"writeStream","linesOfCode":2,"sourceCode":"writeStream\r\t^ WriteStream on: self"},{"name":"select:","linesOfCode":13,"sourceCode":"select: aBlock \r\t\"Refer to the comment in Collection|select:.\"\r\t| basicSize newSelf size selection |\r\tbasicSize := self basicSize.\r\tnewSelf := self species new: basicSize.\r\tsize := 0.\r      1 to: basicSize do: [ :i |\r               (self basicAt: i) ifNotNil: [ :dep |\r                       (aBlock value: dep) ifTrue: [\r                               newSelf basicAt: (size := size+1) put: dep ] ] ].\r\tselection := self species new: size.\r\tselection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.\r\t^selection"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: anIndex put: anObject\r\t| basicSize counter |\r\tanIndex > 0 ifTrue: [\r\t\tbasicSize := self basicSize.\r\t\tanIndex <= basicSize ifTrue: [\r\t\t\tcounter := 0.\r\t\t\t1 to: basicSize do: [:i |\r\t\t\t\t(self basicAt: i) == nil\r\t\t\t\t\tifFalse: [(counter := counter + 1) = anIndex ifTrue: [^self basicAt: i put: anObject]]]]].\r\tself error: 'access with an index out of bounds'"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Refer to the comment in Collection|select:.\"\r\t| basicSize newSelf size dep selection |\r\tbasicSize := self basicSize.\r\tnewSelf := self species new: basicSize.\r\tsize := 0.\r\t1 to: basicSize do: [:i |\r\t\t(dep := self basicAt: i) notNil ifTrue: [newSelf basicAt: (size := size+1) put: (aBlock value: dep)]].\r\tselection := self species new: size.\r\tselection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.\r\t^selection"}],"meta":{"name":"DependentsArray class","instanceVariables":[],"methods":[{"name":"with:with:with:with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t^(self basicNew: 6)\r\t\tbasicAt: 1 put: firstObject;\r\t\tbasicAt: 2 put: secondObject;\r\t\tbasicAt: 3 put: thirdObject;\r\t\tbasicAt: 4 put: fourthObject;\r\t\tbasicAt: 5 put: fifthObject;\r\t\tbasicAt: 6 put: sixthObject;\r\t\tyourself"},{"name":"with:with:with:with:with:","linesOfCode":8,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t^(self basicNew: 5)\r\t\tbasicAt: 1 put: firstObject;\r\t\tbasicAt: 2 put: secondObject;\r\t\tbasicAt: 3 put: thirdObject;\r\t\tbasicAt: 4 put: fourthObject;\r\t\tbasicAt: 5 put: fifthObject;\r\t\tyourself"},{"name":"with:with:with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t^(self basicNew: 4)\r\t\tbasicAt: 1 put: firstObject;\r\t\tbasicAt: 2 put: secondObject;\r\t\tbasicAt: 3 put: thirdObject;\r\t\tbasicAt: 4 put: fourthObject;\r\t\tyourself"},{"name":"with:with:with:","linesOfCode":6,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t^(self basicNew: 3)\r\t\tbasicAt: 1 put: firstObject;\r\t\tbasicAt: 2 put: secondObject;\r\t\tbasicAt: 3 put: thirdObject;\r\t\tyourself"},{"name":"with:with:","linesOfCode":5,"sourceCode":"with: firstObject with: secondObject \r\t^(self basicNew: 2)\r\t\tbasicAt: 1 put: firstObject;\r\t\tbasicAt: 2 put: secondObject;\r\t\tyourself"},{"name":"with:","linesOfCode":2,"sourceCode":"with: anObject\r\t^(self basicNew: 1) basicAt: 1 put: anObject; yourself"},{"name":"withAll:","linesOfCode":6,"sourceCode":"withAll: aCollection\r\t| newInstance |\r\tnewInstance := self basicNew: aCollection size.\r\t1 to: aCollection size do: [:i |\r\t\tnewInstance basicAt: i put: (aCollection at: i)].\r\t^newInstance"}],"meta":null}},{"name":"Heap","instanceVariables":[{"name":"array"},{"name":"tally"},{"name":"sortBlock"},{"name":"indexUpdateBlock"}],"methods":[{"name":"removeFirstOrNil","linesOfCode":4,"sourceCode":"removeFirstOrNil\r\t\"Remove the first element from the receiver\"\r\tself isEmpty ifTrue:  [ ^nil ].\r\t^self privateRemoveAt: 1"},{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: newSize\r\t\"Grow to the requested size.\"\r\t| newArray |\r\tnewArray := Array new: (newSize max: tally).\r\tnewArray replaceFrom: 1 to: array size with: array startingAt: 1.\r\tarray := newArray"},{"name":"fullySort","linesOfCode":5,"sourceCode":"fullySort\r\t\"Fully sort the heap.\r\tThis method preserves the heap invariants and can thus be sent safely\"\r\tself privateReverseSort.\r\t1 to: tally // 2 do: [:i | array swap: i with: 1 + tally - i]"},{"name":"indexUpdateBlock:","linesOfCode":2,"sourceCode":"indexUpdateBlock: aBlockOrNil\r\r\tindexUpdateBlock := aBlockOrNil.\r\r"},{"name":"grow","linesOfCode":3,"sourceCode":"grow\r\t\"Become larger.\"\r\tself growTo: self size + self growSize."},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\t^tally = 0"},{"name":"sort","linesOfCode":3,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\r\tself sort: [:a :b | a <= b]"},{"name":"add:","linesOfCode":7,"sourceCode":"add: anObject\r\t\"Include newObject as one of the receiver's elements. Answer newObject.\"\r\ttally = array size ifTrue:[self grow].\r\tarray at: (tally := tally + 1) put: anObject.\r\tself updateObjectIndex: tally.\r\tself upHeap: tally.\r\t^anObject"},{"name":"sorts:before:","linesOfCode":6,"sourceCode":"sorts: element1 before: element2\r\t\"Return true if element1 should be sorted before element2.\r\tThis method defines the sort order in the receiver\"\r\t^sortBlock == nil\r\t\tifTrue:[element1 <= element2]\r\t\tifFalse:[sortBlock value: element1 value: element2]."},{"name":"trim","linesOfCode":3,"sourceCode":"trim\r\t\"Remove any empty slots in the receiver.\"\r\tself growTo: self size."},{"name":"updateObjectIndex:","linesOfCode":4,"sourceCode":"updateObjectIndex: index\r\t\"If indexUpdateBlock is not nil, notify the object at index of its new position in the heap array.\"\r\tindexUpdateBlock ifNotNil: [\r\t\tindexUpdateBlock value: (array at: index) value: index]"},{"name":"collect:","linesOfCode":2,"sourceCode":"collect: aBlock\r\t^self collect: aBlock as: Array"},{"name":"=","linesOfCode":7,"sourceCode":"= anObject\r\t\"Heap are considered equals only if they have same sort order and same elements.\"\r\r\tself == anObject ifTrue: [^true].\r\tanObject isHeap ifFalse: [^false].\r\tself sortBlock = anObject sortBlock ifFalse: [^false].\r\tself size = anObject size ifFalse: [^false].\r\t^(self asArray sort: sortBlock) = (anObject asArray sort: sortBlock)"},{"name":"privateReverseSort","linesOfCode":10,"sourceCode":"privateReverseSort\r\t\"Arrange to have the array sorted in reverse order.\r\tWARNING: this method breaks the heap invariants. It's up to the sender to restore them afterwards.\"\r\t| oldTally |\r\toldTally := tally.\r\t[tally > 1] whileTrue:\r\t\t [array swap: 1 with: tally.\r\t\ttally := tally - 1.\r\t\t self downHeapSingle: 1].\r\ttally := oldTally"},{"name":"growSize","linesOfCode":3,"sourceCode":"growSize\r\t\"Return the size by which the receiver should grow if there are no empty slots left.\"\r\t^array size max: 5"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tarray := array copy"},{"name":"upHeap:","linesOfCode":14,"sourceCode":"upHeap: anIndex\r\t\"Check the heap upwards for correctness starting at anIndex.\r\t Everything below anIndex is ok.\"\r\t| value k kDiv2 tmp |\r\tanIndex = 0 ifTrue:[^self].\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[ (k > 1) and:[self sorts: value before: (tmp := array at: (kDiv2 := k bitShift: -1))] ] \r\t\twhileTrue:[\r\t\t\tarray at: k put: tmp.\r\t\t\tself updateObjectIndex: k.\r\t\t\tk := kDiv2].\r\tarray at: k put: value.\r\tself updateObjectIndex: k."},{"name":"downHeap:","linesOfCode":24,"sourceCode":"downHeap: anIndex\r\t\"Check the heap downwards for correctness starting at anIndex.\r\t Everything above (i.e. left of) anIndex is ok.\"\r\t| value k n j |\r\tanIndex = 0 ifTrue:[^self].\r\tn := tally bitShift: -1.\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[k <= n] whileTrue:[\r\t\tj := k + k.\r\t\t\"use max(j,j+1)\"\r\t\t(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])\r\t\t\t\tifTrue:[ j := j + 1].\r\t\t\"check if position k is ok\"\r\t\t(self sorts: value before: (array at: j)) \r\t\t\tifTrue:[\t\"yes -> break loop\"\r\t\t\t\t\tn := k - 1]\r\t\t\tifFalse:[\t\"no -> make room at j by moving j-th element to k-th position\"\r\t\t\t\t\tarray at: k put: (array at: j).\r\t\t\t\t\tself updateObjectIndex: k.\r\t\t\t\t\t\"and try again with j\"\r\t\t\t\t\tk := j]].\r\tarray at: k put: value.\r\tself updateObjectIndex: k."},{"name":"privateRemoveAt:","linesOfCode":11,"sourceCode":"privateRemoveAt: index\r\t\"Remove the element at the given index and make sure the sorting order is okay\"\r\t| removed |\r\tremoved := array at: index.\r\tarray at: index put: (array at: tally).\r\tarray at: tally put: nil.\r\ttally := tally - 1.\r\tindex > tally ifFalse:[\r\t\t\"Use #downHeapSingle: since only one element has been removed\"\r\t\tself downHeapSingle: index].\r\t^removed"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver without any of the receiver's elements.\"\r\r\t^self class sortBlock: sortBlock"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\t1 to: tally do:[:i| aBlock value: (array at: i)]"},{"name":"sortBlock","linesOfCode":2,"sourceCode":"sortBlock\r\t^ sortBlock ifNil: [ sortBlock := self defaultSortBlock ]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\t\"Remove oldObject as one of the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject.\"\r\t1 to: tally do:[:i| \r\t\t(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].\r\t^aBlock value"},{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock\r\tsortBlock := aBlock.\r\tself reSort."},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"defaultSortBlock","linesOfCode":2,"sourceCode":"defaultSortBlock\r\t^ self class defaultSortBlock"},{"name":"isHeap","linesOfCode":2,"sourceCode":"isHeap\r\r\t^ true"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\r\tarray atAllPut: nil.\r\ttally := 0"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ tally"},{"name":"downHeapSingle:","linesOfCode":19,"sourceCode":"downHeapSingle: anIndex\r\t\"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster.\"\r\t| value k n j |\r\tanIndex = 0 ifTrue:[^self].\r\tn := tally bitShift: -1.\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[k <= n] whileTrue:[\r\t\tj := k + k.\r\t\t\"use max(j,j+1)\"\r\t\t(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])\r\t\t\t\tifTrue:[\tj := j + 1].\r\t\tarray at: k put: (array at: j).\r\t\tself updateObjectIndex: k.\r\t\t\"and try again with j\"\r\t\tk := j].\r\tarray at: k put: value.\r\tself updateObjectIndex: k.\r\tself upHeap: k"},{"name":"first","linesOfCode":3,"sourceCode":"first\r\t\"Return the first element in the receiver\"\r\t^array at: 1"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"mergeSortFrom:to:by:","linesOfCode":20,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"},{"name":"isSortedBy:","linesOfCode":11,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"array","linesOfCode":2,"sourceCode":"array\r\t^array"},{"name":"isSorted","linesOfCode":12,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"sort:","linesOfCode":7,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\t\"Heap are not designed to be accessed sequentially.\"\r\t\r\tself shouldNotImplement."},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"reSort","linesOfCode":4,"sourceCode":"reSort\r\t\"Resort the entire heap\"\r\tself isEmpty ifTrue:[^self].\r\ttally // 2 to: 1 by: -1 do:[:i| self downHeap: i]."},{"name":"setCollection:","linesOfCode":3,"sourceCode":"setCollection: aCollection\r\tarray := aCollection.\r\ttally := 0."},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"removeFirst","linesOfCode":4,"sourceCode":"removeFirst\r\t\"Remove the first element from the receiver\"\r\tself emptyCheck.\r\t^self privateRemoveAt: 1"},{"name":"at:put:","linesOfCode":4,"sourceCode":"at: index put: newObject\r\t\"Heap are not designed to be accessed sequentially.\r\tPlease consider using #add: instead.\"\r\t\r\tself shouldNotImplement."},{"name":"setCollection:tally:","linesOfCode":3,"sourceCode":"setCollection: aCollection tally: newTally\r\tarray := aCollection.\r\ttally := newTally."}],"meta":{"name":"Heap class","instanceVariables":[{"name":"sortBlock"}],"methods":[{"name":"defaultSortBlock","linesOfCode":5,"sourceCode":"defaultSortBlock\r\t\"Cache the default sort block here. Since the sortBlock is used to compare instances, a single instance \r\t for the default block helps us.\"\r\t^ sortBlock ifNil: [ \r\t\tsortBlock := [ :a :b | a <= b]]"},{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^super new setCollection: (Array new: n)"},{"name":"heapExample","linesOfCode":26,"sourceCode":"heapExample\t\r\t\"self heapExample\"\r\t\"Create a sorted collection of numbers, remove the elements\r\tsequentially and add new objects randomly.\r\tNote: This is the kind of benchmark a heap is designed for.\"\r\t\r\t^ String streamContents: [ :str | \r\t\t| n rnd array time sorted |\r\t\tn := 5000. \"# of elements to sort\"\r\t\trnd := Random new.\r\t\tarray := (1 to: n) collect:[:i| rnd next].\r\t\t\"First, the heap version\"\r\t\ttime := Time millisecondsToRun:[\r\t\tsorted := self withAll: array.\r\t\t\t1 to: n do:[:i| \r\t\t\t\tsorted removeFirst.\r\t\t\t\tsorted add: rnd next].\r\t].\r\tstr << 'Time for Heap: ' << time printString <<' msecs '; cr.\r\t\"The quicksort version\"\r\ttime := Time millisecondsToRun:[\r\t\tsorted := SortedCollection withAll: array.\r\t\t1 to: n do:[:i| \r\t\t\tsorted removeFirst.\r\t\t\tsorted add: rnd next].\r\t].\r\tstr << 'Time for SortedCollection: '<< time printString << ' msecs'.]\r"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^self new: 10"},{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock\r\t\"Create a new heap sorted by the given block\"\r\t^self new sortBlock: aBlock"},{"name":"heapSortExample","linesOfCode":27,"sourceCode":"heapSortExample\t\r\t\"self heapSortExample\"\r\t\"Sort a random collection of Floats and compare the results with\r\tSortedCollection (using the quick-sort algorithm) and \r\tArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm).\"\r\t\r\t^ String streamContents: [ :str | \r\t\t| n rnd array  time sorted |\r\t\tn := 10000. \"# of elements to sort\"\r\t\trnd := Random new.\r\t\tarray := (1 to: n) collect:[:i| rnd next].\r\t\t\"First, the heap version\"\r\t\ttime := Time millisecondsToRun:[\r\t\t\tsorted := Heap withAll: array.\r\t\t\t1 to: n do:[:i| sorted removeFirst].\r\t\t].\r\tstr << 'Time for heap-sort: ' << time printString << ' msecs ';cr.\r\t\"The quicksort version\"\r\ttime := Time millisecondsToRun:[\r\t\tsorted := SortedCollection withAll: array.\r\t].\r\tstr << 'Time for quick-sort: ' << time printString <<' msecs '; cr.\r\t\"The merge-sort version\"\r\ttime := Time millisecondsToRun:[\r\t\tarray mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].\r\t].\r\tstr << 'Time for merge-sort: ' << time printString  << ' msecs'; cr.\r\t]"},{"name":"withAll:","linesOfCode":6,"sourceCode":"withAll: aCollection\r\t\"Create a new heap with all the elements from aCollection\"\r\t^(self basicNew)\r\t\tsetCollection: aCollection asArray copy tally: aCollection size;\r\t\treSort;\r\t\tyourself"},{"name":"withAll:sortBlock:","linesOfCode":6,"sourceCode":"withAll: aCollection sortBlock: aBlock\r\t\"Create a new heap with all the elements from aCollection\"\r\t^(self basicNew)\r\t\tsetCollection: aCollection asArray copy tally: aCollection size;\r\t\tsortBlock: aBlock;\r\t\tyourself"}],"meta":null}},{"name":"OrderedDictionary","instanceVariables":[{"name":"dictionary"},{"name":"orderedKeys"}],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: aKey ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t^ dictionary\r\t\tat: aKey\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [ self at: aKey put: anAbsentBlock value ]"},{"name":"at:ifAbsentPut:","linesOfCode":2,"sourceCode":"at: aKey ifAbsentPut: aBlock\r\t^ self at: aKey ifAbsent: [self at: aKey put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":2,"sourceCode":"associationAt: aKey ifPresent: aBlock\r\t^ dictionary associationAt: aKey ifPresent: aBlock"},{"name":"includesKey:","linesOfCode":2,"sourceCode":"includesKey: aKey\r\t^ dictionary includesKey: aKey"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject\r\t^ dictionary includes: anObject"},{"name":"printElementsOn:","linesOfCode":15,"sourceCode":"printElementsOn: aStream\r\taStream nextPut: $(.\r\tself size > 100\r\t\tifTrue: [\r\t\t\taStream nextPutAll: 'size '.\r\t\t\tself size printOn: aStream]\r\t\tifFalse: [\r\t\t\tself associations withIndexDo: [:each :i |\r\t\t\t\taStream\r\t\t\t\t\tprint: each key;\r\t\t\t\t\tnextPutAll: '->';\r\t\t\t\t\tprint: each value.\r\t\t\t\t(i < self size)\r\t\t\t\t\tifTrue: [aStream space]]].\r\taStream nextPut: $)."},{"name":"hasBindingThatBeginsWith:","linesOfCode":2,"sourceCode":"hasBindingThatBeginsWith: aString\r\t^ dictionary hasBindingThatBeginsWith: aString"},{"name":"stonOn:","linesOfCode":10,"sourceCode":"stonOn: stonWriter\r\t\"I store my instances as maps. When in JSON mode, \r\tencode me directly, without a class tag, keeping the order.\"\r\t\r\tstonWriter jsonMode \r\t\tifTrue: [ \r\t\t\tstonWriter encodeMap: self ] \r\t\tifFalse: [ \r\t\t\tstonWriter \r\t\t\t\twriteObject: self \r\t\t\t\tdo: [ stonWriter encodeMap: self ] ]\r"},{"name":"at:update:initial:","linesOfCode":10,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\"\r\t| val |\r\tval := self at: key ifAbsent: [ nil ].\r\tval \r\t\tifNil: [ self at: key put: (initBlocktOrValue value) ] \r\t\tifNotNil: [ self at: key put: (updateBlock value: val) ]"},{"name":"collect:","linesOfCode":4,"sourceCode":"collect: aBlock\r\t^ self species newFrom:\r\t\t(self associations collect: [:each |\r\t\t\teach key -> (aBlock value: each value)])"},{"name":"=","linesOfCode":10,"sourceCode":"= anObject\r\tself == anObject\r\t\tifTrue: [^ true].\r\r\t(self species == anObject species\r\t\tand: [self size = anObject size])\r\t\tifFalse: [^ false].\r\r\tdictionary associationsDo: [:each |\r\t\t(anObject at: each key ifAbsent: [^ false]) = each value\r\t\t\tifFalse: [^ false]].\r\t^ true."},{"name":"indexOfKey:ifAbsent:","linesOfCode":5,"sourceCode":"indexOfKey: aKey ifAbsent: aBlock\r\t1 to: self size do: [:i |\r\t\t(orderedKeys at: i) = aKey\r\t\t\tifTrue: [^ i]].\r\t^ aBlock value."},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: anAssociationCollection\r\t\"Since Collection implements #associationsDo:, this method can accept\r\tany collection of associations including Arrays and OrderedCollections\"\r\r\tanAssociationCollection associationsDo: [:each | self add: each].\r\t^ anAssociationCollection."},{"name":"associationAt:","linesOfCode":2,"sourceCode":"associationAt: aKey\r\t^ dictionary associationAt: aKey"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\tself valuesDo: aBlock"},{"name":"removeKey:ifAbsent:","linesOfCode":7,"sourceCode":"removeKey: aKey ifAbsent: aBlock\r\t| oldSize value |\r\r\toldSize := dictionary size.\r\tvalue := dictionary removeKey: aKey ifAbsent: aBlock.\r\tdictionary size < oldSize\r\t\tifTrue: [self orderedKeysRemove: aKey].\r\t^ value."},{"name":"includesIdentity:","linesOfCode":2,"sourceCode":"includesIdentity: anObject\r\t^ dictionary includesIdentity: anObject"},{"name":"keyAtIdentityValue:","linesOfCode":2,"sourceCode":"keyAtIdentityValue: aValue\r\t^ dictionary keyAtIdentityValue: aValue"},{"name":"dictionary","linesOfCode":2,"sourceCode":"dictionary\r\t^ dictionary"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^ true"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ dictionary size"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":5,"sourceCode":"at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t^ dictionary\r\t\tat: aKey\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: anAbsentBlock"},{"name":"atRandom:","linesOfCode":3,"sourceCode":"atRandom: aGenerator\r\tself emptyCheck.\r\t^ self at: (self orderedKeys at: (aGenerator nextInteger: self size)) "},{"name":"keyForIdentity:","linesOfCode":2,"sourceCode":"keyForIdentity: anObject\r\t^ dictionary keyForIdentity: anObject"},{"name":"growOrderedKeys","linesOfCode":7,"sourceCode":"growOrderedKeys\r\torderedKeys :=\r\t\t(Array new: ((orderedKeys size * 1.5) asInteger max: 10))\r\t\t\treplaceFrom: 1\r\t\t\tto: orderedKeys size\r\t\t\twith: orderedKeys\r\t\t\tstartingAt: 1."},{"name":"capacity","linesOfCode":2,"sourceCode":"capacity\r\t^ dictionary capacity"},{"name":"associationAt:ifAbsent:","linesOfCode":2,"sourceCode":"associationAt: aKey ifAbsent: aBlock\r\t^ dictionary associationAt: aKey ifAbsent: aBlock"},{"name":"errorInvalidIndex:","linesOfCode":2,"sourceCode":"errorInvalidIndex: anIndex\r\tSubscriptOutOfBounds signalFor: anIndex"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\t^ Dictionary"},{"name":"at:","linesOfCode":2,"sourceCode":"at: aKey\r\t^ dictionary at: aKey"},{"name":"keysAndValuesRemove:","linesOfCode":7,"sourceCode":"keysAndValuesRemove: aTwoArgumentBlock\r\t| removedAssociations |\r\r\tremovedAssociations := OrderedCollection new.\r\tself associationsDo: [:each |\r\t\t(aTwoArgumentBlock value: each key value: each value)\r\t\t\tifTrue: [removedAssociations add: each]].\r\tremovedAssociations do: [:each | self removeKey: each key]."},{"name":"orderedKeysIndexOf:","linesOfCode":2,"sourceCode":"orderedKeysIndexOf: aKey\r\t^ orderedKeys indexOf: aKey"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"at:ifAbsent:","linesOfCode":2,"sourceCode":"at: aKey ifAbsent: aBlock\r\t^ dictionary at: aKey ifAbsent: aBlock"},{"name":"keyAtValue:ifAbsent:","linesOfCode":2,"sourceCode":"keyAtValue: aValue ifAbsent: aBlock\r\t^ dictionary keyAtValue: aValue ifAbsent: aBlock"},{"name":"removeKey:","linesOfCode":5,"sourceCode":"removeKey: aKey\r\t| value |\r\r\tvalue := dictionary removeKey: aKey.\r\tself orderedKeysRemove: aKey.\r\t^ value."},{"name":"associations","linesOfCode":8,"sourceCode":"associations\r\t| associations i |\r\r\tassociations := Array new: self size.\r\ti := 1.\r\tself associationsDo: [:each |\r\t\tassociations at: i put: each.\r\t\ti := i + 1].\r\t^ associations."},{"name":"orderedKeysRemove:","linesOfCode":14,"sourceCode":"orderedKeysRemove: aRemovedKey\r\t| index |\r\r\tindex := self orderedKeysIndexOf: aRemovedKey.\r\r\t\"shift every remaining key after to the left by one\"\r\torderedKeys\r\t\treplaceFrom: index\r\t\tto: self size\r\t\twith: orderedKeys\r\t\tstartingAt: index + 1.\r\r\t\"one key was removed and the rest shifted, so nil what was the last\r\tkey slot before removing and shifting\"\r\torderedKeys\r\t\tat: self size + 1\r\t\tput: nil."},{"name":"orderedKeys","linesOfCode":2,"sourceCode":"orderedKeys\r\t^ orderedKeys"},{"name":"removeKeys:","linesOfCode":27,"sourceCode":"removeKeys: aKeyCollection\r\t\"Fast removal of multiple keys; returns self to avoid\r\thaving to create a removed value collection and does not\r\traise errors.\"\r\r\taKeyCollection\tsize > 1\r\t\tifTrue: [| oldSize newOrderedKeys newOrderedKeysIndex |\r\t\t\toldSize := self size.\r\t\t\taKeyCollection do: [:each |\r\t\t\t\tdictionary\r\t\t\t\t\tremoveKey: each\r\t\t\t\t\tifAbsent: [nil]].\r\r\t\t\tnewOrderedKeys := Array new: oldSize.\r\t\t\tnewOrderedKeysIndex := 0.\r\t\t\t1 to: oldSize do: [:i | | key |\r\t\t\t\t(dictionary includesKey: (key := orderedKeys at: i))\r\t\t\t\t\tifTrue: [\r\t\t\t\t\t\tnewOrderedKeys\r\t\t\t\t\t\t\tat: (newOrderedKeysIndex := newOrderedKeysIndex + 1)\r\t\t\t\t\t\t\tput: key]].\r\r\t\t\torderedKeys := newOrderedKeys]\r\t\tifFalse: [\r\t\t\taKeyCollection size = 1\r\t\t\t\tifTrue: [\r\t\t\t\t\t\"use #anyOne, because it can be a Set\"\r\t\t\t\t\tself\r\t\t\t\t\t\tremoveKey: aKeyCollection anyOne\r\t\t\t\t\t\tifAbsent: [nil]]]"},{"name":"valuesDo:","linesOfCode":2,"sourceCode":"valuesDo: aBlock\r\tself keysDo: [:each | aBlock value: (self at: each)]"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ DictionaryValueHolder value: self\r"},{"name":"add:","linesOfCode":10,"sourceCode":"add: anAssociation\r\t| oldSize |\r\r\toldSize := dictionary size.\r\tdictionary add: anAssociation.\r\tdictionary size > oldSize\r\t\tifTrue: [\r\t\t\torderedKeys size > oldSize\r\t\t\t\tifFalse: [self growOrderedKeys].\r\t\t\torderedKeys at: oldSize + 1 put: anAssociation key].\r\t^ anAssociation."},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":2,"sourceCode":"associationsDo: aBlock\r\tself keysDo: [:each | aBlock value: (self associationAt: each)]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":8,"sourceCode":"declare: aKey from: aDictionary\r\t(self includesKey: aKey)\r\t\tifTrue: [^ self].\r\r\t(aDictionary includesKey: aKey)\r\t\tifTrue: [\r\t\t\tself add: (aDictionary associationAt: aKey).\r\t\t\taDictionary removeKey: aKey]\r\t\tifFalse: [self add: aKey -> nil]"},{"name":"keyAtValue:","linesOfCode":2,"sourceCode":"keyAtValue: aValue\r\t^ dictionary keyAtValue: aValue"},{"name":"keysAndValuesDo:","linesOfCode":2,"sourceCode":"keysAndValuesDo: aBlock\r\tself keysDo: [:each | aBlock value: each value: (self at: each)]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ KeyNotFound signalFor: key ]."},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\torderedKeys := orderedKeys copy.\r\tdictionary := dictionary copy."},{"name":"includesAssociation:","linesOfCode":2,"sourceCode":"includesAssociation: anAssociation\r\t^ dictionary includesAssociation: anAssociation"},{"name":"isHealthy","linesOfCode":2,"sourceCode":"isHealthy\r\t^ dictionary isHealthy"},{"name":"indexOfKey:","linesOfCode":2,"sourceCode":"indexOfKey: aKey\r\t^ self indexOfKey: aKey ifAbsent: [0]"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [ self errorKeyNotFound: secondKey ]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":9,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #OrderedDictionary earlyFields: self size fields: [\r\t\tArray streamContents: [ :out |\r\t\t\tself keysDo: [ :key |\r\t\t\t\tout nextPut: (key encodeGraphForMessagePackWith: graphEncoder);\r\t\t\t\t\tnextPut: ((self at: key) encodeGraphForMessagePackWith: graphEncoder)\r\t\t\t]\r\t\t]\r\t]"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^ dictionary hash"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: aBlock\r\tself shouldNotImplement"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":2,"sourceCode":"keyAtIdentityValue: aValue ifAbsent: aBlock\r\t^ dictionary keyAtIdentityValue: aValue ifAbsent: aBlock"},{"name":"keysDo:","linesOfCode":2,"sourceCode":"keysDo: aBlock\r\t1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t1 to: self size do: [:i | orderedKeys at: i put: nil].\r\tdictionary removeAll."},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: aCapacity\r\tdictionary := self dictionaryClass new: aCapacity.\r\torderedKeys := Array new: aCapacity."},{"name":"keys","linesOfCode":2,"sourceCode":"keys\r\t^ orderedKeys copyFrom: 1 to: self size"},{"name":"identityIndexOfKey:","linesOfCode":2,"sourceCode":"identityIndexOfKey: aKey\r\t^ self identityIndexOfKey: aKey ifAbsent: [0]"},{"name":"replaceKey:with:","linesOfCode":7,"sourceCode":"replaceKey: aKey with: otherKey\r\t| value index |\r\t\r\tvalue := self at: aKey.\r\tindex := orderedKeys indexOf: aKey.\r\tdictionary removeKey: aKey.\r\tdictionary at: otherKey put: value.\r\torderedKeys at: index put: otherKey\r\t"},{"name":"values","linesOfCode":2,"sourceCode":"values\r\t^ self associations collect: [:each | each value]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue\r"},{"name":"keysSortedSafely","linesOfCode":2,"sourceCode":"keysSortedSafely\r\t^ dictionary keysSortedSafely"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\tencoder encodeMap: self"},{"name":"keyAtIndex:","linesOfCode":2,"sourceCode":"keyAtIndex: anIndex\r\t^ self keyAtIndex: anIndex ifAbsent: [self errorInvalidIndex: anIndex]"},{"name":"identityIndexOfKey:ifAbsent:","linesOfCode":5,"sourceCode":"identityIndexOfKey: aKey ifAbsent: aBlock\r\t1 to: self size do: [:i |\r\t\t(orderedKeys at: i) == aKey\r\t\t\tifTrue: [^ i]].\r\t^ aBlock value."},{"name":"associationsSelect:","linesOfCode":2,"sourceCode":"associationsSelect: aBlock\r\t^ self species newFrom: (self associations select: aBlock)"},{"name":"at:ifPresent:","linesOfCode":2,"sourceCode":"at: aKey ifPresent: aBlock\r\t^ dictionary at: aKey ifPresent: aBlock"},{"name":"storeOn:","linesOfCode":12,"sourceCode":"storeOn: aStream\r\taStream << '((' << self class name << ' new)'.\r\tself associations\r\t\tifNotEmpty: [ :assos | \r\t\t\tassos\r\t\t\t\tdo: [ :each | \r\t\t\t\t\taStream\r\t\t\t\t\t\t<< ' add: ';\r\t\t\t\t\t\tstore: each ]\r\t\t\t\tseparatedBy: [ aStream << ';' ].\r\t\t\taStream << '; yourself' ].\r\taStream << ')'"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":2,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t^ dictionary associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock"},{"name":"keyAtIndex:ifAbsent:","linesOfCode":4,"sourceCode":"keyAtIndex: anIndex ifAbsent: aBlock\r\t^ (anIndex > 0 and: [ anIndex <= self size ])\r\t\tifTrue: [ orderedKeys at: anIndex ]\r\t\tifFalse: [ aBlock value ]"},{"name":"select:","linesOfCode":3,"sourceCode":"select: aBlock\r\t^ self species newFrom:\r\t\t(self associations select: [:each | aBlock value: each value])"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: aKey put: aValue\r\t| oldSize |\r\r\toldSize := dictionary size.\r\tdictionary at: aKey put: aValue.\r\tdictionary size > oldSize\r\t\tifTrue: [\r\t\t\torderedKeys size > oldSize\r\t\t\t\tifFalse: [self growOrderedKeys].\r\t\t\torderedKeys at: oldSize + 1 put: aKey].\r\t^ aValue."},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^ self associationAt: varName ifAbsent: [nil]"}],"meta":{"name":"OrderedDictionary class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: aCapacity\r\t^ self basicNew initialize: aCapacity"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: aSequenceableCollection\r\t| newDictionary |\r\r\tnewDictionary := self new: (aSequenceableCollection size / 2) floor.\r\t1 to: aSequenceableCollection size - 1 by: 2 do: [:i |\r\t\tnewDictionary\r\t\t\tat: (aSequenceableCollection at: i)\r\t\t\tput: (aSequenceableCollection at: i + 1)].\r\t^ newDictionary."},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ Dictionary inspectorClass"},{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"My instances are stored as maps.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"},{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\r\t\"(OrderedDictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (OrderedDictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 10"},{"name":"newFrom:","linesOfCode":8,"sourceCode":"newFrom: anAssociationCollection\r\t| newDictionary |\r\r\tnewDictionary := self new: anAssociationCollection size.\r\tanAssociationCollection associationsDo: [:each |\r\t\tnewDictionary\r\t\t\tat: each key\r\t\t\tput: each value].\r\t^ newDictionary."},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #OrderedDictionary ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext pairsDo: [ :key :value |\r\t\t\tresult at: key put: value\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"}],"meta":null}},{"name":"SmallDictionary","instanceVariables":[{"name":"keys"},{"name":"values"},{"name":"size"}],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise store and return the result of evaluating the second block as the\r\tnew value of the key.\"\r\r\t^ self\r\t\tat: key\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [ self at: key put: anAbsentBlock value ]"},{"name":"at:ifAbsentPut:","linesOfCode":9,"sourceCode":"at: key ifAbsentPut: aBlock\r\t\"Return the value at the given key.\r\tIf the key is not included in the receiver store and return the result \r\tof evaluating aBlock as the new value.\"\r\t\r\t| index |\r\tindex := self findIndexForKey:  key.\r\t^ index = 0 \r\t\tifFalse: [values at: index]\r\t\tifTrue: [self privateAt: key put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":10,"sourceCode":"associationAt: key ifPresent: aBlock\r\t\"Answer the value of evaluating aBlock optionally with an association\r\tfor the given key.\r\tIf the key is not found, return nil.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t| index |\r\t(index := keys indexOf: key) = 0\r\t\tifTrue: [ ^ nil ].\r\t^ aBlock cull: key -> (values at: index)"},{"name":"includesKey:","linesOfCode":3,"sourceCode":"includesKey: key\r\t\"Answer whether the receiver has a key equal to the argument, key.\"\r\r\t^ (self findIndexForKey: key) ~= 0"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: aValue\r\tself do: [:each | aValue = each ifTrue: [^true]].\r\t^false"},{"name":"printElementsOn:","linesOfCode":10,"sourceCode":"printElementsOn: aStream\r\t| noneYet |\r\taStream nextPut: $(.\r\tnoneYet := true.\r\tself associationsDo: [ :each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [ noneYet := false ]\r\t\t\t\tifFalse: [ aStream space ].\r\t\t\taStream print: each].\r\taStream nextPut: $)"},{"name":"hasBindingThatBeginsWith:","linesOfCode":6,"sourceCode":"hasBindingThatBeginsWith: aString\r\t\"Answer true if the receiver has a key that begins with aString, false otherwise\"\r\t\r\tself keysDo:[:each | \r\t\t(each beginsWith: aString)\r\t\t\tifTrue:[^true]].\r\t^false"},{"name":"stonOn:","linesOfCode":5,"sourceCode":"stonOn: stonWriter\r\t\"I store my instances as maps\"\r\t\r\tstonWriter \r\t\twriteObject: self \r\t\tdo: [ stonWriter encodeMap: self ]"},{"name":"at:update:initial:","linesOfCode":11,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\r\tI use findElementOrNil: to avoid looking up the key twice.\"\r\t| index |\r\tindex := self findIndexForKey: key.\r\t(index = 0)\r\t\tifTrue:  [ self at: key put: initBlocktOrValue value]\r\t\tifFalse: [ (values at: index) in: [ :val | values at: index put: (updateBlock value: val) ] ]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my values as the argument.  Collect the\r\tresulting values into a collection that is like me. Answer with the new\r\tcollection.\"\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo:[:each |\r\t\tnewCollection at: each key put: (aBlock value: each value).\r\t].\r\t^newCollection"},{"name":"=","linesOfCode":13,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aKeyedCollection\r\taKeyedCollection == self \r\t\tifFalse: [\r\t\t\taKeyedCollection keysAndValuesDo: [:key :value | self at: key put: value]].\r\t^aKeyedCollection"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\r\tKeyNotFound signalFor: aKey"},{"name":"associationAt:","linesOfCode":5,"sourceCode":"associationAt: key \r\t\"Returns an association for the given key.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\r\t^ self valuesDo: aBlock."},{"name":"removeKey:ifAbsent:","linesOfCode":17,"sourceCode":"removeKey: key ifAbsent: aBlock \r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index value |\r\tindex := self findIndexForKey:  key.\r\tindex = 0 ifTrue: [^aBlock value].\r\t\r\tvalue := values at: index.\r\tindex to: size - 1\r\t\tdo: \r\t\t\t[:i | \r\t\t\tkeys at: i put: (keys at: i + 1).\r\t\t\tvalues at: i put: (values at: i + 1)].\r\tkeys at: size put: nil.\r\tvalues at: size put: nil.\r\tsize := size - 1.\r\t^value"},{"name":"includesIdentity:","linesOfCode":4,"sourceCode":"includesIdentity: aValue\r\t\"Answer whether aValue is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check\"\r\r\tself do: [:each | aValue == each ifTrue: [^ true]].\r\t^ false"},{"name":"keyAtIdentityValue:","linesOfCode":5,"sourceCode":"keyAtIdentityValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r\r\t^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^true"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^size"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself at: key ifPresent: [ :v | ^ aPresentBlock cull: v ].\r\t^ anAbsentBlock value"},{"name":"initialize","linesOfCode":5,"sourceCode":"initialize\r\tsuper initialize.\r\tkeys := Array new: 2.\r\tvalues := Array new: 2.\r\tsize := 0"},{"name":"keyForIdentity:","linesOfCode":4,"sourceCode":"keyForIdentity: aValue\r\t\"If aValue is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check\"\r\r\tself keysAndValuesDo: [:key :value |  value == aValue ifTrue: [^  key]].\r\t^ nil"},{"name":"capacity","linesOfCode":2,"sourceCode":"capacity\r\t^keys size"},{"name":"associationAt:ifAbsent:","linesOfCode":10,"sourceCode":"associationAt: key ifAbsent: aBlock \r\t\"Answer an association for the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t| index value |\r\tindex := keys indexOf: key.\r\tindex = 0 ifTrue: [ ^ aBlock value].\r\t\r\tvalue := values at: index.\r\t^ key->value."},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"setClass","linesOfCode":2,"sourceCode":"setClass\r\t^ Set"},{"name":"at:","linesOfCode":3,"sourceCode":"at: key \r\t\"Answer the value associated with the key.\"\r\r\t^ self at: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"keysAndValuesRemove:","linesOfCode":10,"sourceCode":"keysAndValuesRemove: keyValueBlock\r\t\"Removes all entries for which keyValueBlock returns true.\"\r\t\"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method.\"\r\r\t| removals |\r\tremovals := OrderedCollection new.\r\tself keysAndValuesDo:\r\t\t[:key :value | (keyValueBlock value:  key value:  value)\r\t\t\tifTrue: [removals add:  key]].\r \tremovals do:\r\t\t[:aKey | self removeKey: aKey]"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"errorValueNotFound:","linesOfCode":2,"sourceCode":"errorValueNotFound: value\r\r\tValueNotFound signalFor: value"},{"name":"at:ifAbsent:","linesOfCode":11,"sourceCode":"at: key ifAbsent: aBlock \r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t| index |\r\tindex := self findIndexForKey:  key.\r\tindex = 0 ifTrue: [^ aBlock value].\r\t\r\t^ values at: index.\r\r\t\"| assoc |\r\tassoc := array at: (self findElementOrNil: key).\r\tassoc ifNil: [^ aBlock value].\r\t^ assoc value\""},{"name":"keyAtValue:ifAbsent:","linesOfCode":10,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\t: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast.\"\r\t\r\t| index |\r\tindex := (values indexOf: value).\r\tindex = 0 \r\t\tifTrue: [ ^ exceptionBlock value].\r\t\t\r\t^ keys at: index.\r\r"},{"name":"privateAt:put:","linesOfCode":5,"sourceCode":"privateAt: key put: value \r\tsize == keys size ifTrue: [self growKeysAndValues].\r\tsize := size + 1.\r\tkeys at: size put: key.\r\t^values at: size put: value"},{"name":"associations","linesOfCode":7,"sourceCode":"associations\r\t\"Answer a collection containing associations for the receiver.\r\tSuggested by l. Uzonyi\r\r\tModifying the associations won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\t\r\t^Array new: self size streamContents: [ :stream |\r \t\tself associationsDo: [ :each | stream nextPut: each ] ]"},{"name":"empty","linesOfCode":5,"sourceCode":"empty\r\t1 to: size do: [ :index |\r\t\tkeys at: index put: nil.\r\t\tvalues at: index put: nil ].\r\tsize := 0\r"},{"name":"removeKey:","linesOfCode":4,"sourceCode":"removeKey: key \r\t\"Remove key from the receiver.\r\tIf key is not in the receiver, notify an error.\"\r\r\t^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"findIndexForKey:","linesOfCode":2,"sourceCode":"findIndexForKey: aKey \r\t^ keys indexOf: aKey."},{"name":"growTo:","linesOfCode":11,"sourceCode":"growTo: aSize \r\t| newKeys newValues |\r\tnewKeys := Array new: aSize.\r\tnewValues := Array new: aSize.\r\t1 to: size\r\t\tdo: \r\t\t\t[:i | \r\t\t\tnewKeys at: i put: (keys at: i).\r\t\t\tnewValues at: i put: (values at: i)].\r\tkeys := newKeys.\r\tvalues := newValues"},{"name":"valuesDo:","linesOfCode":3,"sourceCode":"valuesDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's values.\"\r\r1 to: size do: [:i | aBlock value: (values at: i)]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation \r\tself at: anAssociation key put: anAssociation value.\r\t^anAssociation"},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each association for the receiver.\r\r\tModifying the associations won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\t\r\tself keysAndValuesDo: [:key :value | aBlock value: key -> value]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":11,"sourceCode":"declare: key from: aDictionary \r\t\"Add key to the receiver. If key already exists, do nothing. If aDictionary \r\tincludes key, then remove it from aDictionary and use its association as \r\tthe element of the receiver.\"\r\r\t(self includesKey: key) ifTrue: [^ self].\r\t(aDictionary includesKey: key)\r\t\tifTrue: \r\t\t\t[self add: (aDictionary associationAt: key).\r\t\t\taDictionary removeKey: key]\r\t\tifFalse: \r\t\t\t[self add: key -> nil]"},{"name":"difference:","linesOfCode":12,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. This is a specialized version for Dictionaries keeping the keys of the objects. At a slightly higher price of an additional Set to track duplicates.\"\r\r\t| other result duplicates |\r\t\r\tother := aCollection asSet.\r\tduplicates := Set new.\r\tresult := self class new: self size.\r\t\r\tself keysAndValuesDo: [ :key :value|\r\t\t((other includes: value) not and: [ (duplicates includes: value) not ])\r\t\t\tifTrue: [ \r\t\t\t\tduplicates add: value.\r\t\t\t\tresult at: key put: value]].\r\t\r\t^ result"},{"name":"keyAtValue:","linesOfCode":4,"sourceCode":"keyAtValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\"\r\r\t^self keyAtValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ self errorKeyNotFound: key ]."},{"name":"keysAndValuesDo:","linesOfCode":2,"sourceCode":"keysAndValuesDo: aBlock\r\t1 to: size do: [:i | aBlock value: (keys at: i) value: (values at: i)]"},{"name":"remove:","linesOfCode":2,"sourceCode":"remove:anAssociation\r\r\tself removeKey:anAssociation key."},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tkeys := keys copy.\r\tvalues := values copy"},{"name":"includesAssociation:","linesOfCode":4,"sourceCode":"includesAssociation: anAssociation\r  ^ (self   \r      associationAt: anAssociation key\r      ifAbsent: [ ^ false ]) value = anAssociation value\r"},{"name":"isHealthy","linesOfCode":13,"sourceCode":"isHealthy\r\t\"Since this dictionary does no hashing, we consider it healthy\r\tif it contains no duplicate keys.\"\r\r\t| uniqueKeys |\r\tuniqueKeys := self setClass new: self size.\r\tkeys\r\t\tdo: [ :each | \r\t\t\teach\r\t\t\t\tifNotNil: [\r\t\t\t\t\t(uniqueKeys includes: each)\r\t\t\t\t\t\tifTrue: [ ^ false ].\r\t\t\t\t\tuniqueKeys add: each ] ].\r\t^ true"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [ self errorKeyNotFound: secondKey ]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\tself removeKey: oldObject key ifAbsent: anExceptionBlock.\r\t^oldObject"},{"name":"growKeysAndValues","linesOfCode":2,"sourceCode":"growKeysAndValues\r\tself growTo: size * 2"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":10,"sourceCode":"keyAtIdentityValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r \t\r\t| index |\r\tindex := (values identityIndexOf: value).\r\tindex = 0 \r\t\tifTrue: [ ^ exceptionBlock value].\r\t^ keys at: index.\r"},{"name":"keysDo:","linesOfCode":2,"sourceCode":"keysDo: aBlock \r\t1 to: size do: [:i | aBlock value: (keys at: i)]"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\tself initialize."},{"name":"keys","linesOfCode":3,"sourceCode":"keys\r\t\"Answer an Array containing the receiver's keys.\"\r\t\r\t^ keys copyFrom: 1 to: size"},{"name":"values","linesOfCode":5,"sourceCode":"values\r\t\"Answer a Collection containing the receiver's values.\"\r\t^Array \r\t\tnew: self size \r\t\tstreamContents: [ :out | self valuesDo: [:value | out nextPut: value]]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue\r"},{"name":"keysSortedSafely","linesOfCode":14,"sourceCode":"keysSortedSafely\r\t\"Answer a SortedCollection containing the receiver's keys.\"\r\t| sortedKeys |\r\tsortedKeys := SortedCollection new: self size.\r\tsortedKeys sortBlock:\r\t\t[:x :y |  \"Should really be use <obj, string, num> compareSafely...\"\r\t\t((x isString and: [y isString])\r\t\t\tor: [x isNumber and: [y isNumber]])\r\t\t\tifTrue: [x < y]\r\t\t\tifFalse: [x class == y class\r\t\t\t\tifTrue: [x printString < y printString]\r\t\t\t\tifFalse: [x class name < y class name]]].\r\tself keysDo: [:each | sortedKeys addLast: each].\r\t^ sortedKeys reSort"},{"name":"storeOn:","linesOfCode":14,"sourceCode":"storeOn: aStream\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself associationsDo: [ :each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [ noneYet := false ]\r\t\t\t\tifFalse: [ aStream nextPut: $; ].\r\t\t\taStream nextPutAll: ' add: '.\r\t\t\taStream store: each].\r\tnoneYet ifFalse: [ aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"associationsSelect:","linesOfCode":10,"sourceCode":"associationsSelect: aBlock \r\t\"Evaluate aBlock with each of my associations as the argument. Collect\r\tinto a new dictionary, only those associations for which aBlock evaluates\r\tto true.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:ifPresent:","linesOfCode":8,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t| v |\r\tv := self at: key ifAbsent: [^ nil].\r\t^ aBlock cull: v\r"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the association for the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself associationAt: key ifPresent: [:assoc | ^ aPresentBlock cull: assoc].\r\t^ anAbsentBlock value"},{"name":"select:","linesOfCode":10,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of my values as the argument. Collect into a\r\tnew dictionary, only those associations for which aBlock evaluates to\r\ttrue.\"\r\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each value) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:put:","linesOfCode":8,"sourceCode":"at: key put: value \r\t\"Set the value at key to be anObject.  If key is not found, create a\r\tnew entry for key and set is value to anObject. Answer anObject.\"\r\r\t| index |\r\tindex := self findIndexForKey:  key.\r\t^ index = 0\r\t\tifFalse: [values at: index put: value]\r\t\tifTrue: [self privateAt: key put: value]\t\r\t"},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^self associationAt: varName ifAbsent:[nil]"}],"meta":{"name":"SmallDictionary class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: aSize \r\t\"Ignore the size\"\r\r\t^self basicNew initialize"},{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\r\t\"(SmallDictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (SmallDictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: anArray \r\t\"Answer an instance of me associating (anArray at:i) to (anArray at: i+i) for each odd i.  anArray must have an even number of entries.\"\r\r\t| newDictionary |\r\r\tnewDictionary := self new: (anArray size/2).\r\t1 to: (anArray size-1) by: 2 do: [ :i|\r\t\tnewDictionary at: (anArray at: i) put: (anArray at: i+1).\r\t].\r\t^ newDictionary"},{"name":"newFrom:","linesOfCode":11,"sourceCode":"newFrom: aDict \r\t\"Answer an instance of me containing the same associations as aDict.\r\t Error if any key appears twice.\"\r\t| newDictionary |\r\tnewDictionary := self new: aDict size.\r\taDict associationsDo:\r\t\t[:x |\r\t\t(newDictionary includesKey: x key)\r\t\t\tifTrue: [self error: 'Duplicate key: ', x key printString]\r\t\t\tifFalse: [newDictionary add: x]].\r\t^ newDictionary"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r    ^ EyeDictionaryInspector"},{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"My instances are stored as maps.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"}],"meta":null}},{"name":"WeakRegistry","instanceVariables":[{"name":"list"},{"name":"valueDictionary"},{"name":"sema"}],"methods":[{"name":"protected:","linesOfCode":5,"sourceCode":"protected: aBlock\r\t\"Execute aBlock protected by the accessLock\"\r\r\t^ sema\r\t\tcritical: aBlock\r\t\tifError: [ :err | err signal ]"},{"name":"removeAll","linesOfCode":6,"sourceCode":"removeAll\r\t\"See super\"\r\t\r\tself protected:[\r\t\tvalueDictionary removeAll.\r\t\tlist swapWithNil. \"prune finalization list as well\"\r\t]"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ self protected: [ valueDictionary slowSize ]"},{"name":"finalizeValues","linesOfCode":24,"sourceCode":"finalizeValues\r\t\"Finalize any values, which happen to stocked in our list, due to some weak references become garbage\"\r\t\r\t| finalizer |\r\r\t\"Do the old way, if VM don't supports us\"\r\tWeakFinalizationList hasNewFinalization ifFalse: [ | finalizers |\r\t\tfinalizers := OrderedCollection new.\r\t\tself protected: [ \r\t\t\tvalueDictionary expiredValuesDo: [:finItem |\r\t\t\t\tfinalizers add: finItem\r\t\t\t\t].\r\t\t ].\r\t\tfinalizers do: [:each | [each finalizeValues] on: Exception fork: [:ex | ex pass ] ].\r\t\t^ self ].\r\r\tself protected: [ finalizer := list swapWithNil ].\r\r\t\"We don't need to protect a following loop from concurrent access,\r\tbecause at the moment we're finalizing values, \r\tonly we can access this list of finalizers, because valueDictionary already see them\r\tas an unused slots, because they're associated with key == nil\"\r\t\r\t[ finalizer notNil ] whileTrue: [\r\t\t| next |\r\t\tnext := finalizer next.\r\t\t[ finalizer finalizeValues] on: Exception fork: [:ex | ex pass ].\r\t\tfinalizer := next\r\t]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anObject\r\t\"Add anObject to the receiver. Store the object as well as the associated executor.\"\r\t\r\t^self add: anObject executor: anObject executor"},{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\tsuper initialize.\r\tvalueDictionary := WeakIdentityKeyDictionary new.\r\tlist := WeakFinalizationList new.\r\tsema := Semaphore forMutualExclusion.\r\tself installFinalizer"},{"name":"keys","linesOfCode":2,"sourceCode":"keys\r\r\t^self protected: [ valueDictionary keys ]\r"},{"name":"printElementsOn:","linesOfCode":3,"sourceCode":"printElementsOn: aStream\r\tsema ifNil: [ ^super printElementsOn: aStream ].\r\taStream nextPutAll: '(<this WeakRegistry is locked>)'"},{"name":"add:executor:","linesOfCode":12,"sourceCode":"add: anObject executor: anExecutor\r\t\"With new finalization, we can simply override associations with key == nil in valueDictionary \"\r\tself protected: [ | finItem |\r\t\tfinItem := valueDictionary at: anObject ifAbsent: [\r\t\t\tWeakFinalizationList hasNewFinalization ifTrue: [\r\t\t\t\tvalueDictionary overridingAt: anObject put: (WeakFinalizerItem new list: list object: anObject) ]\r\t\t\tifFalse: [\r\t\t\t\tvalueDictionary at: anObject put: (WeakFinalizerItem new list: list object: anObject) \r\t\t\t\t]\r\t\t].\r\t\tfinItem add: anExecutor ].\r\t^ anObject\r"},{"name":"postCopy","linesOfCode":12,"sourceCode":"postCopy\r\t\"should we prohibit any attempts to copy receiver?\"\r\tself protected: [ | oldDict |\r\t\tsema := Semaphore forMutualExclusion.\r\t\toldDict := valueDictionary.\r\t\tlist := WeakFinalizationList new.\r\t\tvalueDictionary := WeakIdentityKeyDictionary new.\r\t\tself installFinalizer.\r\t\r\t\toldDict keysAndValuesDo: [:key :value |\r\t\t\tvalueDictionary at: key put: (value copyWithList: list)\r\t\t].\r\t]"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t^self protected: [\r\t\tvalueDictionary keysDo: aBlock\r\t]\r"},{"name":"installFinalizer","linesOfCode":4,"sourceCode":"installFinalizer\r\t\"Do nothing, pharo does not supports it right now\r\t  valueDictionary finalizer: #finalizeValues\r\t\""},{"name":"species","linesOfCode":2,"sourceCode":"species\r\t^Set"},{"name":"remove:ifAbsent:","linesOfCode":5,"sourceCode":"remove: oldObject ifAbsent: exceptionBlock\r\t\"Remove oldObject as one of the receiver's elements.\"\r\t\r\toldObject ifNil: [ ^nil ].\r\t^(self protected: [ valueDictionary removeKey: oldObject ifAbsent: nil ])\r\t\tifNil: [ exceptionBlock value ]"}],"meta":{"name":"WeakRegistry class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^ self new"},{"name":"default","linesOfCode":2,"sourceCode":"default\r\t^Default ifNil: [ Default := self new ]"},{"name":"new","linesOfCode":5,"sourceCode":"new\r\t| registry |\r\tregistry := super new.\r\tWeakArray addWeakDependent: registry.\r\t^registry\r"}],"meta":null}},{"name":"WideCharacterSet","instanceVariables":[{"name":"map"},{"name":"byteArrayMap"}],"methods":[{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\tmap removeAll.\r\tbyteArrayMap := ByteArray new: 256"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":8,"sourceCode":"size\r\t| size |\r\tsize := 0.\r\tmap\r\t\tkeysAndValuesDo: [:high :lowmap | self\r\t\t\t\tbitmap: lowmap\r\t\t\t\tdo: [:low | size := size + 1]].\r\t^ size"},{"name":"add:","linesOfCode":10,"sourceCode":"add: aCharacter \r\t| val high low lowmap |\r\tval := aCharacter asciiValue.\r\tval < 256 ifTrue: [self byteArrayMap at: val + 1 put: 1].\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\tlowmap := map at: high ifAbsentPut: [\"create a chunk of 65536=8192*8 bits\"\r\t\tByteArray new: 8192].\r\tself setBitmap: lowmap at: low.\r\t^ aCharacter"},{"name":"byteArrayMap","linesOfCode":11,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.\r\tIntended for use by primitives only. (and comparison)\r\tThis version will answer a subset with only byte characters\"\r\t\r\t| lowmap |\r\tbyteArrayMap ifNil: [\r\t\tbyteArrayMap := ByteArray new: 256.\r\t\tlowmap := map at: 0 ifAbsent: [^byteArrayMap].\r\t\tlowmap := lowmap copyFrom: 1 to: 32. \"Keep first 8*32=256 bits...\"\r\t\tself bitmap: lowmap do: [:code | byteArrayMap at: code + 1 put: 1]].\r\t^byteArrayMap"},{"name":"includes:","linesOfCode":10,"sourceCode":"includes: aCharacter \r\t| val high low |\r\tval := aCharacter asciiValue.\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\t^(self\r\t\tbitmap: (map\r\t\t\t\tat: high\r\t\t\t\tifAbsent: [^ false])\r\t\tat: low) isZero not"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tsuper initialize.\r\tmap := Dictionary new.\r\tbyteArrayMap := ByteArray new: 256"},{"name":"setBitmap:at:","linesOfCode":7,"sourceCode":"setBitmap: aMap at: shortInteger\r\t\"set a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))"},{"name":"remove:","linesOfCode":13,"sourceCode":"remove: aCharacter \r\t| val high low lowmap |\r\tval := aCharacter asciiValue.\r\tval < 256 ifTrue: [self byteArrayMap at: val + 1 put: 0].\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\tlowmap := map\r\t\t\t\tat: high\r\t\t\t\tifAbsent: [^ aCharacter].\r\tself clearBitmap: lowmap at: low.\r\t(lowmap allSatisfy: [:e | e = 0])\r\t\tifTrue: [map removeKey: high].\r\t^ aCharacter"},{"name":"=","linesOfCode":3,"sourceCode":"= anObject\r\t^self species == anObject species and: [\r\t\tself wideCharacterMap = anObject wideCharacterMap ]"},{"name":"hasWideCharacters","linesOfCode":4,"sourceCode":"hasWideCharacters\r\t\"Answer true if i contain any wide character\"\r\t\r\tself do: [:e | e asciiValue >= 256 ifTrue: [^true]].\r\t^false"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tmap := map collect: [:each | each copy]"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^CharacterSetComplement of: self copy"},{"name":"clearBitmap:at:","linesOfCode":7,"sourceCode":"clearBitmap: aMap at: shortInteger\r\t\"clear a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))"},{"name":"do:","linesOfCode":8,"sourceCode":"do: aBlock \r\tmap\r\t\tkeysAndValuesDo: [:index :lowmap |\r\t\t\t| high16Bits |\r\t\t\thigh16Bits := index bitShift: 16.\r\t\t\tself\r\t\t\t\tbitmap: lowmap\r\t\t\t\tdo: [:low16Bits | aBlock value: (Character value: high16Bits + low16Bits)]]"},{"name":"bitmap:at:","linesOfCode":7,"sourceCode":"bitmap: aMap at: shortInteger\r\t\"access a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)"},{"name":"species","linesOfCode":4,"sourceCode":"species\r\t^self hasWideCharacters\r\t\tifTrue: [WideCharacterSet]\r\t\tifFalse: [CharacterSet]"},{"name":"hash","linesOfCode":8,"sourceCode":"hash\r\t\"Answer a hash code aimed at storing and retrieving the receiver in a Set or Dictionary.\r\tTwo equal objects should have equal hash.\r\tNote: as the receiver can be equal to an ordinary CharacterSet,\r\tthe hash code must reflect this\"\r\t\r\t^self hasWideCharacters\r\t\tifTrue: [map hash]\r\t\tifFalse: [self asCharacterSet hash]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"bitmap:do:","linesOfCode":13,"sourceCode":"bitmap: aMap do: aBlock\r\t\"Execute a block with each value (0 based) corresponding to set bits.\r\tImplementation notes: this version works best for sparse maps.\r\tIt has (byte lowBit) inlined for speed.\"\r\t\r\t| byte byteOffset lowBits |\r\tlowBits := #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]. \"The lowBits table gives a 1-based bitOffset\"\r\t1 to: aMap size do: [:i | \r\t\t(byte := aMap at: i) = 0 ifFalse: [\r\t\t\tbyteOffset := (i bitShift: 3) - 9. \"This byteOffset is -1 based\"\r\t\t\t[\"Evaluate the block with 0-based (byteOffset + bitOffset)\"\r\t\t\taBlock value: (byteOffset + (lowBits at: byte)).\r\t\t\t\"Eliminate the low bit and loop if some bit remain\"\r\t\t\t(byte := byte bitAnd: byte - 1) = 0] whileFalse]]"},{"name":"wideCharacterMap","linesOfCode":2,"sourceCode":"wideCharacterMap\r\t^map"}],"meta":{"name":"WideCharacterSet class","instanceVariables":[],"methods":[{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t| newCollection |\r\tnewCollection := self new.\r\tnewCollection addAll: aCollection.\r\t^newCollection"}],"meta":null}},{"name":"FLLargeIdentityHashedCollection","instanceVariables":[{"name":"tally"},{"name":"tallies"}],"methods":[{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\r\ttally := 0.\r\ttallies := Array new: 4096 withAll: 0"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\r\t^tally"},{"name":"postCopy","linesOfCode":2,"sourceCode":"postCopy\r\r\ttallies := tallies copy\r"}],"meta":{"name":"FLLargeIdentityHashedCollection class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\r\t| rng |\r\trng := Random seed: 664399324.\r\tPermutationMap := (0 to: 4095) asArray shuffleBy: rng"},{"name":"permuteHash:","linesOfCode":3,"sourceCode":"permuteHash: anInteger\r\t\"Return an integer between 1 and 4096 when the argument is between 1 and 4096.\"\r\r\t^PermutationMap at: anInteger"}],"meta":null}},{"name":"RelationSet","instanceVariables":[{"name":"owner"},{"name":"slot"},{"name":"set"}],"methods":[{"name":"inverseRemove:","linesOfCode":2,"sourceCode":"inverseRemove: anObject\r\r\t^set remove: anObject"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^set ifNil: [0] ifNotNil: [ set size ]"},{"name":"add:","linesOfCode":6,"sourceCode":"add: anObject\r\r\t(self includes: anObject)\r\t\tifTrue: [ ^anObject ].\r\t\t\r\tslot add: anObject to: owner.\r\t^set add: anObject"},{"name":"copy","linesOfCode":4,"sourceCode":"copy\r\r\t^Set new \r\t\taddAll: self;\r\t\tyourself"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tset do: aBlock"},{"name":"inverseAdd:","linesOfCode":2,"sourceCode":"inverseAdd: anObject\r\r\t^set add: anObject"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\r\t(set includes: oldObject)\r\t\tifFalse: [ ^aBlock value ].\r\t\t\r\tslot remove: oldObject from: owner.\r\t^set remove: oldObject ifAbsent: aBlock"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^Set"},{"name":"initializeOwner:slot:","linesOfCode":4,"sourceCode":"initializeOwner: anObject slot: aToManyAssociation\r\r\towner := anObject.\r\tslot := aToManyAssociation.\r\tset := Set new"}],"meta":{"name":"RelationSet class","instanceVariables":[],"methods":[{"name":"owner:slot:","linesOfCode":2,"sourceCode":"owner: anObject slot: aToManyAssociation\r\r\t^self new initializeOwner: anObject slot: aToManyAssociation "}],"meta":null}},{"name":"SLVMRedBlackTreeCollection","instanceVariables":[{"name":"root"},{"name":"size"}],"methods":[{"name":"moveRedLeft:","linesOfCode":10,"sourceCode":"moveRedLeft: node\r\t| h |\r\th := node.\r\tself colorFlip: h.\r\t(self isRed: h right left) ifTrue: [\r\t\th right: (self rotateRight: h right).\r\t\th := self rotateLeft: h.\r\t\tself colorFlip: h.\r\t].\r\r\t^ h"},{"name":"moveRedRight:","linesOfCode":9,"sourceCode":"moveRedRight: node\r\t| h |\r\th := node.\r\tself colorFlip: h.\r\t(self isRed: h left left) ifTrue: [\r\t\th := self rotateRight: h.\r\t\tself colorFlip: h.\r\t].\r\r\t^ h"},{"name":"nodeSpecies","linesOfCode":2,"sourceCode":"nodeSpecies\r\t^ SLVMRedBlackTreeNode"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ size"},{"name":"rotateRight:","linesOfCode":8,"sourceCode":"rotateRight: h\r\t| x |\r\tx := h left.\r\th left: x right.\r\tx right: h.\r\tx color: h color.\r\th color: Red.\r\t^ x"},{"name":"lastNode","linesOfCode":2,"sourceCode":"lastNode\r\t^ self getMaxNodeFrom: root"},{"name":"add:","linesOfCode":3,"sourceCode":"add: aValue\r\troot := self insertKey: aValue value: aValue from: root.\r\troot color: Black"},{"name":"getMinNodeFrom:","linesOfCode":9,"sourceCode":"getMinNodeFrom: node\r\t| position bestResult |\r\tposition := node.\r\tbestResult := node.\r\t[ position isNil ] whileFalse: [\r\t\tbestResult := position.\r\t\tposition := position left\r\t].\r\t^ bestResult\r"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tsize := 0."},{"name":"insertKey:value:from:","linesOfCode":18,"sourceCode":"insertKey: key value: aValue from: node\r\t| hkey h |\r\th := node.\r\th ifNil: [ \r\t\tsize := size + 1.\r\t\t^ self nodeSpecies value: aValue color: Red\r\t].\r\r\thkey := h key.\r\tkey < hkey ifTrue: [ \r\t\th left: (self insertKey: key value: aValue from: h left)\r\t] ifFalse: [ \r\t\thkey < key ifTrue: [ \r\t\t\th right: (self insertKey: key value: aValue from: h right)\r\t\t] ifFalse: [\r\t\t\th value: aValue\r\t\t]\r\t].\r\r\t^ self fixUp: h"},{"name":"firstNode","linesOfCode":2,"sourceCode":"firstNode\r\t^ self getMinNodeFrom: root"},{"name":"colorFlip:","linesOfCode":4,"sourceCode":"colorFlip: h\r\th color: h color not.\r\th left color: h left color not.\r\th right color: h right color not."},{"name":"asArray","linesOfCode":9,"sourceCode":"asArray\r\t| array destIndex |\r\tarray := Array new: size.\r\tdestIndex := 1.\r\tself do: [ :value |\r\t\tarray at: destIndex put: value.\r\t\tdestIndex := destIndex + 1\r\t].\r\r\t^ array"},{"name":"isRed:","linesOfCode":2,"sourceCode":"isRed: node\r\t^ node isNotNil and: [node color == Red]"},{"name":"searchKey:from:","linesOfCode":16,"sourceCode":"searchKey: key from: node\r\t| nodeKey position |\r\tposition := node.\r\t[position ~~ nil] whileTrue: [ \r\t\tnodeKey := node key.\r\t\tkey < nodeKey ifTrue: [\r\t\t\tposition := node left\r\t\t] ifFalse: [ \r\t\t\tnodeKey < key ifTrue: [\r\t\t\t\tposition := node right\r\t\t\t] ifFalse: [\r\t\t\t\t^ node\r\t\t\t]\r\t\t]\r\t].\r\r\t^ nil\r"},{"name":"deleteMin:","linesOfCode":12,"sourceCode":"deleteMin: node\r\t| h |\r\th := node.\r\th left ifNil: [\r\t\tsize := size - 1.\r\t\t^ nil\r\t].\r\r\t((self isRed: h left) not and: [ (self isRed: h left left) not ]) ifTrue: [\r\t\th := self moveRedLeft: h\r\t].\r\r\th left: (self deleteMin: h left).\r\t^ self fixUp: h"},{"name":"gtTreeViewIn:","linesOfCode":8,"sourceCode":"gtTreeViewIn: composite\r\t<gtInspectorPresentationOrder: 9>\r\tself ifEmpty: [ ^ self ].\r\tcomposite tree \r\t\ttitle: 'Red-Black Tree';\r\t\tdisplay: [ :node | root ];\r\t\tchildren: [ :each | each childrenNodes ];\r\t\tformat: [ :node | node printString ]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\troot ifNotNil: [ root do: aBlock ]"},{"name":"rotateLeft:","linesOfCode":8,"sourceCode":"rotateLeft: h\r\t| x |\r\tx := h right.\r\th right: x left.\r\tx left: h.\r\tx color: h color.\r\th color: Red.\r\t^ x"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: oldObject ifAbsent: ifAbsentBlock\r\t(self searchKey: oldObject from: root) ifNil: [\r\t\t^ ifAbsentBlock value\r\t].\r\r\tself deleteKey: oldObject.\r\t^ oldObject"},{"name":"fixUp:","linesOfCode":13,"sourceCode":"fixUp: node\r\t| h |\r\th := node.\r\t((self isRed: h right) and: [ (self isRed: h left) not]) ifTrue: [\r\t\th := self rotateLeft: h\r\t].\r\t((self isRed: h left) and: [ self isRed: h left left]) ifTrue: [\r\t\th := self rotateRight: h\r\t].\r\t((self isRed: h left) and: [ self isRed: h right ]) ifTrue: [ \r\t\tself colorFlip: h\r\t].\r\t^ h"},{"name":"deleteKey:from:","linesOfCode":30,"sourceCode":"deleteKey: key from: node\r\t| h hkey equal |\r\th := node.\r\thkey := h key.\r\tkey < hkey ifTrue: [\r\t\t((self isRed: h left) not and: [ (self isRed: h left left) not]) ifTrue: [ \r\t\t\th := self moveRedLeft: h\r\t\t].\r\t\th left: (self deleteKey: key from: h left)\r\t] ifFalse: [\r\t\t(self isRed: h left) ifTrue: [\r\t\t\th := self rotateRight: h\r\t\t].\r\t\r\t\tequal := (hkey < key) not.\r\t\t(equal and: [ h right == nil ]) ifTrue: [\r\t\t\tsize := size - 1.\r\t\t\t^ nil\r\t\t].\r\t\t\r\t\t((self isRed: h right) not and: [ (self isRed: h right left ) not ]) ifTrue: [\r\t\t\th := self moveRedRight: h\r\t\t].\r\t\r\t\tequal ifTrue: [\r\t\t\th value: (self getMinNodeFrom: h right) value.\r\t\t\th right: (self deleteMin: h right)\r\t\t] ifFalse: [\r\t\t\th right: (self deleteKey: key from: h right)\r\t\t]\r\t].\r\r\t^ self fixUp: h"},{"name":"getMaxNodeFrom:","linesOfCode":9,"sourceCode":"getMaxNodeFrom: node\r\t| position bestResult |\r\tposition := node.\r\tbestResult := node.\r\t[ position isNil ] whileFalse: [\r\t\tbestResult := position.\r\t\tposition := position right\r\t].\r\t^ bestResult\r"},{"name":"deleteKey:","linesOfCode":3,"sourceCode":"deleteKey: key\r\troot := self deleteKey: key from: root.\r\troot color: Black"}],"meta":{"name":"SLVMRedBlackTreeCollection class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tRed := true.\r\tBlack := false.\r\t"}],"meta":null}},{"name":"WDCSpatialSubdivisionDataStructure","instanceVariables":[],"methods":[{"name":"allElementsIntersectingBox:","linesOfCode":2,"sourceCode":"allElementsIntersectingBox: box\r\t^ self allElementsIntersectingBox: box select: [:el | true] thenCollect: #yourself"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\tself subclassResponsibility "},{"name":"addSpatialSubdivisionDataStructureElement:","linesOfCode":2,"sourceCode":"addSpatialSubdivisionDataStructureElement: anElement\r\tself subclassResponsibility"},{"name":"add:","linesOfCode":2,"sourceCode":"add: anElement\r\t^ self addSpatialSubdivisionDataStructureElement: anElement asSpatialSubdivisionDataStructureElement"},{"name":"addBox:","linesOfCode":2,"sourceCode":"addBox: aBox\r\t^ self add: (WDCSpatialSubdivisionDataStructureBoxElement new value: aBox).\r"},{"name":"addPoints:","linesOfCode":4,"sourceCode":"addPoints: aCollectionOfPoints\r\taCollectionOfPoints do: [ :point |\r\t\tself add: (WDCSpatialSubdivisionDataStructurePointElement new value: point).\r\t]\r"},{"name":"addBoxes:","linesOfCode":4,"sourceCode":"addBoxes: aCollectionOfBoxes\r\taCollectionOfBoxes do: [ :box |\r\t\tself add: (WDCSpatialSubdivisionDataStructureBoxElement new value: box).\r\t]\r"},{"name":"allElementsInsideOfBox:","linesOfCode":2,"sourceCode":"allElementsInsideOfBox: box\r\t^ self allElementsInsideOfBox: box select: [:el | true] thenCollect: #yourself"},{"name":"allElementsInsideOfBox:select:thenCollect:","linesOfCode":9,"sourceCode":"allElementsInsideOfBox: box select: selectBlock thenCollect: aBlock\r\t| result |\r\tresult := OrderedCollection new.\r\tself allElementsInsideOfBox: box do: [ :el |\r\t\t(selectBlock value: el) ifTrue: [ \r\t\t\tresult add: (aBlock value: el)\r\t\t]\r\t].\r\t^ result"},{"name":"allElementsIntersectingBox:select:thenCollect:","linesOfCode":9,"sourceCode":"allElementsIntersectingBox: box select: selectBlock thenCollect: aBlock\r\t| result |\r\tresult := OrderedCollection new.\r\tself allElementsIntersectingBox: box do: [ :el |\r\t\t(selectBlock value: el) ifTrue: [ \r\t\t\tresult add: (aBlock value: el)\r\t\t]\r\t].\r\t^ result"},{"name":"addPoint:","linesOfCode":2,"sourceCode":"addPoint: aPoint\r\t^ self add: (WDCSpatialSubdivisionDataStructurePointElement new value: aPoint).\r"},{"name":"allElementsIntersectingBox:do:","linesOfCode":2,"sourceCode":"allElementsIntersectingBox: box do: aBlock\r\tself subclassResponsibility"},{"name":"allElementsInsideOfBox:thenCollect:","linesOfCode":2,"sourceCode":"allElementsInsideOfBox: box thenCollect: aBlock\r\t^ self allElementsIntersectingBox: box select: [:el | true] thenCollect: aBlock"},{"name":"allElementsIntersectingBox:thenCollect:","linesOfCode":2,"sourceCode":"allElementsIntersectingBox: box thenCollect: aBlock\r\t^ self allElementsIntersectingBox: box select: [:el | true] thenCollect: aBlock"},{"name":"allElementsInsideOfBox:do:","linesOfCode":2,"sourceCode":"allElementsInsideOfBox: box do: aBlock\r\tself subclassResponsibility"}],"meta":{"name":"WDCSpatialSubdivisionDataStructure class","instanceVariables":[],"methods":[{"name":"forAll:","linesOfCode":11,"sourceCode":"forAll: aCollection\r\t| spatialObjects boundingBox |\r\tspatialObjects := aCollection collect: #asSpatialSubdivisionDataStructureElement.\r\tboundingBox := BoxF32 empty.\r\tspatialObjects do: [ :el |\r\t\tboundingBox insertBox: el spatialElementBoundingBox\r\t].\r\r\t^ self new\r\t\tcreateRootNodeWithBoundingBox: boundingBox;\r\t\taddAll: spatialObjects;\r\t\tyourself"}],"meta":null}},{"name":"Set","instanceVariables":[],"methods":[{"name":"grow","linesOfCode":11,"sourceCode":"grow\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: (HashTableSizes atLeast: oldElements size * 2).\r\ttally := 0.\r\toldElements\r\t\tdo:\r\t\t\t[ :each | \r\t\t\teach == nil\r\t\t\t\tifFalse: [ self noCheckAdd: each enclosedElement] ]"},{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ element enclosedElement = anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":17,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\t\"Include anObject as one of the receiver's elements and then value aBlock, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t| index |\r\tindex := self scanFor: anObject.\r\t(array at: index) \r\t\tifNil: [self atNewIndex: index put: anObject asCollectionElement]\r\t\tifNotNil: [ aBlock value ].\r\t^ anObject\r\r\t\"Sets in Pharo 1.2 can't' contain nil, so this implementation is wrong in that version. This is the right one (in Pharo 1.2):\r\r\t| index |\r\tanObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].\r\tindex := self findElementOrNil: anObject.\r\t(array at: index) \r\t\tifNil: [ self atNewIndex: index put: anObject ]\r\t\tifNotNil: [ aBlock value ].\r\t^ anObject\""},{"name":"add:","linesOfCode":7,"sourceCode":"add: newObject\r\t\"Include newObject as one of the receiver's elements, but only if\r\tnot already present. Answer newObject.\"\r\r\t| index |\r\tindex := self scanFor: newObject.\r\t(array at: index) ifNil: [self atNewIndex: index put: newObject asCollectionElement].\r\t^ newObject"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject \r\t^ (array at: (self findElementOrNil: anObject)) ~~ nil"},{"name":"intersection:","linesOfCode":10,"sourceCode":"intersection: aCollection\r\t\"Answer the set theoretic intersection of two collections.\r\tOptimized version for Sets where no intermediate Set is necessary\"\r\r\t\"(#(1 2 3 4) asSet intersection: #(3 4 5) asSet) >>> #(3 4) asSet\"\r\r\t\"(#(1 2 3 4) asSet intersection: #() asSet) >>> Set new\"\r\r\t\"( #() asSet intersection: #(1 2 3 4) asSet) >>> Set new\"\r\r\t| outputSet |\r\toutputSet := self class new.\r\taCollection do: [ :each | (self includes: each) ifTrue: [ outputSet add: each ] ].\r\t^ outputSet"},{"name":"occurrencesOf:","linesOfCode":2,"sourceCode":"occurrencesOf: anObject \r\t^ (self includes: anObject) ifTrue: [1] ifFalse: [0]"},{"name":"difference:","linesOfCode":11,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. Optimized version for Sets where no intermediate Set is necessary\"\r\r\t\"#(a b c d e f) difference:  #(a b z k)\r\t=> #(#f #d #e #c)\r\t\r\t#(a b z k) difference: #(a b c d e f) \r\t=> #(#k #z) \r\t\"\r\r\t| set |\r\tset := self copy.\r\taCollection do: [ :each | set remove: each ifAbsent: [  ] ].\r\t^ set"},{"name":"like:ifAbsent:","linesOfCode":6,"sourceCode":"like: anObject ifAbsent: aBlock\r\t\"Answer an object in the receiver that is equal to anObject,\r\tor evaluate the block if not found. Relies heavily on hash properties\"\r\t| element |\r\telement := array at: (self scanFor: anObject).\r\t^ element ifNil: [ aBlock value ] ifNotNil: [ element enclosedElement ]"},{"name":"collect:","linesOfCode":8,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newSet |\r\tnewSet := self species new: self size.\r\tarray do: [:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]].\r\t^ newSet"},{"name":"rehash","linesOfCode":5,"sourceCode":"rehash\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tself do: [:each | newSelf noCheckAdd: each].\r\tarray := newSelf array"},{"name":"=","linesOfCode":6,"sourceCode":"= aSet\r\tself == aSet ifTrue: [^ true].\t\"stop recursion\"\r\t(aSet isKindOf: Set) ifFalse: [^ false].\r\tself size = aSet size ifFalse: [^ false].\r\tself do: [:each | (aSet includes: each) ifFalse: [^ false]].\r\t^ true"},{"name":"comeFullyUpOnReload:","linesOfCode":5,"sourceCode":"comeFullyUpOnReload: smartRefStream\r\t\"Symbols have new hashes in this image.\"\r\r\t^self \r\t\trehash; \r\t\tyourself\r"},{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^self"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tarray := array copy"},{"name":"stonPostReferenceResolution","linesOfCode":4,"sourceCode":"stonPostReferenceResolution\r\t\"When references were resolved in me, the hash of my elements might have changed.\r\tCheck if I am still healthy and rehash me if not.\"\r\t\r\tself isHealthy ifFalse: [ self rehash ]"},{"name":"isHealthy","linesOfCode":11,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tSet allSubInstances select: [:badSet |\r\t\tbadSet isHealthy not ]\r\t\"\r\tarray withIndexDo: [ :element :index |\r\t\telement ifNotNil: [\r\t\t\t(self scanFor: element enclosedElement) == index\r\t\t\t\tifFalse: [ ^ false ]]].\r\t^ true"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock \r\ttally = 0 ifTrue: [^ self].\r\t1 to: array size do:\r\t\t[:index |\r\t\t| each |\r\t\t(each := array at: index) ifNotNil: [aBlock value: each enclosedElement]]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #Set earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder]]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\r\t| index |\r\tindex := self findElementOrNil: oldObject.\r\t(array at: index) == nil ifTrue: [ ^ aBlock value ].\r\tarray at: index put: nil.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^ oldObject"},{"name":"metaLinkOptions","linesOfCode":5,"sourceCode":"metaLinkOptions\r\t^{\r\t#parseOptions: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":7,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :object |\r\t\t\tarray\r\t\t\t\tat: (self scanForEmptySlotFor: object enclosedElement)\r\t\t\t\tput: object ] ]"},{"name":"max:","linesOfCode":3,"sourceCode":"max: aBlock\r\tself ifEmpty: [ ^ nil ].\r\t^ self inject: 0 into: [ :max :each | (aBlock value: each) max: max ]"},{"name":"withArray:","linesOfCode":4,"sourceCode":"withArray: anArray\r\t\"private -- for use only in copy\"\r\t\"I want to get a conflict\"\r\tarray := anArray"},{"name":"atRandom:","linesOfCode":10,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\r    should be kept by the user in a variable and used every time. Use\r    this instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\t| index |\r\r\tself emptyCheck.\r\tindex := aGenerator nextInteger: array size.\r\t[ (array at: index) isNil ] whileTrue: [ index := index \\\\ array size + 1 ].\r\t^ array at: index."},{"name":"parseOptions:","linesOfCode":19,"sourceCode":"parseOptions: anArray\r\r\t\"parse an array, which is a sequence of options in a form of: \r\t\r\t#( + option1 option2 - option3 ... )\r\t\r\teach time the #+ is seen, the options which follow it will be subject for inclusion\r\tand, correspondingly, if #- seen, then they will be excluded\t.\r\r\tBy default, (if none of #+ or #- specified initially), all options are subject for inclusion.\r\t\"\r\t| include |\r\t\r\tinclude := true.\r\tanArray do: [:option |\r\t\toption == #+ \r\t\t\tifTrue: [ include := true ]\r\t\t\tifFalse: [\r\t\t\t\toption == #- \r\t\t\t\t\tifTrue: [ include := false ]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\tinclude ifTrue: [ self add: option ] \r\t\t\t\t\t\tifFalse: [ self remove: option ifAbsent:[] ]]]\r\t\t]."},{"name":"copyWithout:","linesOfCode":6,"sourceCode":"copyWithout: oldElement \r\t\"Answer a copy of the receiver that does not contain any\r\telements equal to oldElement.\"\r\r\t^ self copy\r\t\tremove: oldElement ifAbsent: [];\r\t\tyourself"},{"name":"noCheckAdd:","linesOfCode":4,"sourceCode":"noCheckAdd: anObject\r\t\"This method should be deprecated\"\r\tarray at: (self findElementOrNil: anObject) put: anObject asCollectionElement.\r\ttally := tally + 1"},{"name":"fixCollisionsFrom:","linesOfCode":10,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one\"\r\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == nil ] whileFalse: [\r\t\t| newIndex |\r\t\t(newIndex := self scanFor: element enclosedElement) = index ifFalse: [\r\t\t\tarray swap: index with: newIndex ] ]"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\t\"Since we have subclasses of Set that behave differently, we cannot use the visitSimpleCollection: for all of them.\"\r\t^ ((self class == Set) or: [ self class == IdentitySet ] ) \r\t\tifTrue: [ aGeneralMapper visitSimpleCollection: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"gtInspectorItemsIn:","linesOfCode":4,"sourceCode":"gtInspectorItemsIn: composite\r\t\"we override this because sets do not work well in morph tree morphs\"\r\r\t^ (super gtInspectorItemsIn: composite)\r\t\tdisplay: [ :set | set asOrderedCollection ]"},{"name":"like:","linesOfCode":5,"sourceCode":"like: anObject\r\t\"Answer an object in the receiver that is equal to anObject,\r\tnil if no such object is found. Relies heavily on hash properties.\r\tNote, use #like:ifAbsent: if you need to match against nil as element\"\r\r\t^ self like: anObject ifAbsent: [ nil ]"},{"name":"fuelAfterMaterialization","linesOfCode":5,"sourceCode":"fuelAfterMaterialization\r\r\t\"Since for Set and IdentitySet we are recreating the collection with #add: (see FLSimpleCollectionCluster) we do not need to rehash\"\r\t^ ((self class == Set) or: [ self class == IdentitySet ] ) \r\t\tifFalse: [ self rehash ] \r\t\tifTrue: [ self ]"}],"meta":{"name":"Set class","instanceVariables":[],"methods":[{"name":"sizeFor:","linesOfCode":3,"sourceCode":"sizeFor: nElements\r\t\"Large enough size to hold nElements with some slop (see fullCheck)\"\r\r\t^ HashTableSizes atLeast: nElements * 4 // 3"},{"name":"newFrom:","linesOfCode":8,"sourceCode":"newFrom: aCollection\r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t\"(Set newFrom: {1. 2. 3}) >>> #( 1 2 3) asSet\"\r\t\"({1. 2. 3} as: Set) >>> #( 1 2 3) asSet\"\r\t\r\t| newCollection |\r\tnewCollection := self new: aCollection size.\r\tnewCollection addAll: aCollection.\r\t^ newCollection\r"},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #Set ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext do: [ :eachValue |\r\t\t\tresult add: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeSetInspector"}],"meta":null}},{"name":"Dictionary","instanceVariables":[],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise store and return the result of evaluating the second block as the\r\tnew value of the key.\"\r\r\t^ self\r\t\tat: key\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [self at: key put: anAbsentBlock value]"},{"name":"at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: key ifAbsentPut: aBlock\r\t\"Return the value at the given key.\r\tIf the key is not included in the receiver store and return the result \r\tof evaluating aBlock as the new value.\"\r\r\t^ self at: key ifAbsent: [self at: key put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":5,"sourceCode":"associationAt: key ifPresent: aBlock\r\t\"Answer the value of evaluating aBlock optionally with the association\r\tfor the given key. If the key is not found, return nil.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNotNil: [ :assoc | aBlock cull: assoc ]"},{"name":"includesKey:","linesOfCode":4,"sourceCode":"includesKey: key \r\t\"Answer whether the receiver has a key equal to the argument, key.\"\r\t\r\t^ (array at: (self scanFor: key)) ~~ nil \r\t\"We could use #notNil here, but ProtoObject doesn't understand it.\""},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\r\tself do: [:each | anObject = each ifTrue: [^true]].\r\t^false"},{"name":"printElementsOn:","linesOfCode":11,"sourceCode":"printElementsOn: aStream \r\taStream nextPut: $(.\r\tself size > 100\r\t\tifTrue: [aStream nextPutAll: 'size '.\r\t\t\tself size printOn: aStream]\r\t\tifFalse: [self keysSortedSafely\r\t\t\t\tdo: [:key | aStream print: key;\r\t\t\t\t\t\t nextPutAll: '->';\t\t\t\t\r\t\t\t\t\t\t print: (self at: key);\r\t\t\t\t\t\t space]].\r\taStream nextPut: $)"},{"name":"hasBindingThatBeginsWith:","linesOfCode":6,"sourceCode":"hasBindingThatBeginsWith: aString\r\t\"Answer true if the receiver has a key that begins with aString, false otherwise\"\r\t\r\tself keysDo:[:each | \r\t\t(each beginsWith: aString)\r\t\t\tifTrue:[^true]].\r\t^false"},{"name":"stonOn:","linesOfCode":10,"sourceCode":"stonOn: stonWriter\r\t\"Instances of STON mapClass will be encoded directly, without a class tag.\r\tOther (sub)classes will be encoded with a class tag and will use a map representation. \"\r\t\r\tself class == STON mapClass\r\t\tifTrue: [ \r\t\t\tstonWriter writeMap: self ]\r\t\tifFalse: [ \r\t\t\tstonWriter \r\t\t\t\twriteObject: self \r\t\t\t\tdo: [ stonWriter encodeMap: self ] ]"},{"name":"at:update:initial:","linesOfCode":11,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\r\tI use findElementOrNil: to avoid looking up the key twice.\"\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(array at: index)\r\t\tifNil: [ self atNewIndex: index put: key -> initBlocktOrValue value]\r\t\tifNotNil: [ :assoc | assoc value: (updateBlock value: assoc value) ]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my values as the argument.  Collect the\r\tresulting values into a collection that is like me. Answer with the new\r\tcollection.\"\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo:[:each |\r\t\tnewCollection at: each key put: (aBlock value: each value).\r\t].\r\t^newCollection"},{"name":"flatCollect:","linesOfCode":6,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's values (by opposition to keys) and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\"If you want to have keys use associations collect: or associations flatCollect: \"\r\t\r\t^ self flatCollect: aBlock as: OrderedCollection"},{"name":"=","linesOfCode":13,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aKeyedCollection\r\taKeyedCollection == self ifFalse: [\r\t\taKeyedCollection keysAndValuesDo: [:key :value |\r\t\t\tself at: key put: value]].\r\t^aKeyedCollection"},{"name":"removeKeyAtValue:","linesOfCode":5,"sourceCode":"removeKeyAtValue: aValue\r\t| key |\r\tkey := self keyAtValue: aValue ifAbsent: [ nil ].\r\tkey ifNotNil: [ self removeKey: key ].\r\t^ key"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\r\tKeyNotFound signalFor: aKey"},{"name":"gtDebuggerSUnitPrint","linesOfCode":9,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ String streamContents: [ :aStream | \r\t\tself keysSortedSafely\r\t\t\t\tdo: [:key | aStream print: key;\r\t\t\t\t\t\t space;\r\t\t\t\t\t\t nextPutAll: '->';\t\r\t\t\t\t\t\t space;\t\t\t\r\t\t\t\t\t\t print: (self at: key);\r\t\t\t\t\t\t cr]]."},{"name":"associationAt:","linesOfCode":3,"sourceCode":"associationAt: key \r\t\"Returns the association for the given key.\"\r\r\t^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\r\t^self valuesDo: aBlock"},{"name":"removeKey:ifAbsent:","linesOfCode":12,"sourceCode":"removeKey: key ifAbsent: aBlock \r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\tassoc == nil ifTrue: [ ^ aBlock value ].\r\tarray at: index put: nil.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^ assoc value"},{"name":"includesIdentity:","linesOfCode":4,"sourceCode":"includesIdentity: anObject\r\t\"Answer whether anObject is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check\"\r\r\tself do: [:each | anObject == each ifTrue: [^ true]].\r\t^ false"},{"name":"keyAtIdentityValue:","linesOfCode":5,"sourceCode":"keyAtIdentityValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r\r\t^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^true"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself at: key ifPresent: [:v | ^ aPresentBlock cull: v].\r\t^ anAbsentBlock value"},{"name":"keyForIdentity:","linesOfCode":4,"sourceCode":"keyForIdentity: anObject\r\t\"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check\"\r\r\tself associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].\r\t^ nil"},{"name":"gtInspectorKeysIn:","linesOfCode":5,"sourceCode":"gtInspectorKeysIn: composite\r\t<gtInspectorPresentationOrder: 1>\r\r\t^ composite fastList\r\t\ttitle: 'Keys';\r\t\tdisplay: [ self keys ]"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r\t\"Answer the association with the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNil: [ aBlock value ]\r\t\tifNotNil: [ :assoc | assoc ]"},{"name":"noCheckAdd:","linesOfCode":4,"sourceCode":"noCheckAdd: anObject\r\t\"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.\"\r\r\tarray at: (self findElementOrNil: anObject key) put: anObject.\r\ttally := tally + 1"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"fixCollisionsFrom:","linesOfCode":10,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == nil ] whileFalse: [\r\t\t| newIndex |\r\t\t(newIndex := self findElementOrNil: element key) = index ifFalse: [\r\t\t\tarray swap: index with: newIndex ] ]"},{"name":"fillFrom:with:","linesOfCode":5,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\taCollection keysAndValuesDo: [ :key :value |\r\t\tself at: key put: (aBlock value: value) ]"},{"name":"unreferencedKeys","linesOfCode":4,"sourceCode":"unreferencedKeys\r\t\"This is private code for the Undeclared handling\"\r\r\t^self keys select: [ :key | \r\t\t\t(self systemNavigation allReferencesTo: (self associationAt: key)) isEmpty ]"},{"name":"at:","linesOfCode":3,"sourceCode":"at: key \r\t\"Answer the value associated with the key.\"\r\r\t^ self at: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"keysAndValuesRemove:","linesOfCode":10,"sourceCode":"keysAndValuesRemove: keyValueBlock\r\t\"Removes all entries for which keyValueBlock returns true.\"\r\t\"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method.\"\r\r\t| removals |\r\tremovals := OrderedCollection new.\r\tself associationsDo:\r\t\t[:assoc | (keyValueBlock value: assoc key value: assoc value)\r\t\t\tifTrue: [removals add: assoc key]].\r \tremovals do:\r\t\t[:aKey | self removeKey: aKey]"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"errorValueNotFound:","linesOfCode":2,"sourceCode":"errorValueNotFound: value\r\r\tValueNotFound signalFor: value"},{"name":"fuelAfterMaterialization","linesOfCode":7,"sourceCode":"fuelAfterMaterialization\r\t| class |\r\t\"Since for Set and IdentitySet we are recreating the collection with #add: we do not need to rehash.\"\r\tclass := self class.\r\t^ (((class == Dictionary) or: [ class == IdentityDictionary ]) ) \r\t\tifFalse: [ self rehash ] \r\t\tifTrue: [ self ]"},{"name":"at:ifAbsent:","linesOfCode":6,"sourceCode":"at: key ifAbsent: aBlock \r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t^((array at: (self findElementOrNil: key)) \r\t\t\tifNil: [aBlock] \r\t\t\tifNotNil: [:assoc | assoc]) value."},{"name":"keyAtValue:ifAbsent:","linesOfCode":7,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\t: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast.\"\r \r\tself associationsDo: \r\t\t[:association | value = association value ifTrue: [^association key]].\r\t^exceptionBlock value"},{"name":"removeKey:","linesOfCode":4,"sourceCode":"removeKey: key \r\t\"Remove key from the receiver.\r\tIf key is not in the receiver, notify an error.\"\r\r\t^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"associations","linesOfCode":5,"sourceCode":"associations\r\t\"Answer a collection containing the receiver's associations.\"\r\t\"Suggested by l. Uzonyi\"\r\t\r\t^Array new: self size streamContents: [ :stream |\r\t\tself associationsDo: [ :each | stream nextPut: each ] ]"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| element start finish |\r\tfinish := array size.\r\tstart := (anObject hash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key = anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key = anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"valuesDo:","linesOfCode":10,"sourceCode":"valuesDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's values.  Implemented with == checks\r\tmerely for the sake of maximum efficiency\"\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do:\r\t\t[ :eachIndex | \r\t\t\t| eachAssociation |\r\t\t\teachAssociation := array at: eachIndex.\r\t\t\tnil == eachAssociation ifFalse: [ aBlock value: eachAssociation value ]\r\t\t]"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ DictionaryValueHolder value: self"},{"name":"add:","linesOfCode":8,"sourceCode":"add: anAssociation\r\t| index element |\r\tindex := self findElementOrNil: anAssociation key.\r\telement := array at: index.\r\telement\r\t\tifNil: [ self atNewIndex: index put: anAssociation ]\r\t\tifNotNil: [ element value: anAssociation value ].\r\t^ anAssociation"},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":7,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).\"\r\r\ttally = 0 ifTrue: [^ self].\r\tarray do:\r\t\t[:each |\r\t\teach ifNotNil: [aBlock value: each]]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":11,"sourceCode":"declare: key from: aDictionary \r\t\"Add key to the receiver. If key already exists, do nothing. If aDictionary \r\tincludes key, then remove it from aDictionary and use its association as \r\tthe element of the receiver.\"\r\r\t(self includesKey: key) ifTrue: [^ self].\r\t(aDictionary includesKey: key)\r\t\tifTrue: \r\t\t\t[self add: (aDictionary associationAt: key).\r\t\t\taDictionary removeKey: key]\r\t\tifFalse: \r\t\t\t[self add: key -> nil]"},{"name":"difference:","linesOfCode":12,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. This is a specialized version for Dictionaries keeping the keys of the objects. At a slightly higher price of an additional Set to track duplicates.\"\r\r\t| other result duplicates |\r\t\r\tother := aCollection asSet.\r\tduplicates := Set new.\r\tresult := self class new: self size.\r\t\r\tself keysAndValuesDo: [ :key :value|\r\t\t((other includes: value) not and: [ (duplicates includes: value) not ])\r\t\t\tifTrue: [ \r\t\t\t\tduplicates add: value.\r\t\t\t\tresult at: key put: value]].\r\t\r\t^ result"},{"name":"keyAtValue:","linesOfCode":4,"sourceCode":"keyAtValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, signal an error.\"\r\r\t^self keyAtValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ self errorKeyNotFound: key ]."},{"name":"keysAndValuesDo:","linesOfCode":3,"sourceCode":"keysAndValuesDo: aBlock\r\t^self associationsDo:[:assoc|\r\t\taBlock value: assoc key value: assoc value]."},{"name":"rehash","linesOfCode":6,"sourceCode":"rehash\r\t\"Smalltalk rehash.\"\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tself associationsDo: [:each | newSelf noCheckAdd: each].\r\tarray := newSelf array"},{"name":"remove:","linesOfCode":2,"sourceCode":"remove: anObject\r\r\tself shouldNotImplement"},{"name":"postCopy","linesOfCode":5,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\roriginal and the copy\"\r\r\tarray := array collect: [ :association |\r\t\tassociation ifNotNil: [ association copy ] ]"},{"name":"includesAssociation:","linesOfCode":4,"sourceCode":"includesAssociation: anAssociation\r  ^ (self   \r      associationAt: anAssociation key\r      ifAbsent: [ ^ false ]) value = anAssociation value\r"},{"name":"valueAtNewKey:put:atIndex:declareFrom:","linesOfCode":11,"sourceCode":"valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary \r\t\"Support for coordinating class variable and global declarations\r\twith variables that have been put in Undeclared so as to\r\tredirect all references to the undeclared variable.\"\r\r\t(aDictionary includesKey: aKey)\r\t\tifTrue: \r\t\t\t[self atNewIndex: index \r\t\t\t\tput: ((aDictionary associationAt: aKey) value: anObject).\r\t\t\taDictionary removeKey: aKey]\r\t\tifFalse: \r\t\t\t[self atNewIndex: index put: (Association key: aKey value: anObject)]"},{"name":"isHealthy","linesOfCode":14,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tDictionary allInstances select: [:dict |\r\t\tdict isHealthy not ]\r\tDictionary allSubInstances select: [:dict |\r\t\tdict isHealthy not ]\r\t\"\r\tarray withIndexDo: [:elem :i |\r\t\telem ifNotNil: [\r\t\t\t(self scanFor: elem key) == i ifFalse: [ ^ false ]\r\t\t\t]\r\t].\r\t^ true"},{"name":"stonPostReferenceResolution","linesOfCode":4,"sourceCode":"stonPostReferenceResolution\r\t\"When references were resolved in me, the hash of my keys might have changed.\r\tCheck if I am still healthy and rehash me if not.\"\r\t\r\tself isHealthy ifFalse: [ self rehash ]"},{"name":"spotterForKeysFor:","linesOfCode":7,"sourceCode":"spotterForKeysFor: aStep\r\t<spotterOrder: 15>\r\taStep listProcessor\r\t\t\ttitle: 'Keys';\r\t\t\tallCandidates: [ self keys ];\r\t\t\tcandidatesLimit: 5;\r\t\t\tfilter: GTFilterSubstring"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [self errorKeyNotFound: secondKey]"},{"name":"inspectionItems:","linesOfCode":11,"sourceCode":"inspectionItems: aBuilder\r\t<inspectorPresentationOrder: 0 title: 'Items'> \r\t\r\t^ aBuilder newTable \r\t\taddColumn: (SpStringTableColumn \r\t\t\ttitle: 'Key'\r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each key ]);\r\t\taddColumn: (SpStringTableColumn \r\t\t\ttitle: 'Value' \r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each value ]);\r\t\titems: self associations;\r\t\tyourself"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: exceptionBlock\r\r\tself shouldNotImplement"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":7,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tarray\r\t\t\t\tat: (self scanForEmptySlotFor: association key)\r\t\t\t\tput: association ] ]"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":7,"sourceCode":"keyAtIdentityValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^association key]].\r\t^exceptionBlock value"},{"name":"keysDo:","linesOfCode":3,"sourceCode":"keysDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's keys.\"\r\r\tself associationsDo: [:association | aBlock value: association key]"},{"name":"keys","linesOfCode":3,"sourceCode":"keys\r\t\"Answer an Array containing the receiver's keys.\"\r\t\r\t^Array new: self size streamContents: [:s| self keysDo: [:key| s nextPut: key]]"},{"name":"values","linesOfCode":5,"sourceCode":"values\r\t\"Answer a Collection containing the receiver's values.\"\r\t^Array \r\t\tnew: self size \r\t\tstreamContents: [ :out | self valuesDo: [:value | out nextPut: value]]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue"},{"name":"keysSortedSafely","linesOfCode":17,"sourceCode":"keysSortedSafely\r\t\"Answer an Array containing the receiver's keys.\"\r \t\"Suggested by l. Uzonyi\"\r\t\r \t| sortedKeys |\r \tsortedKeys := Array \r\t\t\t\t\t\tnew: self size \r\t\t\t\t\t\tstreamContents: [ :stream |\r \t\t\t\t\t\t\t\tself keysDo: [ :each | stream nextPut: each ] ].\r \tsortedKeys sort: [ :x :y |\r \t\t\"Should really be use <obj, string, num> compareSafely...\"\r \t\t((x isString and: [ y isString ])\r \t\t\tor: [ x isNumber and: [ y isNumber ] ])\r \t\t\tifTrue: [ x < y ]\r \t\t\tifFalse: [ x class == y class\r \t\t\t\tifTrue: [ x printString < y printString ]\r \t\t\t\tifFalse: [ x class name < y class name ] ] ].\r \t^sortedKeys"},{"name":"fuelAccept:","linesOfCode":7,"sourceCode":"fuelAccept: aGeneralMapper\r\t| class |\r\t\"Since we have subclasses of Dictionary that behave differently, we cannot use the visitDictionary: for all of them.\t We could also use MethodDictionary for this case, but its materialization is much slower with this cluster than with the default action.\"\r\tclass := self class.\r\t^ (((class == Dictionary) or: [class == IdentityDictionary ])) \r\t\tifTrue: [ aGeneralMapper visitDictionary: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeMap: self"},{"name":"storeOn:","linesOfCode":15,"sourceCode":"storeOn: aStream\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself associationsDo: \r\t\t\t[:each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [noneYet := false]\r\t\t\t\tifFalse: [aStream nextPut: $;].\r\t\t\taStream nextPutAll: ' add: '.\r\t\t\taStream store: each].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"associationsSelect:","linesOfCode":10,"sourceCode":"associationsSelect: aBlock \r\t\"Evaluate aBlock with each of my associations as the argument. Collect\r\tinto a new dictionary, only those associations for which aBlock evaluates\r\tto true.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:ifPresent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t^(array at: (self findElementOrNil: key))\r\t\tifNotNil: [:assoc | aBlock cull: assoc value]"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the association for the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself associationAt: key ifPresent: [:assoc | ^ aPresentBlock cull: assoc].\r\t^ anAbsentBlock value"},{"name":"removeUnreferencedKeys","linesOfCode":4,"sourceCode":"removeUnreferencedKeys\r\t\"This is private code for the Undeclared handling, not a general API.\" \r\t\"Undeclared removeUnreferencedKeys\"\r\r\t^ self unreferencedKeys do: [ :key | self removeKey: key ]"},{"name":"select:","linesOfCode":8,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of my values as the argument. Collect into a new dictionary, only those associations for which aBlock evaluates to true.\"\r\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself associationsDo: [ :each |\r\t\t(aBlock value: each value) ifTrue: [\r\t\t\tnewCollection add: each copy ] ].\r\t^newCollection"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: key put: anObject \r\t\"Set the value at key to be anObject.  If key is not found, create a\r\tnew entry for key and set is value to anObject. Answer anObject.\"\r\r\t| index assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\tassoc\r\t\tifNil: [self atNewIndex: index put: (Association key: key value: anObject)]\r\t\tifNotNil: [assoc value: anObject].\r\t^ anObject"},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^self associationAt: varName ifAbsent:[nil]"}],"meta":{"name":"Dictionary class","instanceVariables":[],"methods":[{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\"(Dictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (Dictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: anArray\r\t\"Answer an instance of me associating (anArray at: i) to (anArray at: i+1)\r\t for each odd i.  anArray must have an even number of entries.\"\r\r\t\"Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}.\"\r\r\t| newDictionary |\r\tnewDictionary := self new: anArray size / 2.\r\t1 to: anArray size - 1 by: 2 do: [ :i | newDictionary at: (anArray at: i) put: (anArray at: i + 1) ].\r\t^ newDictionary"},{"name":"newFrom:","linesOfCode":15,"sourceCode":"newFrom: aDict \r\t\"Answer an instance of me containing the same associations as aDict.\r\t Error if any key appears twice.\"\r\t| newDictionary |\r\tnewDictionary := self new: aDict size.\r\taDict associationsDo:\r\t\t[:x |\r\t\t(newDictionary includesKey: x key)\r\t\t\tifTrue: [self error: 'Duplicate key: ', x key printString]\r\t\t\tifFalse: [newDictionary add: x]].\r\t^ newDictionary\r\r\"\tNewDictionary newFrom: {1->#a. 2->#b. 3->#c}\r\t{1->#a. 2->#b. 3->#c} as: NewDictionary\r\tNewDictionary newFrom: {1->#a. 2->#b. 1->#c}\r\t{1->#a. 2->#b. 1->#c} as: NewDictionary\r\""},{"name":"newFromAssociations:","linesOfCode":6,"sourceCode":"newFromAssociations: anAssocCollection\r\t\"return a dictionary with the Associations in anAssocCollection.\r\tIf the same key appears twice in anAssocCollection, the last one enumerated will win\"\r\t\r\t^ anAssocCollection \r\t\tinject: Dictionary new \r\t\tinto: [ :dict :assoc | dict add: assoc. dict ]"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeDictionaryInspector"},{"name":"fromSton:","linesOfCode":8,"sourceCode":"fromSton: stonReader\r\t\"Instances of STON mapClass will be read directly and won't arrive here.\r\tOther (sub)classes will use this method.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"}],"meta":null}},{"name":"ArrayedCollection","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self basicSize * self bytesPerBasicElement\r"},{"name":"fillFrom:with:","linesOfCode":7,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\t| index |\r\tindex := 0.\r\taCollection do: [ :each |\r\t\tself at: (index := index + 1) put: (aBlock value: each) ]"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tself shouldNotImplement"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t<primitive: 62>\r\t^ self basicSize"},{"name":"bytesPerBasicElement","linesOfCode":6,"sourceCode":"bytesPerBasicElement\r\t\"Answer the number of bytes that each of my basic elements requires.\r\tIn other words:\r\t\tself basicSize * self bytesPerBasicElement\r\tshould equal the space required on disk by my variable sized representation.\"\r\t^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ]"},{"name":"storeOn:","linesOfCode":9,"sourceCode":"storeOn: aStream\r\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new: '.\r\taStream store: self size.\r\taStream nextPut: $).\r\t(self storeElementsFrom: 1 to: self size on: aStream)\r\t\tifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"storeElementsFrom:to:on:","linesOfCode":17,"sourceCode":"storeElementsFrom: firstIndex to: lastIndex on: aStream\r\r\t| noneYet defaultElement arrayElement |\r\tnoneYet := true.\r\tdefaultElement := self defaultElement.\r\tfirstIndex to: lastIndex do: \r\t\t[:index | \r\t\tarrayElement := self at: index.\r\t\tarrayElement = defaultElement\r\t\t\tifFalse: \r\t\t\t\t[noneYet\r\t\t\t\t\tifTrue: [noneYet := false]\r\t\t\t\t\tifFalse: [aStream nextPut: $;].\r\t\t\t\taStream nextPutAll: ' at: '.\r\t\t\t\taStream store: index.\r\t\t\t\taStream nextPutAll: ' put: '.\r\t\t\t\taStream store: arrayElement]].\r\t^noneYet"},{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\tself shouldNotImplement"},{"name":"defaultElement","linesOfCode":2,"sourceCode":"defaultElement\r\r\t^nil"},{"name":"restoreEndianness","linesOfCode":10,"sourceCode":"restoreEndianness\r \t\"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Reverse the byte order if the current machine is Little Endian.\r \tWe only intend this for non-pointer arrays.  Do nothing if I contain pointers.\"\r \r \tself class isPointers | self class isWords not ifTrue: [^self].\r \tEndianDetector isLittleEndian \r \t\tifTrue: \r \t\t\t[Bitmap \r \t\t\t\tswapBytesIn: self\r \t\t\t\tfrom: 1\r \t\t\t\tto: self basicSize]"},{"name":"swapHalves","linesOfCode":12,"sourceCode":"swapHalves\r \t\t\"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.\r \tThis method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc.\"\r \r \t| hack blt |\r \t\"The implementation is a hack, but fast for large ranges\"\r \thack := Form new hackBits: self.\r \tblt := (BitBlt toForm: hack) sourceForm: hack.\r \tblt combinationRule: Form reverse.  \"XOR\"\r \tblt sourceY: 0; destY: 0; height: self size; width: 2.\r \tblt sourceX: 0; destX: 2; copyBits.  \"Exchange bytes 0&1 with 2&3\"\r \tblt sourceX: 2; destX: 0; copyBits.\r \tblt sourceX: 0; destX: 2; copyBits.\r"},{"name":"writeOn:","linesOfCode":5,"sourceCode":"writeOn: aStream \r\t\"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds. We only intend this for non-pointer arrays.  Do nothing if I contain pointers.\"\r\t(self class isPointers or: [ self class isWords not ]) ifTrue: [^ self ].\r\taStream nextInt32Put: self basicSize.\r\taStream nextWordsPutAll: self."}],"meta":{"name":"ArrayedCollection class","instanceVariables":[],"methods":[{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #ArrayedCollection"},{"name":"new:withAll:","linesOfCode":4,"sourceCode":"new: size withAll: value \r\t\"Answer an instance of me, with number of elements equal to size, each \r\tof which refers to the argument, value.\"\r\r\t^(self new: size) atAllPut: value"},{"name":"with:with:with:with:with:with:","linesOfCode":11,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t\"Answer a new instance of me, containing only the 6 arguments as elements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 6.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\tnewCollection at: 5 put: fifthObject.\r\tnewCollection at: 6 put: sixthObject.\r\t^ newCollection"},{"name":"with:with:with:with:with:","linesOfCode":11,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t\"Answer a new instance of me, containing only the five arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 5.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\tnewCollection at: 5 put: fifthObject.\r\t^newCollection"},{"name":"with:with:with:with:","linesOfCode":10,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t\"Answer a new instance of me, containing only the three arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 4.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\t^newCollection"},{"name":"with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t\"Answer a new instance of me, containing only the three arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 3.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\t^newCollection"},{"name":"with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject \r\t\"Answer a new instance of me, containing firstObject and secondObject.\"\r\r\t| newCollection |\r\tnewCollection := self new: 2.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\t^newCollection"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Answer a new instance of me, with size = 0.\"\r\r\t^self new: 0"},{"name":"with:","linesOfCode":6,"sourceCode":"with: anObject \r\t\"Answer a new instance of me, containing only anObject.\"\r\r\t| newCollection |\r\tnewCollection := self new: 1.\r\tnewCollection at: 1 put: anObject.\r\t^newCollection"},{"name":"withAll:","linesOfCode":3,"sourceCode":"withAll: aCollection\r\t\"Create a new collection containing all the elements from aCollection.\"\r\r\t^ (self new: aCollection size) replaceFrom: 1 to: aCollection size with: aCollection"},{"name":"with:withAll:","linesOfCode":10,"sourceCode":"with: anObject withAll: aCollection\r\r\t| newArray |\r\tnewArray := self new: aCollection size + 1.\r\tnewArray at: 1 put: anObject.\r\tnewArray\r\t\treplaceFrom: 2\r\t\tto: newArray size\r\t\twith: aCollection.\r\t^newArray\r\t\r\"Array with: 1 withAll: #(2 3 4)\""},{"name":"newFrom:","linesOfCode":11,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t| newArray |\r\tnewArray := self new: aCollection size.\r\t1 to: aCollection size do: [:i | newArray at: i put: (aCollection at: i)].\r\t^ newArray\r\r\"\tArray newFrom: {1. 2. 3}\r\t{1. 2. 3} as: Array\r\t{1. 2. 3} as: ByteArray\r\t{$c. $h. $r} as: String\r\t{$c. $h. $r} as: Text\r\""}],"meta":null}},{"name":"Interval","instanceVariables":[{"name":"start"},{"name":"stop"},{"name":"step"}],"methods":[{"name":"asOpenInterval","linesOfCode":7,"sourceCode":"asOpenInterval\r\t\"Return a new interval representing the open version of the receiver.\r\tIn other words, the new inteval does not contain the upper and lower boundaries of the receiver\r\t\"\r\t\r\t\"(1 to: 10) asOpenInterval >>> (2 to: 9)\"\r\t\"(10 to: 1 by: -1) asOpenInterval >>> (9 to: 2)\"\r\r\t^ start + step to: stop - step"},{"name":"isInterval","linesOfCode":2,"sourceCode":"isInterval\r\r\t^ true"},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ self class == Interval"},{"name":"asParser","linesOfCode":10,"sourceCode":"asParser    \r\t\"Create a range of characters between start and stop.\"\r\r    self assert:start isCharacter.\r    self assert:stop isCharacter.\r    self assert:step == 1.\r    ^ PPPredicateObjectParser between: start and: stop\r\r    \"\r\t\t($a to: $f) asParser parse: 'a'\r\t\t($a to: $f) asParser parse: 'g'\r    \""},{"name":"anyOne","linesOfCode":4,"sourceCode":"anyOne\r\t\"This message will fail for an empty Interval, super would not.\r\t(2 to: 1) anyOne should fail because empty.\"\r\r\t^self at: 1"},{"name":"add:","linesOfCode":3,"sourceCode":"add: newObject \r\t\"Adding to an Interval is not allowed.\"\r\r\tself shouldNotImplement"},{"name":"setFrom:to:by:","linesOfCode":5,"sourceCode":"setFrom: startInteger to: stopInteger by: stepInteger\r\r\tstart := startInteger.\r\tstop := stopInteger.\r\tstep := stepInteger.\r\tstep isZero ifTrue: [ ^ DomainError signal: 'Zero size steps not allowed' ]"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonReader parseNamedInstVarsFor: self"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Overwritten to get back the standard object behavior\"\r\r\tstonWriter writeObject: self"},{"name":"remove:","linesOfCode":3,"sourceCode":"remove: newObject \r\t\"Removing from an Interval is not allowed.\"\r\r\tself error: 'elements cannot be removed from an Interval'"},{"name":"collect:","linesOfCode":9,"sourceCode":"collect: aBlock\r\t| nextValue result |\r\tresult := self species new: self size.\r\tnextValue := start.\r\t1 to: result size do:\r\t\t[:i |\r\t\tresult at: i put: (aBlock value: nextValue).\r\t\tnextValue := nextValue + step].\r\t^ result"},{"name":"last","linesOfCode":3,"sourceCode":"last \r\t\"Refer to the comment in SequenceableCollection|last.\"\r\r\t^stop - (stop - start \\\\ step)"},{"name":"=","linesOfCode":8,"sourceCode":"= anObject\r\r\t^ self == anObject\r\t\tifTrue: [true]\r\t\tifFalse: [anObject isInterval\r\t\t\tifTrue: [start = anObject first\r\t\t\t\tand: [step = anObject increment\r\t\t\t\t\tand: [self last = anObject last]]]\r\t\t\tifFalse: [super = anObject]]"},{"name":"-","linesOfCode":2,"sourceCode":"- number\r\r\t^ start - number to: stop - number by: step"},{"name":"do:","linesOfCode":16,"sourceCode":"do: aBlock\r\t\"Evaluate aBlock for each value of the interval.\r\tImplementation note: instead of repeatedly incrementing the value\r\t\taValue := aValue + step.\r\tuntil stop is reached,\r\tWe prefer to recompute value from start\r\t\taValue := start + (index * step).\r\tThis is better for floating points accuracy, while not degrading Integer and Fraction speed too much.\r\tMoreover, this is consistent with methods #at: and #size\"\r\r\t| aValue index size |\r\tindex := 0.\r\tsize := self size.\r\t[index < size]\r\t\twhileTrue: [aValue := start + (index * step).\r\t\t\tindex := index + 1.\r\t\t\taBlock value: aValue]"},{"name":"sorted:","linesOfCode":3,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison. We convert the interval to an array because intervals can't be changed.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t\"Hash is reimplemented because = is implemented.\"\r\r\t^(((start hash bitShift: 2)\r\t\tbitOr: stop hash)\r\t\tbitShift: 1)\r\t\tbitOr: self size"},{"name":"rangeIncludes:","linesOfCode":8,"sourceCode":"rangeIncludes: aNumber\r\t\"Return true if aNumber lies anywhere between the interval bounds.\r\tThis is a fast O(1) bounds check.\r\t\r\tBeware: because #rangeIncludes: only considers the sign of the step, not its magnitude, it also returns true for values that are not actual elements of the interval.\r\tFor precise element inclusion with arbitrary step, use #includes:.\"\r\r\t^ step >= 0\r\t\tifTrue: [ aNumber between: start and: stop ]\r\t\tifFalse: [ aNumber between: stop and: start ]"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^Array"},{"name":"asGPUArrayOfType:","linesOfCode":2,"sourceCode":"asGPUArrayOfType: type\r\t^ SGPUCompilationEnvironment current constructArrayOfType: type withInterval: self"},{"name":"sum","linesOfCode":5,"sourceCode":"sum\r\t\"Optimized version. Use the sum(n * i - k, i=a..b) = -1/2 * (a - b - 1) * (n * (a + b) - 2 * k) equation with a = 1, n = step, b = self size and k = step - start.\"\r\r\t| b |\r\tb := self size.\r\t^b * ((b - 1) * step + (start * 2)) / 2"},{"name":"size","linesOfCode":9,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ step < 0\r\t\tifTrue: [ start < stop\r\t\t\t\tifTrue: [ 0 ]\r\t\t\t\tifFalse: [ (stop - start) // step + 1 ] ]\r\t\tifFalse: [ stop < start\r\t\t\t\tifTrue: [ 0 ]\r\t\t\t\tifFalse: [ (stop - start) // step + 1 ] ]"},{"name":"printOn:","linesOfCode":7,"sourceCode":"printOn: aStream\r\taStream nextPut: $(;\r\t print: start;\r\t nextPutAll: ' to: ';\r\t print: stop.\r\tstep ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].\r\taStream nextPut: $)"},{"name":"+","linesOfCode":2,"sourceCode":"+ number\r\r\t^ start + number to: stop + number by: step"},{"name":"reverseDo:","linesOfCode":10,"sourceCode":"reverseDo: aBlock \r\t\"Evaluate aBlock for each element of my interval, in reverse order.\r\tImplementation notes: see do: for an explanation on loop detail\"\r\r\t| aValue index |\r\tindex := self size.\r\t[index > 0]\r\t\twhileTrue: [\r\t\t\tindex := index - 1.\r\t\t\taValue := start + (index * step).\r\t\t\taBlock value: aValue]"},{"name":"shuffled","linesOfCode":3,"sourceCode":"shuffled\r\t\"Return an array that contains my elements shuffled in a random order\"\r\t^ self asArray shuffle"},{"name":"first","linesOfCode":3,"sourceCode":"first \r\t\"Refer to the comment in SequenceableCollection|first.\"\r\r\t^start"},{"name":"permutationsDo:","linesOfCode":5,"sourceCode":"permutationsDo: aBlock\r\t\"Repeatly value aBlock with a single copy of the receiver. Reorder the copy\r\tso that aBlock is presented all (self size factorial) possible permutations.\"\r\t\"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]\"\r\r\tself asArray permutationsDo: aBlock\r"},{"name":"sort:","linesOfCode":3,"sourceCode":"sort: aBlock\r\t\"What sorting an Interval means is not clear.\"\r\r\tself shouldNotImplement."},{"name":"at:","linesOfCode":5,"sourceCode":"at: anInteger\r\t\"Answer the anInteger'th element.\"\r\r\t(anInteger between: 1 and: self size)\r\t\tifTrue: [ ^ start + (step * (anInteger - 1)) ]\r\t\tifFalse: [ self errorSubscriptBounds: anInteger ]"},{"name":"storeOn:","linesOfCode":7,"sourceCode":"storeOn: aStream \r\taStream nextPut: $(;\r\t \tstore: start;\r\t \tnextPutAll: ' to: ';\r\t \tstore: stop.\r\tstep ~= 1 ifTrue: [aStream nextPutAll: ' by: '; store: step].\r\taStream nextPut: $)"},{"name":"increment","linesOfCode":3,"sourceCode":"increment\r\t\"Answer the receiver's interval increment.\"\r\r\t^step"},{"name":"extent","linesOfCode":4,"sourceCode":"extent \r\t\"Answer the max - min of the receiver interval.\"\r\t\"(10 to: 50) extent\"\r\r\t^stop - start"},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t^ self increment >= 0\r\t\tifTrue: [ self copy ]\r\t\tifFalse: [ self last to: self first by: self increment negated ]"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: anInteger put: anObject \r\t\"Storing into an Interval is not allowed.\"\r\r\tself error: 'you can not store into an interval'"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":18,"sourceCode":"indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock\r\t\"startIndex is an positive integer, the collection index where the search is started.\"\r\t\"during the computation of val , floats are only used when the receiver contains floats\"\r\r\t| index val |\r\t(anElement isNumber and:[self rangeIncludes: anElement])\r\t\tifFalse: [^ exceptionBlock value].\r\tval := anElement - self first / self increment.\r\tval isFloat\r\t\tifTrue: [(val - val rounded) abs * 100000000 < 1\r\t\t\t\t\tifTrue: [index := val rounded + 1]\r\t\t\t\t\tifFalse: [^ exceptionBlock value]]\r\t\tifFalse: [val isInteger\r\t\t\t\t\tifTrue: [index := val + 1]\r\t\t\t\t\tifFalse: [^ exceptionBlock value]].\r\t\"finally, the value of startIndex comes into play:\"\r\t^ (index between: startIndex and: self size)\r\t\tifTrue: [index]\r\t\tifFalse: [exceptionBlock value]"}],"meta":{"name":"Interval class","instanceVariables":[],"methods":[{"name":"from:to:","linesOfCode":7,"sourceCode":"from: startInteger to: stopInteger \r\t\"Answer an instance of me, starting at startNumber, ending at \r\tstopNumber, and with an interval increment of 1.\"\r\r\t^self new\r\t\tsetFrom: startInteger\r\t\tto: stopInteger\r\t\tby: 1"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"new","linesOfCode":10,"sourceCode":"new\r\t\"Primitive. Create and answer with a new instance of the receiver\r\t(a class) with no indexable fields. Fail if the class is indexable. Override\r\tSequenceableCollection new. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 70>\r\tself isVariable ifTrue: [ ^ self new: 0 ].\r\t\"space must be low\"\r\tOutOfMemory signal.\r\t^ self new  \"retry if user proceeds\"\r"},{"name":"newFrom:","linesOfCode":19,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r    | newInterval n |\r\r    (n := aCollection size) <= 1 ifTrue: [\r\t\tn = 0 ifTrue: [^self from: 1 to: 0].\r\t\t^self from: aCollection first to: aCollection last].\r    \tnewInterval := self from: aCollection first to: aCollection last\r\tby: (aCollection last - aCollection first) // (n - 1).\r\taCollection ~= newInterval\r\t\tifTrue: [\r\t\t\t\"Give a second chance, because progression might be arithmetic, but = answer false\"\r\t\t\t(newInterval hasEqualElements: aCollection) ifFalse: [\r\t\t\t\tself error: 'The argument is not an arithmetic progression']].\r\t^newInterval\r\r\"\tInterval newFrom: {1. 2. 3}\r\t{33. 5. -23} as: Interval\r\t{33. 5. -22} as: Interval    (an error)\r\t(-4 to: -12 by: -1) as: Interval\r\t#(2 4 6) asByteArray as: Interval.\r\""},{"name":"from:to:by:","linesOfCode":7,"sourceCode":"from: startInteger to: stopInteger by: stepInteger \r\t\"Answer an instance of me, starting at startNumber, ending at \r\tstopNumber, and with an interval increment of stepNumber.\"\r\r\t^self new\r\t\tsetFrom: startInteger\r\t\tto: stopInteger\r\t\tby: stepInteger"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\t^ self new\r\t\tfromSton: stonReader;\r\t\tyourself"}],"meta":null}},{"name":"LinkedList","instanceVariables":[{"name":"firstLink"},{"name":"lastLink"}],"methods":[{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Reimplemennt #select: for speedup on linked lists. \r\tThe super implemention accesses the linkes by index, thus causing an O(n^2)\"\r\t\r\t| newCollection |\r\tnewCollection := self class new.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"copyWith:","linesOfCode":2,"sourceCode":"copyWith: newElement\r\t^self copy add: newElement; yourself"},{"name":"isEmpty","linesOfCode":2,"sourceCode":"isEmpty\r\r\t^firstLink isNil"},{"name":"linkAt:ifAbsent:","linesOfCode":6,"sourceCode":"linkAt: index ifAbsent: errorBlock\r\r\t| i |\r\ti := 0.\r\tself linksDo: [:link |\r\t\t(i := i + 1) = index ifTrue: [^ link]].\r\t^ errorBlock value"},{"name":"linksDo:","linesOfCode":7,"sourceCode":"linksDo: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil ] whileFalse:\r\t\t[\r\t\taBlock value: aLink.\r\t\taLink := aLink nextLink]"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: anObject\r\r\t^self at: index putLink: (self linkOf: anObject ifAbsent: [anObject asLink])"},{"name":"reject:thenCollect:","linesOfCode":9,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Optimized version of SequenceableCollection>>#reject:thenCollect:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ newCollection add: (collectBlock value: each) ] ].\r\t^ newCollection"},{"name":"swap:with:","linesOfCode":25,"sourceCode":"swap: ix1 with: ix2\r\t\"Reimplemented, super would create an infinite loop\"\r\t| minIx maxIx link1Prev link2Prev link1 link2 link1Next link2Next newLink2Next |\r\t((self validIndex: ix1) and: [self validIndex: ix2])\tifFalse: [^ self errorOutOfBounds].\r\t\r\t\"Get edge case out of the way\"\r\tix1 = ix2 ifTrue: [^ self ].\r\t\r\t\"Sort indexes to make boundary-checks easier\" \r\tminIx := ix1 min: ix2.\r\tmaxIx := ix2 max: ix1.\r\t\r\tlink1Prev := (minIx = 1) ifFalse: [self linkAt: minIx -1].\r\tlink1 := link1Prev ifNotNil: [ link1Prev nextLink]\r\t\t\t\tifNil: [self linkAt: minIx].\r\tlink1Next := link1 nextLink.\r\tlink2Prev := self linkAt: maxIx -1.\r\tlink2 := link2Prev nextLink.\r\tlink2Next := link2 nextLink.\r\t\r\t\"Link at start being swapped\"\r\tlink1 = firstLink ifTrue: [firstLink := link2.] ifFalse: [link1Prev nextLink: link2].\r\t\"Link at end being swapped\"\r\tlink2 = lastLink ifTrue: [lastLink := link1] ifFalse: [].\r\t\"Links  being swapped adjacent\"\r\tnewLink2Next := (link1 nextLink = link2) ifTrue: [link1] ifFalse: [link2Prev nextLink: link1.\r\t\tlink1Next].\r\tlink1 nextLink: link2Next.\r\tlink2 nextLink: newLink2Next.\r\t"},{"name":"add:","linesOfCode":3,"sourceCode":"add: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\r\t^self addLast: aLinkOrObject"},{"name":"removeLink:ifAbsent:","linesOfCode":18,"sourceCode":"removeLink: aLink ifAbsent: aBlock  \r\t\"Remove aLink from the receiver. If it is not there, answer the result of\r\tevaluating aBlock.\"\r\r\t| tempLink |\r\taLink == firstLink\r\t\tifTrue: [firstLink := aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := nil]]\r\t\tifFalse: [tempLink := firstLink.\r\t\t\t\t[tempLink == nil ifTrue: [^aBlock value].\r\t\t\t\t tempLink nextLink == aLink]\r\t\t\t\t\twhileFalse: [tempLink := tempLink nextLink].\r\t\t\t\ttempLink nextLink: aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := tempLink]].\r\t\"Not nilling the link enables us to delete while iterating\"\r\t\"aLink nextLink: nil.\"\r\t^aLink"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":13,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\t\t\r\t|currentLink index|\t\t\r\tcurrentLink := self linkAt: start ifAbsent: [nil].\r\tindex := start.\r\t[currentLink isNil ] \r\t\twhileFalse: [currentLink value = anElement value ifTrue: [^index].\r\t\t\t\t\tcurrentLink := currentLink nextLink.\r\t\t\t\t\tindex := index +1].\r\t^exceptionBlock value"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| aLink newCollection |\r\tnewCollection := self class new.\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[newCollection add: (aBlock value: aLink value).\r\t\t aLink := aLink nextLink].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\r\t^self lastLink value"},{"name":"firstLink","linesOfCode":5,"sourceCode":"firstLink\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^firstLink "},{"name":"removeAllSuchThat:","linesOfCode":4,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  For LinkedLists, it's safe to use do:.\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"postCopy","linesOfCode":7,"sourceCode":"postCopy\r\t| aLink |\r\tsuper postCopy.\r\tfirstLink ifNotNil: [\r\t\taLink := firstLink := firstLink copy.\r\t\t[aLink nextLink isNil] whileFalse: [aLink nextLink: (aLink := aLink nextLink copy)].\r\t\tlastLink := aLink]."},{"name":"reject:","linesOfCode":9,"sourceCode":"reject: rejectBlock\r\t\"Optimized version of SequenceableCollection>>#reject:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ newCollection add: each ] ].\r\t^ newCollection"},{"name":"validIndex:","linesOfCode":3,"sourceCode":"validIndex: index\r\t ^index > 0\r\t\t\tand: [index <= self size]"},{"name":"at:putLink:","linesOfCode":23,"sourceCode":"at: index putLink: aLink \r\t| previousLink nextLink |\r\t\"Please don't put a link which is already in the list, or you will create an infinite loop\"\r\t(self validIndex: index)\r\t\tifFalse: [^ self errorOutOfBounds].\r\tindex = 1\r\t\tifTrue: [aLink nextLink: self firstLink nextLink.\r\t\t\tfirstLink := aLink.\r\t\t\taLink nextLink ifNil: [lastLink := aLink].\r\t\t\t^ aLink].\r\tpreviousLink := self linkAt: index - 1.\r\tnextLink := previousLink nextLink nextLink.\r\t\r\tnextLink ifNil: [\r\t\taLink nextLink: self lastLink\r\t] ifNotNil: [\r\t\taLink nextLink: nextLink.\r\t].\r\r\tpreviousLink nextLink: aLink.\r\r\tnextLink ifNil: [\r\t\tlastLink := aLink.\r\t\taLink nextLink: nil.\r\t].\r\r\t^ aLink"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[aBlock value: aLink value.\r\t\t aLink := aLink nextLink]"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^ Array"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: aLinkOrObject ifAbsent: aBlock \r\t\"Remove aLink from the receiver. If it is not there, answer the result of evaluating aBlock.\"\r\t\r\t| link |\r\tlink := self linkOf: aLinkOrObject ifAbsent: [^aBlock value].\r\tself removeLink: link ifAbsent: [^aBlock value].\r\t^aLinkOrObject"},{"name":"removeLink:","linesOfCode":2,"sourceCode":"removeLink: aLink\r\t^self removeLink: aLink ifAbsent: [self error: 'no such method!']"},{"name":"select:thenDo:","linesOfCode":6,"sourceCode":"select: selectBlock thenDo: doBlock\r\t\"Optimized version of SequenceableCollection>>#select:thenDo:\"\r\r\tself\r\t\tdo: [ :each | \r\t\t\t\t(selectBlock value: each)\r\t\t\t\t\tifTrue: [ doBlock value: each ] ]"},{"name":"add:after:","linesOfCode":5,"sourceCode":"add: link after: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link afterLink: otherLink"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t\"Implementation note: this has to be fast\"\r\r\tfirstLink := lastLink := nil"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r^self firstLink value"},{"name":"add:beforeLink:","linesOfCode":15,"sourceCode":"add: aLinkOrObject beforeLink: otherLink\r\r\t| currentLink|\r\r\tfirstLink == otherLink ifTrue: [^ self addFirst: aLinkOrObject].\r\t\r\tcurrentLink := firstLink.\r\t[currentLink == nil] whileFalse: [\r\t\tcurrentLink nextLink == otherLink ifTrue: [\r\t\t\t| aLink |\r\t\t\taLink := aLinkOrObject asLink.\r\t\t\taLink nextLink: currentLink nextLink.\r\t\t\tcurrentLink nextLink: aLink.\r\t\t\t^ aLink\r\t\t].\r\t\t currentLink := currentLink nextLink.\r\t].\r\t^ self errorNotFound: otherLink"},{"name":"addFirst:","linesOfCode":8,"sourceCode":"addFirst: aLinkOrObject \r\t\"Add aLink to the beginning of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty ifTrue: [lastLink := aLink].\r\taLink nextLink: firstLink.\r\tfirstLink := aLink.\r\t^aLink"},{"name":"copyWithout:","linesOfCode":5,"sourceCode":"copyWithout: oldElement\r\t|newInst| \r\tnewInst := self class new.\r\tself do: [:each | each = oldElement ifFalse: [newInst add: each]].\r\t^newInst"},{"name":"add:before:","linesOfCode":5,"sourceCode":"add: link before: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link beforeLink: otherLink"},{"name":"removeLast","linesOfCode":15,"sourceCode":"removeLast\r\t\"Remove the receiver's last element and answer it. If the receiver is \r\tempty, create an error notification.\"\r\r\t| oldLink aLink |\r\tself emptyCheck.\r\toldLink := lastLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [aLink := firstLink.\r\t\t\t\t[aLink nextLink == oldLink] whileFalse:\r\t\t\t\t\t[aLink := aLink nextLink].\r\t\t\t\t aLink nextLink: nil.\r\t\t\t\t lastLink := aLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"add:afterLink:","linesOfCode":9,"sourceCode":"add: aLinkOrObject afterLink: otherLink\r\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| savedLink aLink |\r\tlastLink == otherLink ifTrue: [^ self addLast: aLinkOrObject].\r\tsavedLink := otherLink nextLink.\r\taLink := aLinkOrObject asLink.\r\totherLink nextLink: aLink.\r\taLink nextLink:  savedLink.\r\t^aLink."},{"name":"sort:","linesOfCode":6,"sourceCode":"sort: aBlock\r\t|aLinkedList|\r\tself isEmpty ifTrue: [ ^self ].\r\taLinkedList := LinkedList newFrom: (self asArray sort: aBlock).\r\tfirstLink := aLinkedList firstLink.\r\tlastLink := aLinkedList lastLink."},{"name":"collect:thenReject:","linesOfCode":10,"sourceCode":"collect: collectBlock thenReject: rejectBlock\r\t\"Optimized version of SequenceableCollection>>#collect:#thenReject:\"\r\r\t| newCollection newElement |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\tnewElement := collectBlock value: each.\r\t\t\t(rejectBlock value: newElement)\r\t\t\t\tifFalse: [ newCollection add: newElement ] ].\r\t^ newCollection"},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\r\t^(self linkAt: index) value"},{"name":"addLast:","linesOfCode":9,"sourceCode":"addLast: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty\r\t\tifTrue: [firstLink := aLink]\r\t\tifFalse: [lastLink nextLink: aLink].\r\tlastLink := aLink.\r\t^aLink"},{"name":"lastLink","linesOfCode":5,"sourceCode":"lastLink\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^lastLink"},{"name":"linkOf:","linesOfCode":4,"sourceCode":"linkOf: anObject \r\t^ self\r\t\tlinkOf: anObject\r\t\tifAbsent: [self error: 'No such element']"},{"name":"linkAt:","linesOfCode":2,"sourceCode":"linkAt: index\r\r\t^self linkAt: index ifAbsent: [ self errorSubscriptBounds: index]"},{"name":"removeFirst","linesOfCode":11,"sourceCode":"removeFirst\r\t\"Remove the first element and answer it. If the receiver is empty, create \r\tan error notification.\"\r\r\t| oldLink |\r\tself emptyCheck.\r\toldLink := firstLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [firstLink := oldLink nextLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"collect:thenSelect:","linesOfCode":10,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of SequenceableCollection>>#collect:#thenSelect:\"\r\r\t| newCollection newElement |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\tnewElement := collectBlock value: each.\r\t\t\t(selectBlock value: newElement)\r\t\t\t\tifTrue: [ newCollection add: newElement ] ].\r\t^ newCollection"},{"name":"linkOf:ifAbsent:","linesOfCode":5,"sourceCode":"linkOf: anObject ifAbsent: errorBlock \r\t\r\tself\r\t\tlinksDo: [:el | el value = anObject\r\t\t\t\tifTrue: [^ el]].\r\t^ errorBlock value"},{"name":"select:thenCollect:","linesOfCode":9,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of SequenceableCollection>>#select:thenCollect:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ newCollection add: (collectBlock value: each) ] ].\r\t^ newCollection"}],"meta":{"name":"LinkedList class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: anInt\r\t\"LinkedList don't need capacity\"\r\t^self new"},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ self withAll: (super new: size streamContents: aBlock)"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t\"Answer an instance with same elements as aCollection.\"\r\t^self new\r\t\taddAll: aCollection;\r\t\tyourself"}],"meta":null}},{"name":"OrderedCollection","instanceVariables":[{"name":"array"},{"name":"firstIndex"},{"name":"lastIndex"}],"methods":[{"name":"at:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: index ifAbsentPut: block\r\t\"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)\"\r\r\t| v |\r\tindex <= self size ifTrue: [\r\t\t^ (v := self at: index)\r\t\t\tifNotNil: [v]\r\t\t\tifNil: [self at: index put: block value]\r\t].\r\t[self size < index] whileTrue: [self add: nil].\r\t^ self at: index put: block value"},{"name":"copyWith:","linesOfCode":7,"sourceCode":"copyWith: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver and \r\tincludes the argument, newElement, at the end.\"\r\r\t| newCollection |\r\tnewCollection := self copy.\r\tnewCollection add: newElement.\r\t^newCollection"},{"name":"makeRoomAtFirst","linesOfCode":15,"sourceCode":"makeRoomAtFirst\r\t\"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1\"\r\t\r\t\"#(1 2 3) asOrderedCollection capacity >>> 3\"\r\t\"#(1 2 3) asOrderedCollection makeRoomAtFirst capacity >>> 6\"\r\t\r\t| tally newFirstIndex newLastIndex |\r\ttally := self size.\r\ttally * 2 >= array size ifTrue: [ ^self growAtFirst ].\r\ttally = 0 ifTrue: [ ^self resetTo: array size + 1 ].\r\tnewFirstIndex := array size // 2 + 1.\r\tnewLastIndex := newFirstIndex - firstIndex + lastIndex.\r\t0 to: tally - 1 do: [ :offset |\r\t\tarray at: newLastIndex - offset put: (array at: lastIndex - offset) ].\r\tarray from: firstIndex to: newFirstIndex - 1 put: nil.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"copyReplaceFrom:to:with:","linesOfCode":28,"sourceCode":"copyReplaceFrom: start to: stop with: replacementCollection \r\t\"Answer a copy of the receiver with replacementCollection's elements in\r\tplace of the receiver's start'th to stop'th elements. This does not expect\r\ta 1-1 map from replacementCollection to the start to stop elements, so it\r\twill do an insert or append.\"\r\r\t| newOrderedCollection delta startIndex stopIndex |\r\t\"if start is less than 1, ignore stop and assume this is inserting at the front. \r\tif start greater than self size, ignore stop and assume this is appending. \r\totherwise, it is replacing part of me and start and stop have to be within my \r\tbounds. \"\r\tdelta := 0.\r\tstartIndex := start.\r\tstopIndex := stop.\r\tstart < 1\r\t\tifTrue: [startIndex := stopIndex := 0]\r\t\tifFalse: [startIndex > self size\r\t\t\t\tifTrue: [startIndex := stopIndex := self size + 1]\r\t\t\t\tifFalse: \r\t\t\t\t\t[(stopIndex < (startIndex - 1) or: [stopIndex > self size])\r\t\t\t\t\t\tifTrue: [self errorOutOfBounds].\r\t\t\t\t\tdelta := stopIndex - startIndex + 1]].\r\tnewOrderedCollection := \r\t\tself species new: self size + replacementCollection size - delta.\r\t1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].\r\t1 to: replacementCollection size do: \r\t\t[:index | newOrderedCollection add: (replacementCollection at: index)].\r\tstopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].\r\t^newOrderedCollection"},{"name":"addAllFirstUnlessAlreadyPresent:","linesOfCode":5,"sourceCode":"addAllFirstUnlessAlreadyPresent: anOrderedCollection \r\t\"Add each element of anOrderedCollection at the beginning of the receiver, preserving the order, but do not add any items that are already in the receiver.  Answer anOrderedCollection.\"\r\r\tanOrderedCollection reverseDo:\r\t\t[:each | (self includes: each) ifFalse: [self addFirst: each]].\r\t^ anOrderedCollection"},{"name":"reject:thenCollect:","linesOfCode":10,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r    \" Optimized version of Collection>>#reject:thenCollect: \"\r\r\t| newCollection |\r\r    newCollection := self copyEmpty.\r\r    firstIndex to: lastIndex do: [ :index |\r\t\t| element |\r\t\telement := array at: index.\r\t\t(rejectBlock value: element) \r\t\t\tifFalse: [ newCollection addLast: (collectBlock value: element) ]].\r\r    ^ newCollection"},{"name":"collect:","linesOfCode":12,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my elements as the argument. Collect the \r\tresulting values into a collection that is like me. Answer the new \r\tcollection. Override superclass in order to use addLast:, not at:put:.\"\r\r\t\"(#(1 2 3) asOrderedCollection collect: [ :v | v * 10 ]) asArray >>> #(10 20 30)\"\r\t\"(#(1 2 3) asOrderedCollection collect: [ :v | 10 ]) asArray >>> #(10 10 10)\"\r\t\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\tfirstIndex to: lastIndex do:\r\t\t[:index |\r\t\tnewCollection addLast: (aBlock value: (array at: index))].\r\t^ newCollection"},{"name":"removeAllSuchThat:","linesOfCode":11,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Remove each element of the receiver for which aBlock evaluates to true.\r\tThe method in Collection is O(N^2), this is O(N).\"\r\r\t| n |\r\tn := firstIndex.\r\tfirstIndex to: lastIndex do: [:index |\r\t    (aBlock value: (array at: index)) ifFalse: [\r\t\t\tarray at: n put: (array at: index).\r\t\t\tn := n + 1]].\r\tarray from: n to: lastIndex put: nil.\r\tlastIndex := n - 1"},{"name":"errorConditionNotSatisfied","linesOfCode":2,"sourceCode":"errorConditionNotSatisfied\r\r\tself error: 'no element satisfies condition'"},{"name":"asArray","linesOfCode":7,"sourceCode":"asArray\r\t\"Convert an OrderedCollection into an Array.\"\r\t\"#(a b c) asOrderedCollection asArray >>> #(a b c)\"\r\t\"OrderedCollection new class >>> OrderedCollection\"\r\t\"OrderedCollection new asArray class >>> Array\"\r\t\"(OrderedCollection new add: 42; add: 43; yourself) asArray >>> #(42 43)\"\r\t\r\t^ (Array new: self size) replaceFrom: 1 to: self size with: array startingAt: firstIndex."},{"name":"addAll:","linesOfCode":4,"sourceCode":"addAll: aCollection \r\t\"Add each element of aCollection at my end. Answer aCollection.\"\r\r\t\"(OrderedCollection new addAll: #(41 42); yourself) asArray >>> #(41 42)\"\r\r\r\t^ self addAllLast: aCollection"},{"name":"makeRoomAtLast","linesOfCode":16,"sourceCode":"makeRoomAtLast\r\t\"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size\"\r\t\r\t| tally newFirstIndex newLastIndex |\r\ttally := self size.\r\ttally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].\r\ttally = 0 ifTrue: [ ^self resetTo: 1 ].\r\tnewLastIndex := lastIndex // 2.\r\tnewFirstIndex := newLastIndex - lastIndex + firstIndex.\r\tarray \r\t\treplaceFrom: newFirstIndex\r\t\tto: newLastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray from: newLastIndex + 1 to: lastIndex put: nil.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"reject:","linesOfCode":9,"sourceCode":"reject: rejectBlock \r\t\"Optimized version of Collection>>#reject:\"\r\r\t| newCollection element |\r\t\r\tnewCollection := self copyEmpty.\r\t\r\tfirstIndex to: lastIndex do: [ :index |\r\t\t(rejectBlock value: (element := array at: index))\r\t\t\tifFalse: [ newCollection addLast: element ]].\r\t\t\r\t^ newCollection"},{"name":"withIndexCollect:","linesOfCode":10,"sourceCode":"withIndexCollect: elementAndIndexBlock \r\t\"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:.\"\r\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\tfirstIndex to: lastIndex do:\r\t\t[:index |\r\t\tnewCollection addLast: (elementAndIndexBlock\r\t\t\tvalue: (array at: index)\r\t\t\tvalue: index - firstIndex + 1)].\r\t^ newCollection"},{"name":"insert:before:","linesOfCode":27,"sourceCode":"insert: anObject before: spot\r\r  \"  spot is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection. \r     Never use this method in your code, it is meant for private use by OrderedCollection only.\r     The methods for use are:\r        #add:before:   to insert an object before another object\r        #add:beforeIndex:   to insert an object before a given position. \"\r\t| \"index\" delta spotIndex|\r\tspotIndex := spot.\r\tdelta := spotIndex - firstIndex.\r\tfirstIndex = 1\r\t\tifTrue: \r\t\t\t[self makeRoomAtFirst.\r\t\t\tspotIndex := firstIndex + delta].\r\tfirstIndex := firstIndex - 1.\r\tarray\r\t\treplaceFrom: firstIndex\r\t\tto: spotIndex - 2\r\t\twith: array\r\t\tstartingAt: firstIndex + 1.\r\tarray at: spotIndex - 1 put: anObject.\r\"\tindex := firstIndex := firstIndex - 1.\r\t[index < (spotIndex - 1)]\r\t\twhileTrue: \r\t\t\t[array at: index put: (array at: index + 1).\r\t\t\tindex := index + 1].\r\tarray at: index put: anObject.\"\r\t^ anObject"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver that contains no elements.\"\r\r\t^self species new"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t\"Override the superclass for performance reasons.\"\r\r\tfirstIndex to: lastIndex do: [ :index | \r\t\taBlock value: (array at: index) ]"},{"name":"add:beforeIndex:","linesOfCode":6,"sourceCode":"add: newObject beforeIndex: index \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just before index. Answer newObject.\"\r\t(index between: 1 and: self size+1) ifFalse:[^self errorSubscriptBounds: index].\r\tself insert: newObject before: firstIndex + index - 1.\r\t^ newObject"},{"name":"compact","linesOfCode":10,"sourceCode":"compact\r\t\"remove all empty slots to the end of array, while keeping the empty slots at the front.\"\r\r    | newArray |\r    newArray := self class arrayType new: lastIndex.\r    newArray \r        replaceFrom: firstIndex\r        to: lastIndex\r        with: array\r        startingAt: firstIndex.\r    array := newArray"},{"name":"asOrderedCollection","linesOfCode":3,"sourceCode":"asOrderedCollection \r\r\tself species == OrderedCollection ifTrue: [ ^self ].\r\t^super asOrderedCollection "},{"name":"find:","linesOfCode":12,"sourceCode":"find: oldObject\r  \"  This method answers an index in the range firstIndex .. lastIndex, which is meant for internal use only.\r     Never use this method in your code, the methods for public use are:\r        #indexOf:\r        #indexOf:ifAbsent: \"\r\r\t| index |\r\tindex := firstIndex.\r\t[index <= lastIndex]\r\t\twhileTrue:\r\t\t\t[(array at: index) = oldObject ifTrue: [^ index].\r\t\t\tindex := index + 1].\r\tself errorNotFound: oldObject"},{"name":"resetTo:","linesOfCode":3,"sourceCode":"resetTo: index\r\tfirstIndex := index.\r\tlastIndex := firstIndex - 1"},{"name":"reversed","linesOfCode":8,"sourceCode":"reversed\r\t\"Answer a copy of the receiver with element order reversed.  \"\r\t\"#(2 3 4 'fred') asOrderedCollection reversed >>> #('fred' 4 3 2) asOrderedCollection\"\r\t| newCol |\r\tnewCol := self species new.\r\tself reverseDo:\r\t\t[:elem | newCol addLast: elem].\r\t^ newCol\r\r"},{"name":"add:after:","linesOfCode":11,"sourceCode":"add: newObject after: oldObject \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just succeeding oldObject. Answer newObject.\r\tRaises an error if oldObject is not found\"\r\t\r\t\"(OrderedCollection new add: 41; add: 42 after: 41; yourself) asArray >>>  #(41 42)\"\r\t\"(OrderedCollection new add: 41; add: 42 after: 41; add: 43 after: 41; yourself) asArray >>>  #(41 43 42)\"\r\t\t\r\t| index |\r\tindex := self find: oldObject.\r\tself insert: newObject before: index + 1.\r\t^newObject"},{"name":"with:collect:","linesOfCode":10,"sourceCode":"with: otherCollection collect: twoArgBlock \r\t\"Collect and return the result of evaluating twoArgBlock with \r\tcorresponding elements from this collection and otherCollection.\"\r\t| result |\r\totherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result addLast: (twoArgBlock value: (self at: index)\r\t\t\t\t\t\t\t\t\tvalue: (otherCollection at: index))].\r\t^ result"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ lastIndex - firstIndex + 1"},{"name":"collect:from:to:","linesOfCode":8,"sourceCode":"collect: aBlock from: fromIndex to: toIndex\r\t\"Override superclass in order to use addLast:, not at:put:.\"\r\t| result |\r\tself ensureBoundsFrom: fromIndex to: toIndex.\r\tresult := self species new: toIndex - fromIndex + 1.\r\tfirstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:\r\t\t[:index | result addLast: (aBlock value: (array at: index))].\r\t^ result\r"},{"name":"reverseDo:","linesOfCode":4,"sourceCode":"reverseDo: aBlock\r\t\"Override the superclass for performance reasons.\"\r\r\tlastIndex to: firstIndex by: -1 do: [ :index | \r\t\taBlock value: (array at: index) ]"},{"name":"reset","linesOfCode":3,"sourceCode":"reset\r\t\"Quickly remove all elements. The objects will be still referenced, but will not be \taccessible.\"\r\t\r\tself resetTo: 1"},{"name":"withIndexSelect:select:","linesOfCode":9,"sourceCode":"withIndexSelect: elementAndIndexBlock select: selectBlock\r\t\"Optimized version of SequenceableCollection>>#withIndexSelect: \"\r\r\t\"(#('We' 'love' 'pharo!') asOrderedCollection withIndexSelect: [:value :index | value size - 1 <= index]) >>> (OrderedCollection with: 'We')\"\r\r\t| newCollection element |\r\tnewCollection := self copyEmpty.\r\tfirstIndex to: lastIndex do: [ :index | \r\t\t(selectBlock value: (element := array at: index) value: index)\r\t\t\tifTrue: [ newCollection addLast: element ] ].\r\t^ newCollection"},{"name":"capacity","linesOfCode":5,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new addAll: (1 to: 15); yourself) capacity >>> 20\"\r\t\r\t^ array size"},{"name":"add:before:","linesOfCode":8,"sourceCode":"add: newObject before: oldObject \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just preceding oldObject. Answer newObject.\"\r\t\r\t\"(OrderedCollection new add: 42; add: 41 before: 42; yourself) asArray >>> #(41 42)\"\r\t\r\t| index |\r\tindex := self find: oldObject.\r\tself insert: newObject before: index.\r\t^newObject"},{"name":"removeDuplicates","linesOfCode":15,"sourceCode":"removeDuplicates\r\t\"Remove the copies of elements, but keep the same order\"\r\t\r\t\"#(7 42 7 42 9) asOrderedCollection removeDuplicates asArray >>> #(7 42 9)\"\r\t\"#(1 2 3) asOrderedCollection removeDuplicates asArray >>> #(1 2 3)\"\r\r\t| iterator seen |\r\tself ifEmpty: [ ^ self ].\r\titerator := 1.\r\tseen := Set new.\r\t[ iterator <= self size ]\r\t\twhileTrue: [ | each |\r\t\t\teach := self at: iterator.\r\t\t\t(seen includes: each)\r\t\t\t\tifTrue: [ self removeAt: iterator ]\r\t\t\t\tifFalse: [ seen add: each. iterator := iterator + 1. ].\r\t ]"},{"name":"setContents:","linesOfCode":4,"sourceCode":"setContents: anArray\r\tarray := anArray.\r\tfirstIndex := 1.\r\tlastIndex := array size."},{"name":"at:","linesOfCode":13,"sourceCode":"at: anInteger\r\t\"Answer my element at index anInteger. at: is used by a knowledgeable\r\tclient to access an existing element.\"\r\t\"((OrderedCollection new add: 34; yourself) at: 1) >>> 34\"\r\t\"(#(40 41 42) asOrderedCollection at: 1) >>> 40\"\r\t\"(#(40 41 42) asOrderedCollection at: 2) >>> 41\"\r\t\"(#(40 41 42) asOrderedCollection at: 3) >>> 42\"\r\r\t| index |\r\tanInteger < 1\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t(index := anInteger + firstIndex - 1) > lastIndex\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t^ array at: index"},{"name":"setCollection:","linesOfCode":3,"sourceCode":"setCollection: anArray\r\tarray := anArray.\r\tself reset"},{"name":"join:","linesOfCode":8,"sourceCode":"join: aCollection \r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\r\t| result |\r\tresult := self class new.\r\taCollection\r\t\tdo: [:each | each appendTo: result]\r\t\tseparatedBy: [self appendTo: result].\r\t^ result"},{"name":"collect:thenSelect:","linesOfCode":9,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r    \"Optimized version Collection>>#collect:thenSelect:\"\r\r    | newCollection newElement |\r\r    newCollection := self copyEmpty.\r    firstIndex to: lastIndex do: [ :index | \r\t\tnewElement := collectBlock value: (array at: index).\r\t\t(selectBlock value: newElement) \r\t\t\tifTrue: [ newCollection addLast: newElement ]].\r    ^ newCollection"},{"name":"select:thenCollect:","linesOfCode":9,"sourceCode":"select: selectBlock thenCollect: collectBlock\r    \" Optimized version Collection>>#select:thenCollect: \"\r\r\t| newCollection element |\r\r    newCollection := self copyEmpty.\r\r    firstIndex to: lastIndex do: [ :index |\r\t\telement := array at: index.\r\t\t(selectBlock value: element) \r\t\t\tifTrue: [ newCollection addLast: (collectBlock value: element) ]].\r\r    ^ newCollection"},{"name":"postCopyFrom:to:","linesOfCode":12,"sourceCode":"postCopyFrom: startIndex to: endIndex \r\t\"finish copying the array in a certain range.\"\r\r\tendIndex < startIndex ifFalse: [\r\t\t\"Because actual size of the array may be greater than used size,\r\t\tpostCopyFrom:to: may fail to fail and answer an incorrect result\r\t\tif this sanity check were not applied.\"\r\t\t(startIndex between: 1 and: self size) ifFalse: [^SubscriptOutOfBounds signalFor: startIndex lowerBound: (1 min: self size) upperBound: self size in: self].\r\t\t(endIndex between: 1 and: self size) ifFalse: [^SubscriptOutOfBounds signalFor: endIndex lowerBound: (1 min: self size) upperBound: self size in: self]].\r\t\r\t\"Add a protection that lacks in Array>>postcopy\"\r\tarray := array copyFrom: startIndex + firstIndex - 1 to: (endIndex max: startIndex - 1) + firstIndex - 1.\r\tfirstIndex := 1.\r\tlastIndex := array size"},{"name":"addAllFirst:","linesOfCode":6,"sourceCode":"addAllFirst: anOrderedCollection \r\t\"Add each element of anOrderedCollection at the beginning of the \r\treceiver. Answer anOrderedCollection.\"\r\t\r\t\"((OrderedCollection new add: 40; addAllFirst: #(41 42); yourself) asArray) >>  #(41 42 40)\"\r\r\tanOrderedCollection reverseDo: [:each | self addFirst: each].\r\t^anOrderedCollection"},{"name":"add:","linesOfCode":9,"sourceCode":"add: newObject\r\t\"Add a new object at the end of the collection, and returns the object itself\"\r\t\"((OrderedCollection new add: 42; yourself) add: 43; yourself) asArray >>> #(42 43)\"\r\t\r\t\"Add returns the object itself\"\r\t\"(OrderedCollection new add: 42) >>> 42\"\r\t\r\t\"You may want to use yourself to return the collection itself\"\r\t\"(OrderedCollection new add: 42; yourself) class >>> OrderedCollection\"\r\t\"(OrderedCollection new add: 42; yourself) size >>> 1\"\r\t^self addLast: newObject"},{"name":"collector","linesOfCode":2,"sourceCode":"collector  \"Private\"\r\t^ array"},{"name":"removeIndex:","linesOfCode":12,"sourceCode":"removeIndex: removedIndex\r  \"  removedIndex is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.\r    Never use this method in your code, it is meant for private use by OrderedCollection only.\r     The method for public use is:\r        #removeAt: \"\r\r\tarray \r\t\treplaceFrom: removedIndex \r\t\tto: lastIndex - 1 \r\t\twith: array \r\t\tstartingAt: removedIndex+1.\r\tarray at: lastIndex put: nil.\r\tlastIndex := lastIndex - 1."},{"name":"postCopy","linesOfCode":2,"sourceCode":"postCopy\r\tarray := array copy"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #OrderedCollection earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder] as: Array]"},{"name":"remove:ifAbsent:","linesOfCode":11,"sourceCode":"remove: oldObject ifAbsent: absentBlock\r\r\t| index |\r\tindex := firstIndex.\r\t[index <= lastIndex]\r\t\twhileTrue: \r\t\t\t[oldObject = (array at: index)\r\t\t\t\tifTrue: \r\t\t\t\t\t[self removeIndex: index.\r\t\t\t\t\t^ oldObject]\r\t\t\t\tifFalse: [index := index + 1]].\r\t^ absentBlock value"},{"name":"removeAt:","linesOfCode":5,"sourceCode":"removeAt: index\r\t| removed |\r\tremoved := self at: index.\r\tself removeIndex: index + firstIndex - 1.\r\t^removed"},{"name":"addAllLast:","linesOfCode":5,"sourceCode":"addAllLast: aCollection \r\t\"Add each element of aCollection at the end of the receiver. \r\tAnswer aCollection.\"\r\r\taCollection do: [:each | self addLast: each].\r\t^aCollection"},{"name":"removeAll","linesOfCode":4,"sourceCode":"removeAll\r\t\"remove all the elements from this collection.\r\tKeep same amount of storage\"\r\t\r\tself setCollection: (self class arrayType new: array size)"},{"name":"removeLast:","linesOfCode":12,"sourceCode":"removeLast: n \r\t\"Remove last n object into an array with last in last position\"\r\t| list |\r\tlist := self class arrayType new: n.\r\tn\r\t\tto: 1\r\t\tby: -1\r\t\tdo:\r\t\t\t[ : i | list\r\t\t\t\tat: i\r\t\t\t\tput: self removeLast ].\r\t^ list"},{"name":"addFirst:","linesOfCode":6,"sourceCode":"addFirst: newObject \r\t\"Add newObject to the beginning of the receiver. Answer newObject.\"\r\r\tfirstIndex = 1 ifTrue: [self makeRoomAtFirst].\r\tfirstIndex := firstIndex - 1.\r\tarray at: firstIndex put: newObject.\r\t^ newObject"},{"name":"removeLast","linesOfCode":9,"sourceCode":"removeLast\r\t\"Remove the last element of the receiver and answer it. If the receiver is \r\tempty, create an error notification.\"\r\t| lastObject |\r\tself emptyCheck.\r\tlastObject := array at: lastIndex.\r\tarray at: lastIndex put: nil.\r\tlastIndex := lastIndex - 1.\r\t^ lastObject"},{"name":"growAtFirst","linesOfCode":16,"sourceCode":"growAtFirst\r\t\"Add new empty slots to the front of array, while keeping the empty slots at the end.\"\r\t\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new growAtFirst; capacity) >>> 20\"\r\t\r\r\t| newArray newFirstIndex newLastIndex |\r\tnewArray := self class arrayType new: (array size * 2 max: 1).\r\tnewFirstIndex := newArray size - array size + firstIndex.\r\tnewLastIndex := newFirstIndex + lastIndex - firstIndex.\r\tnewArray \r\t\treplaceFrom: newFirstIndex\r\t\tto: newLastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray := newArray.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"sort:","linesOfCode":10,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tarray\r\t\tmergeSortFrom: firstIndex\r\t\tto: lastIndex \r\t\tsrc: array shallowCopy \r\t\tdst: array \r\t\tby: aSortBlock"},{"name":"ensureBoundsFrom:to:","linesOfCode":5,"sourceCode":"ensureBoundsFrom: fromIndex to: toIndex\r\t(fromIndex < 1)\r\t\tifTrue: [^self errorSubscriptBounds: fromIndex].\r\t(toIndex + firstIndex - 1 > lastIndex)\r\t\tifTrue: [^self errorSubscriptBounds: toIndex]."},{"name":"copyFrom:to:","linesOfCode":4,"sourceCode":"copyFrom: startIndex to: endIndex \r\t\"Answer a copy of the receiver that contains elements from position\r\tstartIndex to endIndex.\"\r\r\t^self shallowCopy postCopyFrom: startIndex to: endIndex"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\t\"Since we have subclasses of OrderedCollection that behave differently, we cannot use the visitSimpleCollection: for all of them.\"\r\t^ (self class == OrderedCollection ) \r\t\tifTrue: [ aGeneralMapper visitSimpleCollection: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"addLast:","linesOfCode":6,"sourceCode":"addLast: newObject \r\t\"Add newObject to the end of the receiver. Answer newObject.\"\r\r\tlastIndex = array size ifTrue: [self makeRoomAtLast].\r\tlastIndex := lastIndex + 1.\r\tarray at: lastIndex put: newObject.\r\t^ newObject"},{"name":"growAtLast","linesOfCode":12,"sourceCode":"growAtLast\r\t\"Add new empty slots to the end of array, while keeping the empty slots at the front.\"\r\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new growAtLast; capacity) >>> 20\"\r\r\t| newArray |\r\tnewArray := self class arrayType new: (array size * 2 max: 1).\r\tnewArray \r\t\treplaceFrom: firstIndex\r\t\tto: lastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray := newArray"},{"name":"removeFirst:","linesOfCode":11,"sourceCode":"removeFirst: n \r\t\"Remove first n object into an array\"\r\t| list |\r\tlist := self class arrayType new: n.\r\t1\r\t\tto: n\r\t\tdo:\r\t\t\t[ : i | list\r\t\t\t\tat: i\r\t\t\t\tput: self removeFirst ].\r\t^ list"},{"name":"add:afterIndex:","linesOfCode":6,"sourceCode":"add: newObject afterIndex: index \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just after index. Answer newObject.\"\r\t(index between: 0 and: self size) ifFalse:[^self errorSubscriptBounds: index].\r\tself insert: newObject before: firstIndex + index.\r\t^ newObject"},{"name":"removeFirst","linesOfCode":9,"sourceCode":"removeFirst\r\t\"Remove the first element of the receiver and answer it. If the receiver is \r\tempty, create an error notification.\"\r\t| firstObject |\r\tself emptyCheck.\r\tfirstObject := array at: firstIndex.\r\tarray at: firstIndex put: nil.\r\tfirstIndex := firstIndex + 1.\r\t^ firstObject"},{"name":"select:","linesOfCode":9,"sourceCode":"select: selectBlock \r\t\"Optimized version of Collection>>#select: \"\r\r\t| newCollection element |\r\t\r\tnewCollection := self copyEmpty.\r\t\r\tfirstIndex to: lastIndex do: [ :index |\r\t\t(selectBlock value: (element := array at: index))\r\t\t\tifTrue: [ newCollection addLast: element ]].\r\t\t\r\t^ newCollection"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: anInteger put: anObject\r\t\"Put anObject at element index anInteger. at:put: cannot be used to\r\tappend, front or back, to an ordered collection; it is used by a\r\tknowledgeable client to replace an element.\"\r\r\t| index |\r\tanInteger < 1\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t(index := anInteger + firstIndex - 1) > lastIndex\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t^ array at: index put: anObject"}],"meta":{"name":"OrderedCollection class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: anInteger \r\t^ self basicNew setCollection: (self arrayType new: anInteger)"},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ self withAll: (super new: size streamContents: aBlock)"},{"name":"arrayType","linesOfCode":2,"sourceCode":"arrayType\r\t^ Array"},{"name":"ofSize:","linesOfCode":8,"sourceCode":"ofSize: n\r\t\"Create a new collection of size n with nil as its elements.\r\tThis method exists because OrderedCollection new: n creates an\r\tempty collection,  not one of size n.\"\r\t| collection |\r\tcollection := self new: n.\r\tcollection setContents: (collection collector).\r\t^ collection\r"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"new:withAll:","linesOfCode":2,"sourceCode":"new: anInteger withAll: anObject\r\t^ self basicNew setContents: (self arrayType new: anInteger withAll: anObject)"},{"name":"compactAllInstances","linesOfCode":2,"sourceCode":"compactAllInstances\r\tself allInstances do: #compact"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 10"},{"name":"newFrom:","linesOfCode":9,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t| newCollection |\r\tnewCollection := self new: aCollection size.\r\tnewCollection addAll: aCollection.\r\t^newCollection\r\r\"\tOrderedCollection newFrom: {1. 2. 3}\r\t{1. 2. 3} as: OrderedCollection\r\t{4. 2. 7} as: SortedCollection\r\""},{"name":"cleanUp:","linesOfCode":3,"sourceCode":"cleanUp: aggressive\r\t\"Rehash all instances when cleaning aggressively\"\r\r\taggressive ifTrue: [self compactAll]."},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #OrderedCollection ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext do: [ :eachValue |\r\t\t\tresult add: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"compactAll","linesOfCode":4,"sourceCode":"compactAll\r\t\"OrderedCollection compactAll\"\t\r\t\t\r\tself allSubclassesDo: #compactAllInstances"}],"meta":null}},{"name":"ProcessList","instanceVariables":[{"name":"firstLink"},{"name":"lastLink"}],"methods":[{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Reimplemennt #select: for speedup on linked lists. \r\tThe super implemention accesses the linkes by index, thus causing an O(n^2)\"\r\t\r\t| newCollection |\r\tnewCollection := self class new.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"copyWith:","linesOfCode":2,"sourceCode":"copyWith: newElement\r\t^self copy add: newElement; yourself"},{"name":"isEmpty","linesOfCode":2,"sourceCode":"isEmpty\r\r\t^firstLink isNil"},{"name":"linkAt:ifAbsent:","linesOfCode":6,"sourceCode":"linkAt: index ifAbsent: errorBlock\r\r\t| i |\r\ti := 0.\r\tself linksDo: [:link |\r\t\t(i := i + 1) = index ifTrue: [^ link]].\r\t^ errorBlock value"},{"name":"linksDo:","linesOfCode":7,"sourceCode":"linksDo: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil ] whileFalse:\r\t\t[\r\t\taBlock value: aLink.\r\t\taLink := aLink nextLink]"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: anObject\r\r\t^self at: index putLink: (self linkOf: anObject ifAbsent: [anObject asLink])"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":13,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\t\t\r\t|currentLink index|\t\t\r\tcurrentLink := self linkAt: start ifAbsent: [nil].\r\tindex := start.\r\t[currentLink isNil ] \r\t\twhileFalse: [currentLink value = anElement value ifTrue: [^index].\r\t\t\t\t\tcurrentLink := currentLink nextLink.\r\t\t\t\t\tindex := index +1].\r\t^exceptionBlock value"},{"name":"swap:with:","linesOfCode":25,"sourceCode":"swap: ix1 with: ix2\r\t\"Reimplemented, super would create an infinite loop\"\r\t| minIx maxIx link1Prev link2Prev link1 link2 link1Next link2Next newLink2Next |\r\t((self validIndex: ix1) and: [self validIndex: ix2])\tifFalse: [^ self errorOutOfBounds].\r\t\r\t\"Get edge case out of the way\"\r\tix1 = ix2 ifTrue: [^ self ].\r\t\r\t\"Sort indexes to make boundary-checks easier\" \r\tminIx := ix1 min: ix2.\r\tmaxIx := ix2 max: ix1.\r\t\r\tlink1Prev := (minIx = 1) ifFalse: [self linkAt: minIx -1].\r\tlink1 := link1Prev ifNotNil: [ link1Prev nextLink]\r\t\t\t\tifNil: [self linkAt: minIx].\r\tlink1Next := link1 nextLink.\r\tlink2Prev := self linkAt: maxIx -1.\r\tlink2 := link2Prev nextLink.\r\tlink2Next := link2 nextLink.\r\t\r\t\"Link at start being swapped\"\r\tlink1 = firstLink ifTrue: [firstLink := link2.] ifFalse: [link1Prev nextLink: link2].\r\t\"Link at end being swapped\"\r\tlink2 = lastLink ifTrue: [lastLink := link1] ifFalse: [].\r\t\"Links  being swapped adjacent\"\r\tnewLink2Next := (link1 nextLink = link2) ifTrue: [link1] ifFalse: [link2Prev nextLink: link1.\r\t\tlink1Next].\r\tlink1 nextLink: link2Next.\r\tlink2 nextLink: newLink2Next.\r\t"},{"name":"add:","linesOfCode":3,"sourceCode":"add: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\r\t^self addLast: aLinkOrObject"},{"name":"removeLink:ifAbsent:","linesOfCode":18,"sourceCode":"removeLink: aLink ifAbsent: aBlock  \r\t\"Remove aLink from the receiver. If it is not there, answer the result of\r\tevaluating aBlock.\"\r\r\t| tempLink |\r\taLink == firstLink\r\t\tifTrue: [firstLink := aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := nil]]\r\t\tifFalse: [tempLink := firstLink.\r\t\t\t\t[tempLink == nil ifTrue: [^aBlock value].\r\t\t\t\t tempLink nextLink == aLink]\r\t\t\t\t\twhileFalse: [tempLink := tempLink nextLink].\r\t\t\t\ttempLink nextLink: aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := tempLink]].\r\t\"Not nilling the link enables us to delete while iterating\"\r\t\"aLink nextLink: nil.\"\r\t^aLink"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| aLink newCollection |\r\tnewCollection := self class new.\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[newCollection add: (aBlock value: aLink value).\r\t\t aLink := aLink nextLink].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\r\t^self lastLink value"},{"name":"firstLink","linesOfCode":5,"sourceCode":"firstLink\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^firstLink "},{"name":"removeAllSuchThat:","linesOfCode":4,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  For LinkedLists, it's safe to use do:.\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"postCopy","linesOfCode":7,"sourceCode":"postCopy\r\t| aLink |\r\tsuper postCopy.\r\tfirstLink ifNotNil: [\r\t\taLink := firstLink := firstLink copy.\r\t\t[aLink nextLink isNil] whileFalse: [aLink nextLink: (aLink := aLink nextLink copy)].\r\t\tlastLink := aLink]."},{"name":"validIndex:","linesOfCode":3,"sourceCode":"validIndex: index\r\t ^index > 0\r\t\t\tand: [index <= self size]"},{"name":"at:putLink:","linesOfCode":23,"sourceCode":"at: index putLink: aLink \r\t| previousLink nextLink |\r\t\"Please don't put a link which is already in the list, or you will create an infinite loop\"\r\t(self validIndex: index)\r\t\tifFalse: [^ self errorOutOfBounds].\r\tindex = 1\r\t\tifTrue: [aLink nextLink: self firstLink nextLink.\r\t\t\tfirstLink := aLink.\r\t\t\taLink nextLink ifNil: [lastLink := aLink].\r\t\t\t^ aLink].\r\tpreviousLink := self linkAt: index - 1.\r\tnextLink := previousLink nextLink nextLink.\r\t\r\tnextLink ifNil: [\r\t\taLink nextLink: self lastLink\r\t] ifNotNil: [\r\t\taLink nextLink: nextLink.\r\t].\r\r\tpreviousLink nextLink: aLink.\r\r\tnextLink ifNil: [\r\t\tlastLink := aLink.\r\t\taLink nextLink: nil.\r\t].\r\r\t^ aLink"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[aBlock value: aLink value.\r\t\t aLink := aLink nextLink]"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^ Array"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: aLinkOrObject ifAbsent: aBlock \r\t\"Remove aLink from the receiver. If it is not there, answer the result of evaluating aBlock.\"\r\t\r\t| link |\r\tlink := self linkOf: aLinkOrObject ifAbsent: [^aBlock value].\r\tself removeLink: link ifAbsent: [^aBlock value].\r\t^aLinkOrObject"},{"name":"removeLink:","linesOfCode":2,"sourceCode":"removeLink: aLink\r\t^self removeLink: aLink ifAbsent: [self error: 'no such method!']"},{"name":"add:after:","linesOfCode":5,"sourceCode":"add: link after: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link afterLink: otherLink"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t\"Implementation note: this has to be fast\"\r\r\tfirstLink := lastLink := nil"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r^self firstLink value"},{"name":"add:beforeLink:","linesOfCode":15,"sourceCode":"add: aLinkOrObject beforeLink: otherLink\r\r\t| currentLink|\r\r\tfirstLink == otherLink ifTrue: [^ self addFirst: aLinkOrObject].\r\t\r\tcurrentLink := firstLink.\r\t[currentLink == nil] whileFalse: [\r\t\tcurrentLink nextLink == otherLink ifTrue: [\r\t\t\t| aLink |\r\t\t\taLink := aLinkOrObject asLink.\r\t\t\taLink nextLink: currentLink nextLink.\r\t\t\tcurrentLink nextLink: aLink.\r\t\t\t^ aLink\r\t\t].\r\t\t currentLink := currentLink nextLink.\r\t].\r\t^ self errorNotFound: otherLink"},{"name":"addFirst:","linesOfCode":8,"sourceCode":"addFirst: aLinkOrObject \r\t\"Add aLink to the beginning of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty ifTrue: [lastLink := aLink].\r\taLink nextLink: firstLink.\r\tfirstLink := aLink.\r\t^aLink"},{"name":"copyWithout:","linesOfCode":5,"sourceCode":"copyWithout: oldElement\r\t|newInst| \r\tnewInst := self class new.\r\tself do: [:each | each = oldElement ifFalse: [newInst add: each]].\r\t^newInst"},{"name":"add:before:","linesOfCode":5,"sourceCode":"add: link before: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link beforeLink: otherLink"},{"name":"removeLast","linesOfCode":15,"sourceCode":"removeLast\r\t\"Remove the receiver's last element and answer it. If the receiver is \r\tempty, create an error notification.\"\r\r\t| oldLink aLink |\r\tself emptyCheck.\r\toldLink := lastLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [aLink := firstLink.\r\t\t\t\t[aLink nextLink == oldLink] whileFalse:\r\t\t\t\t\t[aLink := aLink nextLink].\r\t\t\t\t aLink nextLink: nil.\r\t\t\t\t lastLink := aLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"add:afterLink:","linesOfCode":9,"sourceCode":"add: aLinkOrObject afterLink: otherLink\r\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| savedLink aLink |\r\tlastLink == otherLink ifTrue: [^ self addLast: aLinkOrObject].\r\tsavedLink := otherLink nextLink.\r\taLink := aLinkOrObject asLink.\r\totherLink nextLink: aLink.\r\taLink nextLink:  savedLink.\r\t^aLink."},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\r\t^(self linkAt: index) value"},{"name":"addLast:","linesOfCode":9,"sourceCode":"addLast: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty\r\t\tifTrue: [firstLink := aLink]\r\t\tifFalse: [lastLink nextLink: aLink].\r\tlastLink := aLink.\r\t^aLink"},{"name":"lastLink","linesOfCode":5,"sourceCode":"lastLink\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^lastLink"},{"name":"linkOf:","linesOfCode":4,"sourceCode":"linkOf: anObject \r\t^ self\r\t\tlinkOf: anObject\r\t\tifAbsent: [self error: 'No such element']"},{"name":"linkAt:","linesOfCode":2,"sourceCode":"linkAt: index\r\r\t^self linkAt: index ifAbsent: [ self errorSubscriptBounds: index]"},{"name":"removeFirst","linesOfCode":11,"sourceCode":"removeFirst\r\t\"Remove the first element and answer it. If the receiver is empty, create \r\tan error notification.\"\r\r\t| oldLink |\r\tself emptyCheck.\r\toldLink := firstLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [firstLink := oldLink nextLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"collect:thenSelect:","linesOfCode":10,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of SequenceableCollection>>#collect:#thenSelect:\"\r\r\t| newCollection newElement |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\tnewElement := collectBlock value: each.\r\t\t\t(selectBlock value: newElement)\r\t\t\t\tifTrue: [ newCollection add: newElement ] ].\r\t^ newCollection"},{"name":"linkOf:ifAbsent:","linesOfCode":5,"sourceCode":"linkOf: anObject ifAbsent: errorBlock \r\t\r\tself\r\t\tlinksDo: [:el | el value = anObject\r\t\t\t\tifTrue: [^ el]].\r\t^ errorBlock value"},{"name":"select:thenCollect:","linesOfCode":9,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of SequenceableCollection>>#select:thenCollect:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ newCollection add: (collectBlock value: each) ] ].\r\t^ newCollection"}],"meta":{"name":"ProcessList class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: anInt\r\t\"LinkedList don't need capacity\"\r\t^self new"},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ self withAll: (super new: size streamContents: aBlock)"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t\"Answer an instance with same elements as aCollection.\"\r\t^self new\r\t\taddAll: aCollection;\r\t\tyourself"}],"meta":null}},{"name":"RunArray","instanceVariables":[{"name":"runs"},{"name":"values"},{"name":"lastIndex"},{"name":"lastRun"},{"name":"lastOffset"}],"methods":[{"name":"coalesce","linesOfCode":13,"sourceCode":"coalesce\r\t\"Try to combine adjacent runs\"\r\t| ind |\r\tind := 2.\r\t[ind > values size] whileFalse: [\r\t\t(values at: ind-1) = (values at: ind) \r\t\t\tifFalse: [ind := ind + 1]\r\t\t\tifTrue: [\"two are the same, combine them\"\r\t\t\t\tvalues := values copyReplaceFrom: ind to: ind with: #().\r\t\t\t\truns at: ind-1 put: (runs at: ind-1) + (runs at: ind).\r\t\t\t\truns := runs copyReplaceFrom: ind to: ind with: #().\r\t\t\t\t\"self error: 'needed to combine runs' \"]].\r\t\t\t"},{"name":"detectSum:","linesOfCode":8,"sourceCode":"detectSum: aBlock\r\t\"Only loop on runs\"\r\t| sum |\r\tself deprecated: 'Use #sum: instead'.\r\tsum := 0.\r\tself runsAndValuesDo: [:run :value | \r\t\tsum := (aBlock value: value) * run + sum].\r\t^ sum"},{"name":"sum:","linesOfCode":7,"sourceCode":"sum: aBlock\r\t\"Only loop on runs\"\r\t| sum |\r\tsum := 0.\r\tself runsAndValuesDo: [:run :value | \r\t\tsum := (aBlock value: value) * run + sum].\r\t^ sum"},{"name":"copyReplaceFrom:to:with:","linesOfCode":4,"sourceCode":"copyReplaceFrom: start to: stop with: replacement\r\r\t^(self copyFrom: 1 to: start - 1)\r\t\t, replacement \r\t\t, (self copyFrom: stop + 1 to: self size)"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonReader parseNamedInstVarsFor: self"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^values includes: anObject"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonWriter writeObject: self"},{"name":"runsAndValuesDo:","linesOfCode":3,"sourceCode":"runsAndValuesDo: aBlock\r\t\"Evaluate aBlock with run lengths and values from the receiver\"\r\t^runs with: values do: aBlock."},{"name":"collect:","linesOfCode":3,"sourceCode":"collect: aBlock\r\t\"Beware, the block will be evaluated only once per group of values.\"\r\t^(self class runs: runs copy contents values: (values collect: aBlock)) coalesce"},{"name":"last","linesOfCode":2,"sourceCode":"last\r\t^values at: values size"},{"name":"=","linesOfCode":8,"sourceCode":"= otherArray \r\t\"Test if all my elements are equal to those of otherArray\"\r\r\tself == otherArray ifTrue: [^true].\r\tself species == otherArray species ifFalse: [^ false].\r\t(otherArray isMemberOf: RunArray) ifFalse: [^ self hasEqualElements: otherArray].\r\r\t\"Faster test between two RunArrays\"\r\t^ (runs hasEqualElements: otherArray runs)\r\t\tand: [values hasEqualElements: otherArray values]"},{"name":"copyUpToLast:","linesOfCode":7,"sourceCode":"copyUpToLast: anElement\r\t\"Optimized\"\r\r\t| newValues |\r\tnewValues := values copyUpToLast: anElement.\r\t^ self class\r\t\truns: (runs copyFrom: 1 to: newValues size)\r\t\tvalues: newValues"},{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^values asSet"},{"name":"findLast:","linesOfCode":6,"sourceCode":"findLast: aBlock\r\t| index |\r\tindex := values size + 1.\r\t[(index := index - 1) >= 1] whileTrue:\r\t\t[(aBlock value: (values at: index)) ifTrue: [^(1 to: index) detectSum: [:i | runs at: i]]].\r\t^0"},{"name":"setRuns:setValues:","linesOfCode":4,"sourceCode":"setRuns: newRuns setValues: newValues\r\tlastIndex := nil. \"flush access cache\"\r\truns := newRuns asArray.\r\tvalues := newValues asArray."},{"name":"do:","linesOfCode":8,"sourceCode":"do: aBlock\r\t\"This is refined for speed\"\r\t\r\t1 to: runs size do: [:i |\r\t\t| r v |\r\t\tv := values at: i.\r\t\tr := runs at: i.\r\t\t[( r := r - 1) >= 0]\r\t\t\twhileTrue: [aBlock value: v]]."},{"name":"findFirst:","linesOfCode":7,"sourceCode":"findFirst: aBlock\r\t| index |\r\tindex := 1.\r\tself runsAndValuesDo: [ :run :value |\r\t\t(aBlock value: value) ifTrue: [^index].\r\t\tindex := index + run].\r\t^0"},{"name":"reversed","linesOfCode":2,"sourceCode":"reversed\r\t^self class runs: runs reversed values: values reversed"},{"name":"noneSatisfy:","linesOfCode":3,"sourceCode":"noneSatisfy: aBlock \r\t\"Only evaluate once per run\"\r\r\t^values noneSatisfy: aBlock"},{"name":"size","linesOfCode":5,"sourceCode":"size\r\t| size |\r\tsize := 0.\r\t1 to: runs size do: [:i | size := size + (runs at: i)].\r\t^size"},{"name":"printOn:","linesOfCode":7,"sourceCode":"printOn: aStream\r\tself printNameOn: aStream.\r\taStream\r\t\tnextPutAll: ' runs: ';\r\t\tprint: runs;\r\t\tnextPutAll: ' values: ';\r\t\tprint: values"},{"name":"reverseDo:","linesOfCode":12,"sourceCode":"reverseDo: aBlock\r\t\"This is refined for speed\"\r\t\r\t| i |\r\ti := runs size.\r\t[i > 0]\r\t\twhileTrue: \r\t\t\t[ | r v |\r\t\t\tv := values at: i.\r\t\t\tr := runs at: i.\r\t\t\ti := i - 1.\r\t\t\t[( r := r - 1) >= 0]\r\t\t\t\twhileTrue: [aBlock value: v]]."},{"name":"first","linesOfCode":2,"sourceCode":"first\r\t^values at: 1"},{"name":"isSortedBy:","linesOfCode":2,"sourceCode":"isSortedBy: aBlock\r\t^values isSortedBy: aBlock"},{"name":"writeOn:","linesOfCode":6,"sourceCode":"writeOn: aStream\r\r\taStream nextWordPut: runs size.\r\t1 to: runs size do:\r\t\t[:x |\r\t\taStream nextWordPut: (runs at: x).\r\t\taStream nextWordPut: (values at: x)]"},{"name":"isSorted","linesOfCode":2,"sourceCode":"isSorted\r\t^values isSorted"},{"name":"fillFrom:with:","linesOfCode":25,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollection's elements as the argument.\r\tCollect the resulting values into self. Answer self.\"\r\r\t| newRuns newValues lastLength lastValue |\r\tnewRuns := (Array new: aCollection size) writeStream.\r\tnewValues := (Array new: aCollection size) writeStream.\r\tlastLength := 0.\r\tlastValue := Object new.\r\taCollection do: [:each | \r\t\t| value |\r\t\tvalue := aBlock value: each.\r\t\tlastValue = value\r\t\t\tifTrue: [lastLength := lastLength + 1]\r\t\t\tifFalse:\r\t\t\t\t[lastLength > 0\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[newRuns nextPut: lastLength.\r\t\t\t\t\t\tnewValues nextPut: lastValue].\r\t\t\t\tlastLength := 1.\r\t\t\t\tlastValue := value]].\r\tlastLength > 0\r\t\tifTrue:\r\t\t\t[newRuns nextPut: lastLength.\r\t\t\tnewValues nextPut: lastValue].\r\tself setRuns: newRuns contents setValues: newValues contents"},{"name":"at:setRunOffsetAndValue:","linesOfCode":28,"sourceCode":"at: index setRunOffsetAndValue: aBlock \r\t\"Supply all run information to aBlock.\"\r\t\"Tolerates index=0 and index=size+1 for copyReplace: \"\r\t| run limit offset |\r\tlimit := runs size.\r\t(lastIndex == nil or: [index < lastIndex])\r\t\tifTrue: \"cache not loaded, or beyond index - start over\"\r\t\t\t[run := 1.\r\t\t\toffset := index-1]\r\t\tifFalse: \"cache loaded and before index - start at cache\"\r\t\t\t[run := lastRun.\r\t\t\toffset := lastOffset + (index-lastIndex)].\r\t[run <= limit and: [offset >= (runs at: run)]]\r\t\twhileTrue: \r\t\t\t[offset := offset - (runs at: run).\r\t\t\trun := run + 1].\r\tlastIndex := index. \"Load cache for next access\"\r\tlastRun := run.\r\tlastOffset := offset.\r\trun > limit\r\t\tifTrue: \r\t\t\t[\"adjustment for size+1\"\r\t\t\trun := run - 1.\r\t\t\toffset := offset + (runs at: run)].\r\t^aBlock\r\t\tvalue: run \"an index into runs and values\"\r\t\tvalue: offset \"zero-based offset from beginning of this run\"\r\t\tvalue: (values at: run) \"value for this run\""},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\r\tself at: index setRunOffsetAndValue: [:run :offset :value | ^value]"},{"name":"runs","linesOfCode":2,"sourceCode":"runs\r\r\t^runs"},{"name":"detectMin:","linesOfCode":3,"sourceCode":"detectMin: aBlock\r\t\"Only evaluate once per run\"\r\r\t^values detectMin: aBlock"},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ self class == RunArray and: [values isSelfEvaluating]"},{"name":"repeatLast:ifEmpty:","linesOfCode":10,"sourceCode":"repeatLast: times ifEmpty: defaultBlock\r\t\"add the last value back again, the given number of times. If we are empty, add (defaultBlock value)\"\r\ttimes = 0 ifTrue: [^self ].\r\tlastIndex := nil. \"flush access cache\"\r\t(runs size=0)\r\t\tifTrue:\r\t\t\t[runs := runs copyWith: times.\r\t\t\tvalues := values copyWith: defaultBlock value]\r\t\tifFalse:\r\t\t\t[runs at: runs size put: runs last+times] "},{"name":"add:","linesOfCode":4,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject. \r\tArrayedCollections cannot respond to this message.\"\r\r\t^ self addLast: newObject"},{"name":",","linesOfCode":28,"sourceCode":", aRunArray \r\t\"Answer a new RunArray that is a concatenation of the receiver and\r\taRunArray.\"\r\r\t| new newRuns |\r\t(aRunArray isMemberOf: RunArray)\r\t\tifFalse: \r\t\t\t[new := self copy.\r\t\t\t\"attempt to be sociable\"\r\t\t\taRunArray do: [:each | new addLast: each].\r\t\t\t^new].\r\truns size = 0 ifTrue: [^aRunArray copy].\r\taRunArray runs size = 0 ifTrue: [^self copy].\r\t(values at: values size) ~= (aRunArray values at: 1)\r\t\tifTrue: [^RunArray\r\t\t\t\t\truns: runs , aRunArray runs\r\t\t\t\t\tvalues: values , aRunArray values].\r\tnewRuns := runs\r\t\t\tcopyReplaceFrom: runs size\r\t\t\tto: runs size\r\t\t\twith: aRunArray runs.\r\tnewRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).\r\t^RunArray\r\t\truns: newRuns\r\t\tvalues: \r\t\t\t(values\r\t\t\t\tcopyReplaceFrom: values size\r\t\t\t\tto: values size\r\t\t\t\twith: aRunArray values)"},{"name":"add:withOccurrences:","linesOfCode":10,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add value as the last element of the receiver, the given number of times\"\r\tanInteger <= 0 ifTrue: [ ^self ].\r\tlastIndex := nil. \"flush access cache\"\r\t(runs size=0 or: [values last ~= newObject])\r\t\tifTrue:\r\t\t\t[runs := runs copyWith: anInteger.\r\t\t\tvalues := values copyWith: newObject]\r\t\tifFalse:\r\t\t\t[runs at: runs size put: runs last + anInteger]"},{"name":"postCopy","linesOfCode":4,"sourceCode":"postCopy\r\tsuper postCopy.\r\truns := runs copy.\r\tvalues := values copy"},{"name":"asBag","linesOfCode":6,"sourceCode":"asBag\r\t| aBag |\r\taBag := Bag new: values size.\r\tself runsAndValuesDo: [:run :value |\r\t\taBag add: value withOccurrences: run].\r\t^aBag"},{"name":"copyUpTo:","linesOfCode":7,"sourceCode":"copyUpTo: anElement \r\t\"Optimized\"\r\r\t| newValues |\r\tnewValues := values copyUpTo: anElement.\r\t^ self class\r\t\truns: (runs copyFrom: 1 to: newValues size)\r\t\tvalues: newValues"},{"name":"detect:ifNone:","linesOfCode":3,"sourceCode":"detect: aBlock ifNone: exceptionBlock \r\t\"Only evaluate once per run\"\r\r\t^values detect: aBlock ifNone: exceptionBlock "},{"name":"remove:ifAbsent:","linesOfCode":15,"sourceCode":"remove: anObject ifAbsent: exceptionBlock\r\t| index mustCoalesce run |\r\tindex := values indexOf: anObject ifAbsent: [^exceptionBlock value].\r\t(run := runs at: index) > 1\r\t\tifTrue: [runs at: index put: run - 1]\r\t\tifFalse:\r\t\t\t[mustCoalesce := index > 1 and: [index < values size and: [(values at: index - 1) = (values at: index + 1)]].\r\t\t\truns := runs copyWithoutIndex: index.\r\t\t\tvalues := values copyWithoutIndex: index.\r\t\t\tmustCoalesce\r\t\t\t\tifTrue:\r\t\t\t\t\t[runs at: index - 1 put: (runs at: index - 1) + (runs at: index).\r\t\t\t\t\truns := runs copyWithoutIndex: index.\r\t\t\t\t\tvalues := values copyWithoutIndex: index]].\r\t^anObject"},{"name":"runLengthAt:","linesOfCode":4,"sourceCode":"runLengthAt: index \r\t\"Answer the length remaining in run beginning at index.\"\r\r\tself at: index \r\t\tsetRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]"},{"name":"allSatisfy:","linesOfCode":3,"sourceCode":"allSatisfy: aBlock \r\t\"Only evaluate once per run\"\r\r\t^values allSatisfy: aBlock"},{"name":"rangeOf:startingAt:","linesOfCode":25,"sourceCode":"rangeOf: attr startingAt: startPos\r\t\"Answer an interval that gives the range of attr at index position startPos. An empty interval with start value startPos is returned when the attribute attr is not present at position startPos. self size > 0 is assumed, it is the responsibility of the caller to test for emptiness of self.\rNote that an attribute may span several adjancent runs. \"\r\r\tself at: startPos \r\t\tsetRunOffsetAndValue: \r\t\t\t[:run :offset :value | \r\t\t\t^(value includes: attr)\r\t\t\t\tifFalse: [startPos to: startPos - 1]\r\t\t\t\tifTrue:\r\t\t\t\t\t[ | firstRelevantPosition lastRelevantPosition idxOfCandidateRun |\r\t\t\t\t\tlastRelevantPosition := startPos - offset + (runs at: run) - 1.\r\t\t\t\t\tfirstRelevantPosition := startPos - offset.\r\t\t\t\t\tidxOfCandidateRun := run + 1.\r\t\t\t\t\t[idxOfCandidateRun <= runs size \r\t\t\t\t\t\t\t and: [(values at: idxOfCandidateRun) includes: attr]]\r\t\t\t\t\t\twhileTrue:\r\t\t\t\t\t\t\t[lastRelevantPosition := lastRelevantPosition + (runs at: idxOfCandidateRun).\r\t\t\t\t\t\t\tidxOfCandidateRun := idxOfCandidateRun + 1]. \r\t\t\t\t\tidxOfCandidateRun := run - 1.\r\t\t\t\t\t[idxOfCandidateRun >= 1 \r\t\t\t\t\t\t\t and: [(values at: idxOfCandidateRun) includes: attr]]\r\t\t\t\t\t\twhileTrue:\r\t\t\t\t\t\t\t[firstRelevantPosition := firstRelevantPosition - (runs at: idxOfCandidateRun).\r\t\t\t\t\t\t\tidxOfCandidateRun := idxOfCandidateRun - 1]. \r \r\t\t\t\t\tfirstRelevantPosition to: lastRelevantPosition]]"},{"name":"mapValues:","linesOfCode":3,"sourceCode":"mapValues: mapBlock\r\t\"NOTE: only meaningful to an entire set of runs\"\r\r\tvalues := values collect: mapBlock"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\truns := Array new.\r\tvalues := Array new"},{"name":"replace:","linesOfCode":4,"sourceCode":"replace: aBlock\r\t\"Beware, the block will be evaluated only once per group of values.\"\r\tvalues := values replace: aBlock.\r\tself coalesce"},{"name":"addFirst:","linesOfCode":9,"sourceCode":"addFirst: value\r\t\"Add value as the first element of the receiver.\"\r\tlastIndex := nil. \"flush access cache\"\r\t(runs size=0 or: [values first ~= value])\r\t\tifTrue:\r\t\t\t[runs := {1}, runs.\r\t\t\tvalues := {value}, values]\r\t\tifFalse:\r\t\t\t[runs at: 1 put: runs first+1]"},{"name":"detectMax:","linesOfCode":3,"sourceCode":"detectMax: aBlock\r\t\"Only evaluate once per run\"\r\r\t^values detectMax: aBlock"},{"name":"withStartStopAndValueDo:","linesOfCode":9,"sourceCode":"withStartStopAndValueDo: aBlock\r\t| start |\r\tstart := 1.\r\truns with: values do:\r\t\t[:len : val | | stop |\r\t\tstop := start + len - 1.\r\t\taBlock value: start value: stop value: val.\r\t\tstart := stop + 1]\r\t\t"},{"name":"values","linesOfCode":3,"sourceCode":"values\r\t\"Answer the values in the receiver.\"\r\r\t^values"},{"name":"repeatLastIfEmpty:","linesOfCode":9,"sourceCode":"repeatLastIfEmpty: defaultBlock\r\t\"add the last value back again. If we are empty, add (defaultBlock value)\"\r\tlastIndex := nil. \"flush access cache\"\r\t(runs size=0)\r\t\tifTrue:[\r\t\t\truns := runs copyWith: 1.\r\t\t\tvalues := values copyWith: defaultBlock value]\r\t\tifFalse:\r\t\t\t[runs at: runs size put: runs last+1]"},{"name":"copyFrom:to:","linesOfCode":13,"sourceCode":"copyFrom: start to: stop\r\t| newRuns run1 run2 offset1 offset2 | \r\tstop < start ifTrue: [^RunArray new].\r\tself at: start setRunOffsetAndValue: [:r :o :value1 | run1 := r. offset1 := o. value1].\r\tself at: stop setRunOffsetAndValue: [:r :o :value2 | run2 := r. offset2 := o. value2].\r\trun1 = run2\r\t\tifTrue: \r\t\t\t[newRuns := Array with: offset2 - offset1 + 1]\r\t\tifFalse: \r\t\t\t[newRuns := runs copyFrom: run1 to: run2.\r\t\t\tnewRuns at: 1 put: (newRuns at: 1) - offset1.\r\t\t\tnewRuns at: newRuns size put: offset2 + 1].\r\t^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)"},{"name":"count:","linesOfCode":9,"sourceCode":"count: aBlock\r\t\"Beware, the block will be evaluated only once per group of values.\"\r\t| count |\r\tcount := 0.\r\tself runsAndValuesDo: [:run :value |\r\t\t(aBlock value: value)\r\t\t\tifTrue:\r\t\t\t\t[count := count + run]].\r\t^count"},{"name":"addLast:","linesOfCode":10,"sourceCode":"addLast: value\r\t\"Add value as the last element of the receiver.\"\r\tlastIndex := nil. \"flush access cache\"\r\t(runs size=0 or: [values last ~= value])\r\t\tifTrue:\r\t\t\t[runs := runs copyWith: 1.\r\t\t\tvalues := values copyWith: value]\r\t\tifFalse:\r\t\t\t[runs at: runs size put: runs last+1].\r\t^value"},{"name":"copyUpThrough:","linesOfCode":7,"sourceCode":"copyUpThrough: anElement\r\t\"Optimized\"\r\r\t| newValues |\r\tnewValues := values copyUpThrough: anElement.\r\t^ self class\r\t\truns: (runs copyFrom: 1 to: newValues size)\r\t\tvalues: newValues"},{"name":"storeOn:","linesOfCode":8,"sourceCode":"storeOn: aStream\r\r\taStream nextPut: $(.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' runs: '.\r\truns storeOn: aStream.\r\taStream nextPutAll: ' values: '.\r\tvalues storeOn: aStream.\r\taStream nextPut: $)"},{"name":"runsFrom:to:do:","linesOfCode":13,"sourceCode":"runsFrom: start to: stop do: aBlock\r\t\"Evaluate aBlock with all existing runs in the range from start to stop\"\r\tstart > stop ifTrue:[^self].\r\tself at: start setRunOffsetAndValue:[:firstRun :offset :firstValue|\r\t\t| run value index |\r\t\trun := firstRun.\r\t\tvalue := firstValue.\r\t\tindex := start + (runs at: run) - offset.\r\t\t[aBlock value: value.\r\t\tindex <= stop] whileTrue:[\r\t\t\trun := run + 1.\r\t\t\tvalue := values at: run.\r\t\t\tindex := index + (runs at: run)]].\r"},{"name":"anySatisfy:","linesOfCode":3,"sourceCode":"anySatisfy: aBlock \r\t\"Only evaluate once per run\"\r\r\t^values anySatisfy: aBlock"},{"name":"at:put:","linesOfCode":29,"sourceCode":"at: index put: aValue\r\t\"Set an element of the RunArray\"\r\r\t| runIndex offsetInRun lastValue runLength runReplacement valueReplacement iStart iStop |\r\tindex isInteger\r\t\tifFalse: [ self errorNonIntegerIndex ].\r\t(index between: 1 and: self size)\r\t\tifFalse: [ self errorSubscriptBounds: index ].\r\tself\r\t\tat: index\r\t\tsetRunOffsetAndValue: [ :run :offset :value | \r\t\t\trunIndex := run.\r\t\t\toffsetInRun := offset.\r\t\t\tlastValue := value ].\r\taValue = lastValue\r\t\tifTrue: [ ^ aValue ].\r\trunLength := runs at: runIndex.\r\trunReplacement := Array with: offsetInRun with: 1 with: runLength - offsetInRun - 1.\r\tvalueReplacement := Array with: lastValue with: aValue with: lastValue.\r\tiStart := offsetInRun = 0\r\t\tifTrue: [ 2 ]\r\t\tifFalse: [ 1 ].\r\tiStop := offsetInRun = (runLength - 1)\r\t\tifTrue: [ 2 ]\r\t\tifFalse: [ 3 ].\r\tself\r\t\tsetRuns: (runs copyReplaceFrom: runIndex to: runIndex with: (runReplacement copyFrom: iStart to: iStop))\r\t\tsetValues: (values copyReplaceFrom: runIndex to: runIndex with: (valueReplacement copyFrom: iStart to: iStop)).\r\tself coalesce.\r\t^ aValue"},{"name":"select:","linesOfCode":11,"sourceCode":"select: aBlock\r\t\"Beware, the block will be evaluated only once per group of values.\"\r\t| newRuns newValues |\r\tnewRuns := (Array new: runs size) writeStream.\r\tnewValues := (Array new: values size) writeStream.\r\tself runsAndValuesDo: [:run :value |\r\t\t(aBlock value: value)\r\t\t\tifTrue:\r\t\t\t\t[newRuns add: run.\r\t\t\t\tnewValues add: value]].\r\t^(self class runs: newRuns contents values: newValues contents) coalesce"}],"meta":{"name":"RunArray class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: aSize\r\t^ self new: aSize withAll: nil"},{"name":"new:withAll:","linesOfCode":5,"sourceCode":"new: size withAll: value \r\t\"Answer a new instance of me, whose every element is equal to the\r\targument, value.\"\r\r\tsize = 0 ifTrue: [^self new].\r\t^self runs: (Array with: size) values: (Array with: value)"},{"name":"scanFrom:","linesOfCode":36,"sourceCode":"scanFrom: strm\r\t\"Read the style section of a fileOut or sources file.\tnextChunk has already been done. We need to return a RunArray of TextAttributes of various kinds. These are written by the implementors of writeScanOn:\"\r\t| runs values attrList char |\r\t(strm peekFor: $( ) ifFalse: [^ nil].\r\truns := OrderedCollection new.\r\t[strm skipSeparators.\r\t strm peekFor: $)] whileFalse: \r\t\t[runs add: (Number readFrom: strm)].\r\tvalues := OrderedCollection new. \"Value array\"\r\tattrList := OrderedCollection new. \"Attributes list\"\r\t[(char := strm next) == nil] whileFalse: [\r\t\tchar == $, ifTrue: [values add: attrList asArray. attrList := OrderedCollection new].\r\t\tchar == $a ifTrue: [attrList add: \r\t\t\t(TextAlignment new alignment: (Integer readFrom: strm ifFail: [0]))].\r\t\tchar == $f ifTrue: [attrList add: \r\t\t\t(TextFontChange new fontNumber: (Integer readFrom: strm ifFail: [0]))].\r\t\tchar == $F ifTrue: [attrList add: (TextFontReference toFont: \r\t\t\t(self environment at: #StrikeFont ifPresent: [:sf | sf familyName: (strm upTo: $#) size: (Integer readFrom: strm ifFail: [0])]))].\r\t\tchar == $b ifTrue: [attrList add: (TextEmphasis bold)].\r\t\tchar == $i ifTrue: [attrList add: (TextEmphasis italic)].\r\t\tchar == $u ifTrue: [attrList add: (TextEmphasis underlined)].\r\t\tchar == $= ifTrue: [attrList add: (TextEmphasis struckOut)].\r\t\tchar == $n ifTrue: [attrList add: (TextEmphasis normal)].\r\t\tchar == $- ifTrue: [attrList add: (TextKern kern: -1)].\r\t\tchar == $+ ifTrue: [attrList add: (TextKern kern: 1)].\r\t\tchar == $c ifTrue: [attrList add: (TextColor scanFrom: strm)]. \"color\"\r\t\tchar == $L ifTrue: [attrList add: (TextLink scanFrom: strm)]. \"L not look like 1\"\r\t\tchar == $R ifTrue: [attrList add: (TextURL scanFrom: strm)].\r\t\t\t\t\"R capitalized so it can follow a number\"\r\t\tchar == $P ifTrue: [attrList add: (TextPrintIt scanFrom: strm)].\r\t\tchar == $d ifTrue: [attrList add: (TextDoIt scanFrom: strm)].\r\t\t\"space, cr do nothing\"\r\t\t].\r\tvalues add: attrList asArray.\r\t^ self runs: runs asArray values: (values copyFrom: 1 to: runs size) asArray\r\"\rRunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')\r\""},{"name":"runs:values:","linesOfCode":7,"sourceCode":"runs: newRuns values: newValues \r\t\"Answer an instance of me with runs and values specified by the \r\targuments.\"\r\r\t| instance |\r\tinstance := self basicNew.\r\tinstance setRuns: newRuns setValues: newValues.\r\t^instance"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\r\t^ self new\r\t\tfromSton: stonReader;\r\t\tyourself"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\r\t^self runs: Array new values: Array new"},{"name":"newFrom:","linesOfCode":25,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t| runs values lastRun lastValue |\r\truns := (Array new: aCollection size // 2) writeStream.\r\tvalues := (Array new: aCollection size // 2) writeStream.\r\tlastRun := 0.\r\tlastValue := Object new.\r\taCollection do: [:x | \r\t\tlastValue = x\r\t\t\tifTrue: [lastRun := lastRun + 1]\r\t\t\tifFalse:\r\t\t\t\t[lastRun > 0\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[runs nextPut: lastRun.\r\t\t\t\t\t\tvalues nextPut: lastValue].\r\t\t\t\tlastRun := 1.\r\t\t\t\tlastValue := x]].\r\tlastRun > 0\r\t\tifTrue:\r\t\t\t[runs nextPut: lastRun.\r\t\t\tvalues nextPut: lastValue].\r\t^self basicNew setRuns: runs contents setValues: values contents\r\r\"\tRunArray newFrom: {1. 2. 2. 3}\r\t{1. $a. $a. 3} as: RunArray\r\t({1. $a. $a. 3} as: RunArray) values\r\""},{"name":"readFrom:","linesOfCode":11,"sourceCode":"readFrom: aStream\r\t\"Answer an instance of me as described on the stream, aStream.\"\r\r\t| size runs values |\r\tsize := aStream nextWord.\r\truns := Array new: size.\r\tvalues := Array new: size.\r\t1 to: size do:\r\t\t[:x |\r\t\truns at: x put: aStream nextWord.\r\t\tvalues at: x put: aStream nextWord].\r\t^ self runs: runs values: values"}],"meta":null}},{"name":"SGPUManagedDataArray","instanceVariables":[{"name":"compilationEnvironment"},{"name":"size"},{"name":"mbndType"},{"name":"cpuData"},{"name":"currentDataLocation"},{"name":"gpuBufferHandle"},{"name":"generator"}],"methods":[{"name":"ensureInGPU","linesOfCode":3,"sourceCode":"ensureInGPU\r\tself isInGPU ifTrue: [ ^ self ].\r\tSGPUExecutionDriver current ensureManagedDataArrayIsInGPU: self"},{"name":"binaryReductionWith:","linesOfCode":4,"sourceCode":"binaryReductionWith: aBinaryBlock\r\t| neutralValue |\r\tneutralValue := mbndType defaultValue value.\r\t^ self binaryReductionWith: aBinaryBlock neutralValue: neutralValue"},{"name":"generator","linesOfCode":2,"sourceCode":"generator\r\t^ generator"},{"name":"generateDataInGPU","linesOfCode":4,"sourceCode":"generateDataInGPU\r\tself assert: generator isNotNil.\r\tgenerator generateDataInGPUManagedBuffer: self.\r\tgenerator := nil."},{"name":"ensureInCPU","linesOfCode":4,"sourceCode":"ensureInCPU\r\tself isInCPU ifTrue: [ ^ self ].\r\tself isNotYetGenerated ifTrue: [ ^ self generateDataInCPU ].\r\tSGPUExecutionDriver current ensureManagedDataArrayIsInCPU: self"},{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\tself shouldNotImplement"},{"name":"currentDataLocation","linesOfCode":2,"sourceCode":"currentDataLocation\r\t^ currentDataLocation"},{"name":"markOnlyValidInCPU","linesOfCode":2,"sourceCode":"markOnlyValidInCPU\r\tcurrentDataLocation := #cpu."},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^ self cpuData asFloatArray"},{"name":"collect:","linesOfCode":17,"sourceCode":"collect: aBlock\r\t| shaderStageCode resultBuffer |\r\taBlock isSGPUBlockClosure ifFalse: [ ^ super collect: aBlock ].\r\t\r\tshaderStageCode := aBlock asCollectionMapShaderStageCode.\r\tself ensureInGPU.\r\r\tresultBuffer := SGPUCompilationEnvironment current\t\r\t\tconstructArrayOfType: aBlock returnType withSize: self size.\r\tSGPUExecutionDriver current\r\t\tenqueueComputationWithInputBuffers: { self } outputBuffers: { resultBuffer }\r\t\tpushConstants: (IntegerArray with: size)\r\t\tcomputeShaderStage: shaderStageCode globalSize: size\r\t\tcpuFallbackWith: [\r\t\t\t1 to: size do: [ :i |\r\t\t\t\tresultBuffer at: i put: (aBlock value: (self at: i))\r\t\t\t]\r\t\t].\r\t\r\t^ resultBuffer"},{"name":"isNotYetGenerated","linesOfCode":2,"sourceCode":"isNotYetGenerated\r\t^ currentDataLocation == #notYetGenerated"},{"name":"compilationEnvironment:","linesOfCode":2,"sourceCode":"compilationEnvironment: anObject\r\tcompilationEnvironment := anObject"},{"name":"asArray","linesOfCode":2,"sourceCode":"asArray\r\t^ self cpuData asArray"},{"name":"binaryReductionWith:neutralValue:","linesOfCode":28,"sourceCode":"binaryReductionWith: aBinaryBlock neutralValue: neutralValue\r\t| shaderStageCode stageReductionSize currentReductionSize nextReductionSize pingBuffer pongBuffer tempBuffer quickConstants neutralValueOffset |\r\taBinaryBlock isSGPUBlockClosure ifFalse: [ self halt ].\r\t\r\tshaderStageCode := aBinaryBlock asBinaryReductionShaderStageCode.\r\tself ensureInGPU.\r\t\r\tstageReductionSize := 2 * shaderStageCode localBlockSize.\r\t\r\tcurrentReductionSize := self size.\r\tpingBuffer := self.\r\tpongBuffer := nil.\r\tneutralValueOffset := 4 alignedTo: mbndType instanceAlignment.\r\tquickConstants := ByteArray new: neutralValueOffset + mbndType instanceSize.\r\tcpuData elementType write: neutralValue intoPointer: (SLVMInternalObjectPointer object: quickConstants offset: neutralValueOffset).\r\t\r\t[currentReductionSize > 1] whileTrue: [ \r\t\tnextReductionSize := (currentReductionSize + stageReductionSize - 1) // stageReductionSize max: 1.\r\r\t\t(pongBuffer isNil or: [nextReductionSize = 1]) ifTrue: [\r\t\t\tpongBuffer := compilationEnvironment constructArrayOfType: aBinaryBlock returnType withSize: nextReductionSize\r\t\t].\r\t\r\t\t\"Enqueue the computation\"\r\t\tself enqueueBinaryReductionFrom: currentReductionSize buffer: pingBuffer to: nextReductionSize buffer: pongBuffer\r\t\t\tshaderStage: shaderStageCode quickConstants: quickConstants.\r\t\t\r\t\t\"Swap the ping-pong buffers\"\r\t\ttempBuffer := pingBuffer ~~ self ifTrue: [pingBuffer] ifFalse: [nil].\r\t\tpingBuffer := pongBuffer.\r\t\tpongBuffer := tempBuffer.\r\t\tcurrentReductionSize := nextReductionSize\r\t].\r\r\t^ pingBuffer"},{"name":"gpuBufferHandle","linesOfCode":2,"sourceCode":"gpuBufferHandle\r\t^ gpuBufferHandle"},{"name":"isInGPU","linesOfCode":2,"sourceCode":"isInGPU\r\t^ #(both gpu) includes: currentDataLocation"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\t^ Array"},{"name":"cpuData","linesOfCode":3,"sourceCode":"cpuData\r\tself ensureInCPU.\r\t^ cpuData"},{"name":"markOnlyValidInGPU","linesOfCode":2,"sourceCode":"markOnlyValidInGPU\r\tcurrentDataLocation := #gpu."},{"name":"rawCpuData","linesOfCode":2,"sourceCode":"rawCpuData\r\t^ cpuData"},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^ cpuData rawDataSize"},{"name":"mbndType","linesOfCode":2,"sourceCode":"mbndType\r\t^ mbndType"},{"name":"enqueueBinaryReductionFrom:buffer:to:buffer:shaderStage:quickConstants:","linesOfCode":10,"sourceCode":"enqueueBinaryReductionFrom: sourceSize buffer: sourceBuffer to: targetSize buffer: targetBuffer\rshaderStage: shaderStageCode quickConstants: quickConstants\r\tquickConstants unsignedLongAt: 1 put: sourceSize.\r\t\r\tSGPUExecutionDriver current\r\t\tenqueueComputationWithInputBuffers: { sourceBuffer } outputBuffers: { targetBuffer }\r\t\tpushConstants: quickConstants\r\t\tcomputeShaderStage: shaderStageCode globalSize: (sourceSize + 1) // 2\r\t\tcpuFallbackWith: [\r\t\t\tself halt\r\t\t]."},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ size"},{"name":"initializeForType:withCPUData:","linesOfCode":5,"sourceCode":"initializeForType: aMbndType withCPUData: theCpuData\r\tmbndType := aMbndType.\r\tcpuData := theCpuData.\r\tcurrentDataLocation := #cpu.\r\tsize := theCpuData size."},{"name":"compilationEnvironment","linesOfCode":2,"sourceCode":"compilationEnvironment\r\t^ compilationEnvironment"},{"name":"isInCPU","linesOfCode":2,"sourceCode":"isInCPU\r\t^ #(both cpu) includes: currentDataLocation"},{"name":"gpuBufferHandle:","linesOfCode":2,"sourceCode":"gpuBufferHandle: anObject\r\tgpuBufferHandle := anObject"},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\t^ self cpuData at: index"},{"name":"initializeForType:withGenerator:cpuAllocationData:","linesOfCode":6,"sourceCode":"initializeForType: aMbndType withGenerator: theGenerator cpuAllocationData: theCpuData\r\tmbndType := aMbndType.\r\tcpuData := theCpuData.\r\tcurrentDataLocation := #notYetGenerated.\r\tsize := theCpuData size.\r\tgenerator := theGenerator."},{"name":"markSynchronizedCopies","linesOfCode":3,"sourceCode":"markSynchronizedCopies\r\tcurrentDataLocation := #both.\r\tgenerator := nil."},{"name":"generateDataInCPU","linesOfCode":5,"sourceCode":"generateDataInCPU\r\tself assert: generator isNotNil.\r\tself markOnlyValidInCPU.\r\t\r\tgenerator generateDataWithSize: self size intoCPUBuffer: cpuData.\r\t\r\tgenerator := nil."},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: value\r\t^ self cpuData at: index put: value"}],"meta":{"name":"SGPUManagedDataArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityBag","instanceVariables":[],"methods":[{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^contents keys asIdentitySet"}],"meta":{"name":"IdentityBag class","instanceVariables":[],"methods":[{"name":"contentsClass","linesOfCode":2,"sourceCode":"contentsClass\r\t^IdentityDictionary"}],"meta":null}},{"name":"OrderedIdentityDictionary","instanceVariables":[],"methods":[{"name":"indexOfKey:ifAbsent:","linesOfCode":2,"sourceCode":"indexOfKey: aKey ifAbsent: aBlock\r\t^ self identityIndexOfKey: aKey ifAbsent: aBlock"},{"name":"orderedKeysIndexOf:","linesOfCode":2,"sourceCode":"orderedKeysIndexOf: aKey\r\t^ orderedKeys identityIndexOf: aKey"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\t^ IdentityDictionary"}],"meta":{"name":"OrderedIdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LLVMOrderedDictionary","instanceVariables":[],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: aKey ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t^ dictionary\r\t\tat: aKey\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [self at: aKey put: anAbsentBlock value]"},{"name":"valuesDo:","linesOfCode":4,"sourceCode":"valuesDo: aBlock\r\tself keysDo: [ :key |\r\t\tkey ifNotNil: [ aBlock value: (self at: key) ]\r\t]"}],"meta":{"name":"LLVMOrderedDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SmallIdentityDictionary","instanceVariables":[],"methods":[{"name":"findIndexForKey:","linesOfCode":2,"sourceCode":"findIndexForKey: aKey \r\t^ keys identityIndexOf: aKey"},{"name":"setClass","linesOfCode":2,"sourceCode":"setClass\r\t^ IdentitySet"}],"meta":{"name":"SmallIdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FLLargeIdentityDictionary","instanceVariables":[{"name":"keys"},{"name":"values"}],"methods":[{"name":"at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: key ifAbsentPut: aBlock \r\t\"Return the value at the given key. \r\tIf key is not included in the receiver store the result \r\tof evaluating aBlock as new value.\"\r\r\t^ self at: key ifAbsent: [self at: key put: aBlock value]"},{"name":"keysDo:","linesOfCode":7,"sourceCode":"keysDo: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: 4096 do: [ :arrayIndex |\r\t\t| keyArray |\r\t\tkeyArray := keys at: arrayIndex.\r\t\t1 to: (tallies at: arrayIndex) do: [ :index |\r\t\t\taBlock value: (keyArray at: index) ] ]"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifPresent: presentBlock ifAbsent: absentBlock\r\r\t| hash |\r\t(keys at: (hash := key largeIdentityHash + 1)) ifNotNil: [ :keyList | \r\t\t1 to: (tallies at: hash) do: [ :index |\r\t\t\t(keyList at: index) == key ifTrue: [\r\t\t\t\t^ presentBlock cull: ((values at: hash) at: index) ] ] ].\r\t^absentBlock value"},{"name":"valuesDo:","linesOfCode":7,"sourceCode":"valuesDo: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: 4096 do: [ :arrayIndex |\r\t\t| valueArray |\r\t\tvalueArray := values at: arrayIndex.\r\t\t1 to: (tallies at: arrayIndex) do: [ :index |\r\t\t\taBlock value: (valueArray at: index) ] ]"},{"name":"includesKey:","linesOfCode":11,"sourceCode":"includesKey: key\r\r\t| hash |\r\t^(keys at: (hash := key largeIdentityHash \\\\ 4096 + 1))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :keyList | \r\t\t\tkey \r\t\t\t\tifNotNil: [ keyList fuelPointsTo: key ]\r\t\t\t\tifNil: [\r\t\t\t\t\t1 to: (tallies at: hash) do: [ :index |\r\t\t\t\t\t\t(keyList at: index) == key ifTrue: [ ^true ] ].\r\t\t\t\t\tfalse ] ]"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\r\tsuper initialize.\r\tkeys := Array new: 4096.\r\tvalues := Array new: 4096"},{"name":"keys","linesOfCode":3,"sourceCode":"keys\r\r\t^Array new: tally streamContents: [ :stream |\r\t\tself keysDo: [ :key | stream nextPut: key ] ]"},{"name":"keysAndValuesDo:","linesOfCode":10,"sourceCode":"keysAndValuesDo: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: 4096 do: [ :arrayIndex |\r\t\t| keyArray valueArray |\r\t\tkeyArray := keys at: arrayIndex.\r\t\tvalueArray := values at: arrayIndex.\r\t\t1 to: (tallies at: arrayIndex) do: [ :index |\r\t\t\taBlock\r\t\t\t\tvalue: (keyArray at: index)\r\t\t\t\tvalue: (valueArray at: index) ] ]"},{"name":"values","linesOfCode":3,"sourceCode":"values\r\r\t^Array new: tally streamContents: [ :stream |\r\t\tself valuesDo: [ :value | stream nextPut: value ] ]"},{"name":"postCopy","linesOfCode":8,"sourceCode":"postCopy\r\r\tsuper postCopy.\r\tkeys := keys copy.\r\tvalues := values copy.\r\t1 to: 4096 do: [ :index |\r\t\t(keys at: index) ifNotNil: [ :list |\r\t\t\tkeys at: index put: list copy.\r\t\t\tvalues at: index put: (values at: index) copy ] ]"},{"name":"at:","linesOfCode":7,"sourceCode":"at: key\r\r\t| hash |\r\t(keys at: (hash := key largeIdentityHash \\\\ 4096 + 1)) ifNotNil: [ :keyList | \r\t\t1 to: (tallies at: hash) do: [ :index |\r\t\t\t(keyList at: index) == key ifTrue: [\r\t\t\t\t^(values at: hash) at: index ] ] ].\r\tself errorKeyNotFound: key"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\r\tKeyNotFound signalFor: aKey"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\r\t^self valuesDo: aBlock"},{"name":"removeKey:ifAbsent:","linesOfCode":33,"sourceCode":"removeKey: key ifAbsent: aBlock\r\r\t| hash |\r\t(keys at: (hash := key largeIdentityHash \\\\ 4096 + 1)) ifNotNil: [ :keyList |\r\t\t| size |\r\t\t1 to: (size := tallies at: hash) do: [ :index |\r\t\t\t(keyList at: index) == key ifTrue: [\r\t\t\t\t| valueList |\r\t\t\t\tkeyList\r\t\t\t\t\tat: index put: (keyList at: size);\r\t\t\t\t\tat: size put: nil.\r\t\t\t\t(valueList := values at: hash)\r\t\t\t\t\tat: index put: (valueList at: size);\r\t\t\t\t\tat: size put: nil.\r\t\t\t\t(size := size - 1) < (keyList size // 4) ifTrue: [\r\t\t\t\t\t| newList |\r\t\t\t\t\tnewList := Array new: size * 2.\r\t\t\t\t\tnewList\r\t\t\t\t\t\treplaceFrom: 1\r\t\t\t\t\t\tto: size\r\t\t\t\t\t\twith: keyList\r\t\t\t\t\t\tstartingAt: 1.\r\t\t\t\t\tkeys at: hash put: newList.\r\t\t\t\t\tnewList := Array new: size * 2.\r\t\t\t\t\tnewList\r\t\t\t\t\t\treplaceFrom: 1\r\t\t\t\t\t\tto: size\r\t\t\t\t\t\twith: valueList\r\t\t\t\t\t\tstartingAt: 1.\r\t\t\t\t\tvalues at: hash put: newList ].\r\t\t\t\ttallies at: hash put: size.\r\t\t\t\ttally := tally - 1.\r\t\t\t\t^key ] ] ].\r\t^aBlock value"},{"name":"at:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifAbsent: aBlock\r\r\t| hash |\r\t(keys at: (hash := key largeIdentityHash \\\\ 4096 + 1)) ifNotNil: [ :keyList | \r\t\t1 to: (tallies at: hash) do: [ :index |\r\t\t\t(keyList at: index) == key ifTrue: [\r\t\t\t\t^(values at: hash) at: index ] ] ].\r\t^aBlock value"},{"name":"at:put:","linesOfCode":36,"sourceCode":"at: key put: value\r\r\t| hash |\r\t(keys at: (hash := key largeIdentityHash \\\\ 4096 + 1))\r\t\tifNil: [ \r\t\t\tkeys at: hash put: (Array with: key).\r\t\t\tvalues at: hash put: (Array with: value).\r\t\t\ttallies at: hash put: 1.\r\t\t\ttally := tally + 1 ]\r\t\tifNotNil: [ :keyList | \r\t\t\t| newIndex |\r\t\t\t1 to: (tallies at: hash) do: [ :index |\r\t\t\t\t(keyList at: index) == key ifTrue: [\r\t\t\t\t\t^(values at: hash) at: index put: value ] ].\r\t\t\ttally := tally + 1.\r\t\t\tkeyList size < (newIndex := (tallies at: hash) + 1)\r\t\t\t\tifFalse: [ \r\t\t\t\t\tkeyList at: newIndex put: key.\r\t\t\t\t\t(values at: hash) at: newIndex put: value ]\r\t\t\t\tifTrue: [\r\t\t\t\t\t| newList |\r\t\t\t\t\t(newList := Array new: keyList size * 2)\r\t\t\t\t\t\treplaceFrom: 1 \r\t\t\t\t\t\tto: keyList size\r\t\t\t\t\t\twith: keyList\r\t\t\t\t\t\tstartingAt: 1;\r\t\t\t\t\t\tat: newIndex put: key.\r\t\t\t\t\tkeys at: hash put: newList.\r\t\t\t\t\t(newList := Array new: keyList size * 2)\r\t\t\t\t\t\treplaceFrom: 1 \r\t\t\t\t\t\tto: keyList size\r\t\t\t\t\t\twith: (values at: hash)\r\t\t\t\t\t\tstartingAt: 1;\r\t\t\t\t\t\tat: newIndex put: value.\r\t\t\t\t\tvalues at: hash put: newList ].\r\t\t\ttallies at: hash put: newIndex ].\r\t^value"}],"meta":{"name":"FLLargeIdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FLLargeIdentitySet","instanceVariables":[{"name":"array"},{"name":"includesNil"}],"methods":[{"name":"postCopy","linesOfCode":6,"sourceCode":"postCopy\r\r\tsuper postCopy.\r\tarray := array copy.\r\t1 to: 4096 do: [ :index |\r\t\t(array at: index) ifNotNil: [ :list |\r\t\t\tarray at: index put: list copy ] ]"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":32,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\r\t| hash |\r\tanObject ifNil: [ \r\t\tincludesNil ifFalse: [\r\t\t\tincludesNil := true.\r\t\t\ttally := tally + 1 ].\r\t\t^anObject ].\r\t(array at: (hash := anObject largeIdentityHash \\\\ 4096 + 1))\r\t\tifNil: [ \r\t\t\tarray at: hash put: (Array with: anObject).\r\t\t\ttallies at: hash put: 1.\r\t\t\ttally := tally + 1 ]\r\t\tifNotNil: [ :list | \r\t\t\t(list fuelPointsTo: anObject) \r\t\t\tifTrue: [ aBlock value]\r\t\t\tifFalse: [\r\t\t\t\t| newIndex |\r\t\t\t\ttally := tally + 1.\r\t\t\t\tlist size < (newIndex := (tallies at: hash) + 1)\r\t\t\t\t\tifFalse: [ list at: newIndex put: anObject ]\r\t\t\t\t\tifTrue: [\r\t\t\t\t\t\t| newList |\r\t\t\t\t\t\tnewList := Array new: list size * 2.\r\t\t\t\t\t\tnewList\r\t\t\t\t\t\t\treplaceFrom: 1 \r\t\t\t\t\t\t\tto: list size\r\t\t\t\t\t\t\twith: list\r\t\t\t\t\t\t\tstartingAt: 1;\r\t\t\t\t\t\t\tat: newIndex put: anObject.\r\t\t\t\t\t\tarray at: hash put: newList ].\r\t\t\t\ttallies at: hash put: newIndex ] ].\r\t^anObject"},{"name":"add:","linesOfCode":30,"sourceCode":"add: anObject\r\r\t| hash |\r\tanObject ifNil: [ \r\t\tincludesNil ifFalse: [\r\t\t\tincludesNil := true.\r\t\t\ttally := tally + 1 ].\r\t\t^anObject ].\r\t(array at: (hash := anObject largeIdentityHash \\\\ 4096 + 1))\r\t\tifNil: [ \r\t\t\tarray at: hash put: (Array with: anObject).\r\t\t\ttallies at: hash put: 1.\r\t\t\ttally := tally + 1 ]\r\t\tifNotNil: [ :list | \r\t\t\t(list fuelPointsTo: anObject) ifFalse: [\r\t\t\t\t| newIndex |\r\t\t\t\ttally := tally + 1.\r\t\t\t\tlist size < (newIndex := (tallies at: hash) + 1)\r\t\t\t\t\tifFalse: [ list at: newIndex put: anObject ]\r\t\t\t\t\tifTrue: [\r\t\t\t\t\t\t| newList |\r\t\t\t\t\t\tnewList := Array new: list size * 2.\r\t\t\t\t\t\tnewList\r\t\t\t\t\t\t\treplaceFrom: 1 \r\t\t\t\t\t\t\tto: list size\r\t\t\t\t\t\t\twith: list\r\t\t\t\t\t\t\tstartingAt: 1;\r\t\t\t\t\t\t\tat: newIndex put: anObject.\r\t\t\t\t\t\tarray at: hash put: newList ].\r\t\t\t\ttallies at: hash put: newIndex ] ].\r\t^anObject"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: anObject\r\r\tanObject ifNil: [ ^includesNil ].\r\t^(array at: (anObject largeIdentityHash \\\\ 4096 + 1))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :list | list fuelPointsTo: anObject ]"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\r\tsuper initialize.\r\tarray := Array new: 4096.\r\tincludesNil := false"},{"name":"do:","linesOfCode":8,"sourceCode":"do: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\tincludesNil ifTrue: [ aBlock value: nil ].\r\t1 to: 4096 do: [ :arrayIndex |\r\t\t| subArray |\r\t\tsubArray := array at: arrayIndex.\r\t\t1 to: (tallies at: arrayIndex) do: [ :index |\r\t\t\taBlock value: (subArray at: index) ] ]"},{"name":"remove:ifAbsent:","linesOfCode":28,"sourceCode":"remove: anObject ifAbsent: aBlock\r\r\t| list hash size |\r\tanObject ifNil: [\r\t\tincludesNil ifTrue: [\r\t\t\tincludesNil := false.\r\t\t\ttally := tally - 1.\r\t\t\t^anObject ].\r\t\t^aBlock value ].\r\tlist := (array at: (hash := anObject largeIdentityHash \\\\ 4096 + 1)) ifNil: [ ^aBlock value ].\r\t(list fuelPointsTo: anObject) ifFalse: [ ^aBlock value ].\r\t1 to: (size := tallies at: hash) do: [ :index |\r\t\t(list at: index) == anObject \tifTrue: [\r\t\t\tlist\r\t\t\t\tat: index put: (list at: size);\r\t\t\t\tat: size put: nil.\r\t\t\t(size := size - 1) < (list size // 4) ifTrue: [\r\t\t\t\t| newList |\r\t\t\t\tnewList := Array new: size * 2.\r\t\t\t\tnewList\r\t\t\t\t\treplaceFrom: 1\r\t\t\t\t\tto: size\r\t\t\t\t\twith: list\r\t\t\t\t\tstartingAt: 1.\r\t\t\t\tarray at: hash put: newList ].\r\t\t\ttallies at: hash put: size.\r\t\t\ttally := tally - 1.\r\t\t\t^anObject ] ].\r\t^aBlock value"}],"meta":{"name":"FLLargeIdentitySet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SLVMOrderedDictionary","instanceVariables":[],"methods":[{"name":"keysDo:","linesOfCode":2,"sourceCode":"keysDo: aBlock\r\troot ifNotNil: [ root do: [:association | aBlock value: association key] ]"},{"name":"valuesDo:","linesOfCode":2,"sourceCode":"valuesDo: aBlock\r\troot ifNotNil: [ root do: [:association | aBlock value: association value] ]"},{"name":"includesKey:","linesOfCode":2,"sourceCode":"includesKey: aValue\r\t^ (self searchKey: aValue from: root) isNotNil"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\troot := self insertKey: anAssociation key value: anAssociation from: root.\r\troot color: Black"},{"name":"first","linesOfCode":2,"sourceCode":"first\r\t^ self firstNode ifNotNil: [ :node | node value ]"},{"name":"last","linesOfCode":2,"sourceCode":"last\r\t^ self lastNode ifNotNil: [ :node | node value ]"},{"name":"at:","linesOfCode":2,"sourceCode":"at: key\r\t^ self at: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\tKeyNotFound signalFor: aKey"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\troot ifNotNil: [ root do: [:association | aBlock value: association] ]"},{"name":"removeKey:ifAbsent:","linesOfCode":9,"sourceCode":"removeKey: key ifAbsent: ifAbsentBlock\r\t| oldValue |\r\t^ (self searchKey: key from: root) ifNil: [\r\t\tifAbsentBlock value\r\t] ifNotNil: [ :oldNode |\r\t\toldValue := oldNode value value.\r\t\tself deleteKey: key.\r\t\t^ oldValue\r\t]"},{"name":"at:ifAbsent:","linesOfCode":4,"sourceCode":"at: key ifAbsent: ifAbsentBlock\r\t| node |\r\tnode := self searchKey: key from: root.\r\t^ node ifNil: ifAbsentBlock value ifNotNil: [ node value value ]"},{"name":"nodeSpecies","linesOfCode":2,"sourceCode":"nodeSpecies\r\t^ SLVMRedBlackTreeAssociationNode"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: oldObject ifAbsent: ifAbsentBlock\r\t(self searchKey: oldObject key from: root) ifNil: [\r\t\t^ ifAbsentBlock value\r\t].\r\r\tself deleteKey: oldObject key.\r\t^ oldObject"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: aKey put: aValue\r\tself add: aKey -> aValue.\r\t^ aValue"},{"name":"removeKey:","linesOfCode":4,"sourceCode":"removeKey: key \r\t\"Remove key from the receiver.\r\tIf key is not in the receiver, notify an error.\"\r\r\t^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]"}],"meta":{"name":"SLVMOrderedDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SLVMOrderedSet","instanceVariables":[],"methods":[{"name":"includes:","linesOfCode":2,"sourceCode":"includes: aValue\r\t^ (self searchKey: aValue from: root) isNotNil"},{"name":"first","linesOfCode":2,"sourceCode":"first\r\t^ self firstNode ifNotNil: [ :node | node value ]"},{"name":"last","linesOfCode":2,"sourceCode":"last\r\t^ self lastNode ifNotNil: [ :node | node value ]"}],"meta":{"name":"SLVMOrderedSet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WDCQuadTree","instanceVariables":[{"name":"size"},{"name":"root"},{"name":"nodeSplitCountThreshold"}],"methods":[{"name":"isEmpty","linesOfCode":2,"sourceCode":"isEmpty\r\t^ size = 0"},{"name":"root","linesOfCode":2,"sourceCode":"root\r\t^ root"},{"name":"addSpatialSubdivisionDataStructureElement:","linesOfCode":6,"sourceCode":"addSpatialSubdivisionDataStructureElement: anElement\r\troot ifNil: [\r\t\tself createRootNodeWithBoundingBox: (self boundingBoxForInitialElement: anElement)\r\t].\r\r\troot addElement: anElement.\r\tsize := size + 1."},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ size"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tsuper initialize.\r\tsize := 0.\r\tnodeSplitCountThreshold := 16."},{"name":"maxNodeDepth","linesOfCode":2,"sourceCode":"maxNodeDepth\r\t^ 10"},{"name":"nodeSplitCountThreshold:","linesOfCode":2,"sourceCode":"nodeSplitCountThreshold: anObject\r\tnodeSplitCountThreshold := anObject"},{"name":"boundingBoxForInitialElement:","linesOfCode":12,"sourceCode":"boundingBoxForInitialElement: anElement\r\t| center halfExtent box |\r\tcenter := Float32x3 zeros.\r\thalfExtent := Float32x3 ones * 1000.0.\r\tanElement isSpatialVolumeElement ifTrue: [\r\t\tbox := anElement spatialElementBoundingBox.\r\t\tcenter := box center.\r\t\thalfExtent := box halfExtent *1000.0\r\t] ifFalse: [\r\t\tcenter := anElement spatialElementCenter.\r\t].\r\r\t^ BoxF32 center: center halfExtent: halfExtent"},{"name":"allElementsIntersectingBox:do:","linesOfCode":6,"sourceCode":"allElementsIntersectingBox: box do: aBlock\r\troot ifNotNil: [\r\t\troot allElementsIntersectingBox: box do: [ :element |\r\t\t\taBlock value: element spatialElementValue\r\t\t]\r\t]"},{"name":"createRootNodeWithBoundingBox:","linesOfCode":6,"sourceCode":"createRootNodeWithBoundingBox: boundingBox\r\troot := self nodeClass new\r\t\t\tmaxDepth: self maxNodeDepth;\r\t\t\tboundingBox: boundingBox;\r\t\t\ttree: self;\r\t\t\tyourself"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\troot ifNotNil: [\r\t\troot do: [ :element |\r\t\t\taBlock value: element spatialElementValue\r\t\t]\r\t]"},{"name":"nodeClass","linesOfCode":2,"sourceCode":"nodeClass\r\t^ WDCQuadTreeNode"},{"name":"nodeSplitCountThreshold","linesOfCode":2,"sourceCode":"nodeSplitCountThreshold\r\t^ nodeSplitCountThreshold"},{"name":"allElementsInsideOfBox:do:","linesOfCode":6,"sourceCode":"allElementsInsideOfBox: box do: aBlock\r\troot ifNotNil: [\r\t\troot allElementsInsideOfBox: box do: [ :element |\r\t\t\taBlock value: element spatialElementValue\r\t\t]\r\t]"}],"meta":{"name":"WDCQuadTree class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WDCSpatialBag","instanceVariables":[{"name":"elements"}],"methods":[{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ elements size"},{"name":"addSpatialSubdivisionDataStructureElement:","linesOfCode":2,"sourceCode":"addSpatialSubdivisionDataStructureElement: anElement\r\telements add: anElement"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\telements := OrderedCollection new."},{"name":"allElementsIntersectingBox:do:","linesOfCode":6,"sourceCode":"allElementsIntersectingBox: box do: aBlock\r\telements do: [ :element |\r\t\t(element isSpatialElementIntersectingBox: box) ifTrue: [\r\t\t\taBlock value: element spatialElementValue\r\t\t]\r\t]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\telements do: [ :el | aBlock value: (el spatialElementValue) ]"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock\r\t^ elements remove: oldObject ifAbsent: anExceptionBlock"},{"name":"allElementsInsideOfBox:do:","linesOfCode":6,"sourceCode":"allElementsInsideOfBox: box do: aBlock\r\telements do: [ :element |\r\t\t(element isSpatialElementInsideOfBox: box) ifTrue: [\r\t\t\taBlock value: element spatialElementValue\r\t\t]\r\t]"}],"meta":{"name":"WDCSpatialBag class","instanceVariables":[],"methods":[],"meta":null}},{"name":"AnnouncementSet","instanceVariables":[],"methods":[{"name":"-","linesOfCode":7,"sourceCode":"- anotherAnnouncement\r\t\"Create an announcement set containnig the receiver\r\tand anotherAnnouncement as an exclusion.\"\r\r\t^ AnnouncementSetWithExclusions new\r\t\tadd: self;\r\t\taddExclusion: anotherAnnouncement;\r\t\tyourself"},{"name":",","linesOfCode":2,"sourceCode":", anAnnouncementClass\r\tself add: anAnnouncementClass"},{"name":"handlesAnnouncement:","linesOfCode":3,"sourceCode":"handlesAnnouncement: anAnnouncement\r\t\"If any of the set handles the announcements, subscribers should receive it.\"\r\t^ self anySatisfy: [ :each | each handlesAnnouncement: anAnnouncement ]"}],"meta":{"name":"AnnouncementSet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentitySet","instanceVariables":[],"methods":[{"name":"fuelReplacement","linesOfCode":6,"sourceCode":"fuelReplacement\r\t| copy |\r\tcopy := self copyEmpty addAll: self.\r\t^ (self size ~= copy size)\r\t\tifTrue: [ copy ]\r\t\tifFalse: [ self ]"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"scanFor:","linesOfCode":11,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start hash |\r\thash := anObject identityHash.\r\tindex := start := hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ element enclosedElement == anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^self"}],"meta":{"name":"IdentitySet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"PluggableSet","instanceVariables":[{"name":"hashBlock"},{"name":"equalBlock"}],"methods":[{"name":"hashBlock","linesOfCode":3,"sourceCode":"hashBlock\r\t\"Return the block used for hashing the elements in the receiver.\"\r\t^hashBlock"},{"name":"equalBlock","linesOfCode":3,"sourceCode":"equalBlock\r\t\"Return the block used for comparing the elements in the receiver.\"\r\t^equalBlock"},{"name":"equalBlock:","linesOfCode":3,"sourceCode":"equalBlock: aBlock\r\t\"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise\"\r\tequalBlock := aBlock."},{"name":"scanFor:","linesOfCode":12,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := (hashBlock ifNil: [anObject hash] ifNotNil: [ hashBlock value: anObject]) \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ \r\t\t\tequalBlock ifNil: [element enclosedElement = anObject] ifNotNil: [ \r\t\t\t\tequalBlock value: element enclosedElement value: anObject ]])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"copyEmpty","linesOfCode":4,"sourceCode":"copyEmpty\r\t^super copyEmpty\r\t\thashBlock: hashBlock;\r\t\tequalBlock: equalBlock"},{"name":"scanForEmptySlotFor:","linesOfCode":10,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := (hashBlock\r\t\tifNil: [ aKey hash ]\r\t\tifNotNil: [ hashBlock value: aKey ]) \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"hashBlock:","linesOfCode":3,"sourceCode":"hashBlock: aBlock\r\t\"Set a new hash block. The block must accept one argument and return the hash value of the given argument.\"\r\thashBlock := aBlock."}],"meta":{"name":"PluggableSet class","instanceVariables":[],"methods":[{"name":"integerSet","linesOfCode":2,"sourceCode":"integerSet\r\t^self new hashBlock: [:integer | integer hash \\\\ 1064164 * 1009]"}],"meta":null}},{"name":"WeakSet","instanceVariables":[{"name":"flag"}],"methods":[{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: anInteger\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := WeakArray new: anInteger withAll: flag.\r\tself noCheckNoGrowFillFrom: oldElements"},{"name":"scanForLoadedSymbol:","linesOfCode":14,"sourceCode":"scanForLoadedSymbol: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements\"\r\r\t| element start finish |\r\r\tstart := (anObject hash \\\\ array size) + 1.\r\tfinish := array size.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == flag or: [element asString = anObject asString])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == flag or: [element asString = anObject asString])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"grow","linesOfCode":9,"sourceCode":"grow\r\t\"Grow the elements array if needed.\r\tSince WeakSets just nil their slots, alot of the occupied (in the eyes of the set) slots are usually \tempty. Doubling size if unneeded can lead to BAD performance, therefore we see if reassigning \tthe <live> elements to a Set of similiar size leads to a sufficiently (50% used here) empty set first.\r\tand reinsert the old elements\"\r\r\t| oldTally |\r\toldTally := tally.\r\tself growTo: array size.\r\toldTally >> 1 < tally\r\t\tifTrue: [ self growTo: (HashTableSizes atLeast: 2 * array size) ]"},{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element enclosedElement = anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"anyOne","linesOfCode":7,"sourceCode":"anyOne\r\t\"First we will try to return any real object which is not garbage collected. It will skip all slots with flag. In case when everything is garbage collected we will return nil. WeakSet is not empty in this case (isEmpty will return false). So we should not signal any error\"\r\t| result |\r\tresult := super anyOne.\r\t^result == self \r\t\tifTrue: [ nil ] \r\t\tifFalse: [ result ]"},{"name":"add:","linesOfCode":8,"sourceCode":"add: newObject\r\t\"Include newObject as one of the receiver's elements, but only if\r\tnot already present. Answer newObject\"\r\r\t| index element |\r\tindex := self scanFor: newObject.\r\t((element := array at: index) == flag or: [ element == nil ])\r\t\tifTrue: [self atNewIndex: index put: newObject asCollectionElement].\r\t^newObject"},{"name":"includes:","linesOfCode":4,"sourceCode":"includes: anObject \r\t\r\t^(array at: (self scanFor: anObject))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :object | object ~~ flag ]"},{"name":"initialize:","linesOfCode":6,"sourceCode":"initialize: n\r\t\"Initialize array to an array size of n\"\r\r\tflag := Object new.\r\tarray := WeakArray new: n.\r\tarray atAllPut: flag.\r\ttally := 0"},{"name":"printElementsOn:","linesOfCode":7,"sourceCode":"printElementsOn: aStream\r\t| oldPos |\r\taStream nextPut: $(.\r\toldPos := aStream position.\r\tself do: [:element | aStream print: element; space].\r\taStream position > oldPos ifTrue: [aStream skip: -1 \"remove the extra space\"].\r\taStream nextPut: $)"},{"name":"do:after:","linesOfCode":10,"sourceCode":"do: aBlock after: anElement\r\r\t| startIndex |\r\ttally = 0 ifTrue: [ ^self ].\r\tstartIndex := anElement\r\t\tifNil: [ 0 ]\r\t\tifNotNil: [ self scanFor: anElement ].\r\tstartIndex + 1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\taBlock value: object enclosedElement] ] ]"},{"name":"like:ifAbsent:","linesOfCode":7,"sourceCode":"like: anObject ifAbsent: aBlock\r\t\"Answer an object in the receiver that is equal to anObject,\r\tor evaluate the block if not found. Relies heavily on hash properties\"\r\r\t| element |\r\t^ ((element := array at: (self scanFor: anObject)) == flag or: [ element == nil ])\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ element enclosedElement ]"},{"name":"collect:","linesOfCode":9,"sourceCode":"collect: aBlock\r\r\t| newSet |\r\tnewSet := self species new: self size.\r\ttally = 0 ifTrue: [ ^newSet ].\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\tnewSet add: (aBlock value: object enclosedElement) ] ] ].\r\t^newSet"},{"name":"rehash","linesOfCode":2,"sourceCode":"rehash\r\tself growTo: array size"},{"name":"fixCollisionsFrom:","linesOfCode":17,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by flag.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == flag ] whileFalse: [\r\t\telement \r\t\t\tifNil: [ \"This object is gone\"\r\t\t\t\tarray at: index put: flag.\r\t\t\t\ttally := tally - 1 ]\r\t\t\tifNotNil: [\r\t\t\t\t| newIndex |\r\t\t\t\t(newIndex := self scanFor: element enclosedElement) = index ifFalse: [\r\t\t\t\t\tarray \r\t\t\t\t\t\tat: newIndex put: element;\r\t\t\t\t\t\tat: index put: flag ] ] ]\r"},{"name":"slowSize","linesOfCode":11,"sourceCode":"slowSize\r\t\"Careful! Answer the maximum amount\r\tof elements in the receiver, not the\r\texact amount\"\r\r\t| count |\r\tcount := 0.\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\tcount := count + 1 ] ] ].\r\t^count"},{"name":"asArray","linesOfCode":5,"sourceCode":"asArray\r\r\t| newArray |\r\t\r\tnewArray := OrderedCollection new.\r\t\r\tself do: [:each | newArray add: each].\r\t\r\t^ newArray asArray"},{"name":"postCopy","linesOfCode":6,"sourceCode":"postCopy\r\t| oldFlag |\r\tsuper postCopy.\r\toldFlag := flag.\r\tflag := Object new.\r\tarray replaceAll: oldFlag with: flag."},{"name":"isHealthy","linesOfCode":11,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tWeakSet allSubInstances select: [:badSet |\r\t\tbadSet isHealthy not ]\r\t\"\r\tarray withIndexDo: [ :element :index |\r\t\t(element isNotNil and: [ element ~~ flag ]) ifTrue: [\r\t\t\t(self scanFor: element) == index\r\t\t\t\tifFalse: [ ^ false ]]].\r\t^ true"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject  == flag ifFalse: [\r\t\t\t\taBlock value: object enclosedElement] ] ]"},{"name":"like:","linesOfCode":6,"sourceCode":"like: anObject\r\t\"Answer an object in the receiver that is equal to anObject,\r\tnil if no such object is found. Relies heavily on hash properties\"\r\r\t| element |\r\t^(element  := array at: (self scanFor: anObject)) == flag\r\t\tifFalse: [ element enclosedElement]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\r\t| index |\r\tindex := self scanFor: oldObject.\r\t(array at: index) == flag ifTrue: [ ^ aBlock value ].\r\tarray at: index put: flag.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^oldObject"},{"name":"scanForEmptySlotFor:","linesOfCode":9,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":10,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [ \r\t\t\t\tarray\r\t\t\t\t\tat: (self scanForEmptySlotFor: object enclosedElement)\r\t\t\t\t\tput: object.\r\t\t\t\ttally := tally + 1 ] ] ]"}],"meta":{"name":"WeakSet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"OCLiteralSet","instanceVariables":[],"methods":[{"name":"add:","linesOfCode":8,"sourceCode":"add: newObject\r\t\"Include newObject as one of the receiver's elements.  If equivalent is already present don't add and return equivalent object\"\r\r\t| index |\r\tnewObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].\r\tindex := self findElementOrNil: newObject.\r\t^ (array at: index) \r\t\tifNil: [self atNewIndex: index put: newObject. newObject]\r\t\tifNotNil: [array at: index]"},{"name":"scanFor:","linesOfCode":16,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| element start finish |\r\tstart := (anObject hash \\\\ array size) + 1.\r\tfinish := array size.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) isNil\r\t\t\t\t\tor: [element literalEqual: anObject])\r\t\t\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) isNil\r\t\t\t\t\tor: [element literalEqual: anObject])\r\t\t\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""}],"meta":{"name":"OCLiteralSet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityDictionary","instanceVariables":[],"methods":[{"name":"slvmEncodeAsSExpression","linesOfCode":6,"sourceCode":"slvmEncodeAsSExpression\r\t^ { #identityDictionary } , (Array streamContents: [:out |\r\t\tself keysAndValuesDo: [ :key :value |\r\t\t\tout nextPut: key slvmEncodeAsSExpression; nextPut: value slvmEncodeAsSExpression\r\t\t]\r\t])"},{"name":"keyAtValue:ifAbsent:","linesOfCode":6,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^ association key]].\r\t^ exceptionBlock value"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| finish start element |\r\tfinish := array size.\r\tstart := (anObject identityHash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"IdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"KeyedTree","instanceVariables":[],"methods":[{"name":"atPath:put:","linesOfCode":9,"sourceCode":"atPath: anArray put: aBlock\r\t\"Answer the value of aBlock after creating its path.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsentPut: [self species new]].\r\t^element at: anArray last put: aBlock"},{"name":"atPath:ifAbsent:","linesOfCode":8,"sourceCode":"atPath: anArray ifAbsent: aBlock\r\t\"Answer the element referenced by the given key path.\r\tAnswer the value of aBlock if not found.\"\r\r\t|element|\r\telement := self.\r\tanArray do: [:key |\r\t\telement := element at: key ifAbsent: [^aBlock value]].\r\t^element"},{"name":"atPath:ifAbsentPut:","linesOfCode":10,"sourceCode":"atPath: anArray ifAbsentPut: aBlock\r\t\"Answer the element referenced by the given key path.\r\tAnswer the value of aBlock if not found after creating its path.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsentPut: [self species new]].\r\t^element at: anArray last ifAbsentPut: aBlock"},{"name":"putFormattedTextOn:level:indentString:","linesOfCode":13,"sourceCode":"putFormattedTextOn: aStream level: indentLevel indentString: aString\r\t\"Place a description of the receiver on the given stream with the given indentation level.\"\r\r\t\r\t(self keys asSortedCollection: self sortBlock) do: [:k | | v |\r\t\tindentLevel timesRepeat: [aStream nextPutAll: aString].\r\t\taStream nextPutAll: k printString.\r\t\tv := self at: k.\r\t\t(v isKindOf: self class)\r\t\t\tifTrue: [aStream cr.\r\t\t\t\t\tv putFormattedTextOn: aStream level: indentLevel + 1 indentString: aString]\r\t\t\tifFalse: [aStream\r\t\t\t\t\t\tnextPutAll: ' : ';\r\t\t\t\t\t\tnextPutAll: v printString.\r\t\t\t\t\taStream cr]]"},{"name":"atPath:","linesOfCode":4,"sourceCode":"atPath: anArray\r\t\"Answer the element referenced by the give key path.\r\tSignal an error if not found.\"\r\r\t^self atPath: anArray ifAbsent: [self errorKeyNotFound: anArray]"},{"name":"formattedTextWithDescriptions:","linesOfCode":8,"sourceCode":"formattedTextWithDescriptions: aKeyedTree\r\t\"Answer a string or text representing the receiver with indentation and, possibly, markup.\r\tDescriptions of each item are taken from the given tree with\r\tthe same key structure as the receiver.\"\r\t\r\t|str|\r\tstr := String new writeStream.\r\tself putFormattedTextOn: str withDescriptions: aKeyedTree level: 0 indentString: '  '.\r\t^str contents"},{"name":"merge:","linesOfCode":11,"sourceCode":"merge: aKeyedTree\r\t\"Merge the given tree into the receiver, overwriting or extending elements as needed.\"\r\r\taKeyedTree keysAndValuesDo: [ :k :v | \r\t\t\t| subtree |\r\t\t\t(v isKindOf: KeyedTree)\r\t\t\t\tifTrue: [ \r\t\t\t\t\tsubtree := self at: k ifAbsentPut: [ v species new ].\r\t\t\t\t\t(subtree isKindOf: KeyedTree)\r\t\t\t\t\t\tifFalse: [ subtree := self at: k put: v species new ].\r\t\t\t\t\tsubtree merge: v ]\r\t\t\t\tifFalse: [ self at: k put: v ] ]"},{"name":"postCopy","linesOfCode":13,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\r\t\toriginal and the copy.\r\tCopy any subtrees too!\"\r\r\tarray := array\r\t\tcollect: [ :assoc | \r\t\t\tassoc\r\t\t\t\tifNotNil: [ Association\r\t\t\t\t\t\tkey: assoc key\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((assoc value isKindOf: KeyedTree)\r\t\t\t\t\t\t\t\tifTrue: [ assoc value copy ]\r\t\t\t\t\t\t\t\tifFalse: [ assoc value ]) ] ]"},{"name":"formattedText","linesOfCode":6,"sourceCode":"formattedText\r\t\"Answer a string or text representing the receiver with indentation and, possibly, markup.\"\r\r\t|str|\r\tstr := String new writeStream.\r\tself putFormattedTextOn: str level: 0 indentString: '  '.\r\t^str contents"},{"name":"removePath:ifAbsent:","linesOfCode":10,"sourceCode":"removePath: anArray ifAbsent: aBlock\r\t\"Remove and answer the element referenced by the given path.\r\tAnswer the value of aBlock if not found.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsent: [^aBlock value]].\r\t^element removeKey: anArray last ifAbsent: aBlock\t"},{"name":"sortBlock","linesOfCode":3,"sourceCode":"sortBlock\r\t\"Answer the block to sort tree keys with.\"\r\r\t^[:a :b | [a <= b] on: Error do: [a class name <= b class name]]"},{"name":"allKeys","linesOfCode":9,"sourceCode":"allKeys\r\t\"Answer an ordered collection of the keys of the receiver and any subtrees.\r\t\tPlease no circular references!\"\r\r\t|answer|\r\tanswer := OrderedCollection new.\r\tanswer addAll: self keys.\r\tself subtrees do: [:t |\r\t\tanswer addAll: t allKeys].\r\t^answer"},{"name":"removePath:","linesOfCode":4,"sourceCode":"removePath: anArray\r\t\"Remove and answer the element referenced by the given path.\r\tSignal an error if not found.\"\r\r\t^self removePath: anArray ifAbsent: [self errorKeyNotFound: anArray]"},{"name":"subtrees","linesOfCode":3,"sourceCode":"subtrees\r\t\"Answer the subtrees of the receiver.\"\r\r\t^(self select: [:v | v isKindOf: KeyedTree]) values"},{"name":"putFormattedTextOn:withDescriptions:level:indentString:","linesOfCode":19,"sourceCode":"putFormattedTextOn: aStream withDescriptions: aKeyedTree level: indentLevel indentString: aString\r\t\"Place a print of the receiver and associated description on the given stream with the given indentation level.\"\r\r\t\r\t(self keys asSortedCollection: self sortBlock) do: [:k | | v |\r\t\tindentLevel timesRepeat: [aStream nextPutAll: aString].\r\t\taStream nextPutAll: k printString.\r\t\tv := self at: k.\r\t\t(v isKindOf: self class)\r\t\t\tifTrue: [aStream cr.\r\t\t\t\t\tv\r\t\t\t\t\t\tputFormattedTextOn: aStream\r\t\t\t\t\t\twithDescriptions: (aKeyedTree at: k ifAbsent: [self class new])\r\t\t\t\t\t\tlevel: indentLevel + 1\r\t\t\t\t\t\tindentString: aString]\r\t\t\tifFalse: [aStream\r\t\t\t\t\t\tnextPutAll: ' : ';\r\t\t\t\t\t\tnextPutAll: v printString;\r\t\t\t\t\t\ttab; tab;\r\t\t\t\t\t\tnextPutAll: (aKeyedTree at: k ifAbsent: ['nondescript']) printString.\r\t\t\t\t\taStream cr]]"}],"meta":{"name":"KeyedTree class","instanceVariables":[],"methods":[],"meta":null}},{"name":"MethodDictionary","instanceVariables":[],"methods":[{"name":"grow","linesOfCode":6,"sourceCode":"grow \r\t| newSelf |\r\tnewSelf := self species newForCapacity: self basicSize * 2.\r\t1 to: self basicSize do:\r\t\t[:i | (self basicAt: i) ifNotNil: [ :key | newSelf at: key put: (array at: i)]].\r\tself becomeForward: newSelf"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| element start finish |\r\tfinish := array size.\r\tstart := (anObject basicIdentityHash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := self basicAt: index) isNil or: [element == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := self basicAt: index) isNil or: [element == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"swap:with:","linesOfCode":6,"sourceCode":"swap: oneIndex with: otherIndex\r\r\t| element |\r\telement := self basicAt: oneIndex.\r\tself basicAt: oneIndex put: (self basicAt: otherIndex).\r\tself basicAt: otherIndex put: element.\r\tarray swap: oneIndex with: otherIndex\r"},{"name":"add:","linesOfCode":2,"sourceCode":"add: anAssociation\r\r\t^ self at: anAssociation key put: anAssociation value"},{"name":"rehash","linesOfCode":7,"sourceCode":"rehash \r\r\t| newInstance |\r\tnewInstance := self species newForCapacity: self basicSize.\r\t1 to: self basicSize do: [ :index | \r\t\t(self basicAt: index) ifNotNil: [ :key |\r\t\t\tnewInstance at: key put: (array at: index) ] ].\r\tself copyFrom: newInstance"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock \r\r\ttally = 0 ifTrue: [^ self].\r\t1 to: self basicSize do:\r\t\t[:i | (self basicAt: i) ifNotNil:\r\t\t\t[ :key | aBlock value: (Association key: key value: (array at: i))]]"},{"name":"valuesDo:","linesOfCode":4,"sourceCode":"valuesDo: aBlock \r\ttally = 0 ifTrue: [^ self].\r\t1 to: self basicSize do:\r\t\t[:i | (array at: i) ifNotNil: [ :value | aBlock value: value]]"},{"name":"removeDangerouslyKey:ifAbsent:","linesOfCode":15,"sourceCode":"removeDangerouslyKey: key ifAbsent: aBlock\r\t\"This is not really dangerous.  But if normal removal\r\twere done WHILE a MethodDict were being used, the\r\tsystem might crash.  So instead we make a copy, then do\r\tthis operation (which is NOT dangerous in a copy that is\r\tnot being used), and then use the copy after the removal.\"\r\r\t| index element |\r\tindex := self findElementOrNil: key.\r\t(self basicAt: index) ifNil: [ ^ aBlock value ].\r\telement := array at: index.\r\tarray at: index put: nil.\r\tself basicAt: index put: nil.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^ element"},{"name":"keysAndValuesDo:","linesOfCode":7,"sourceCode":"keysAndValuesDo: aBlock \r\t\"Enumerate the receiver with all the keys and values passed to the block\"\r\ttally = 0 ifTrue: [^ self].\r\t1 to: self basicSize do:\r\t\t[:i | (self basicAt: i) ifNotNil:\r\t\t\t[ :key | aBlock value: key value: (array at: i)]\r\t\t]"},{"name":"postCopy","linesOfCode":2,"sourceCode":"postCopy\r\tarray := array copy"},{"name":"isHealthy","linesOfCode":11,"sourceCode":"isHealthy\r\t\"Test that selector hashes match their positions stored in dictionary,\r\tanswer true if everything ok, false otherwise\r\t\r\tMethodDictionary allInstances select: [:dict |\r\t\tdict isHealthy not ]\r\r\t\"\r\t1 to: self basicSize do: [:i | | selector |\r\t\tselector := self basicAt: i.\r\t\tselector ifNotNil: [\r\t\t\t(self scanFor: selector) == i ifFalse: [ ^ false ]]].\r\t^ true"},{"name":"removeKey:ifAbsent:","linesOfCode":10,"sourceCode":"removeKey: key ifAbsent: errorBlock \r\t\"The interpreter might be using this MethodDictionary while\r\tthis method is running! Therefore we perform the removal\r\tin a copy, and then atomically copy that copy\"\r\t\r\t| copy removedValue |\r\tcopy := self copy.\r\tremovedValue := copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].\r\tself copyFrom: copy.\r\tkey flushCache.\r\t^ removedValue"},{"name":"compact","linesOfCode":7,"sourceCode":"compact\r\t\"Make sure that I have the highest possible load factor (between 37.5% and 75%).\"\r\t\r\t| newInstance |\r\tnewInstance := self compactWithoutBecome.\r\tnewInstance capacity = self capacity\r\t\tifTrue: [ self copyFrom: newInstance ]\r\t\tifFalse: [ self becomeForward: newInstance ]"},{"name":"metaLinkOptions","linesOfCode":6,"sourceCode":"metaLinkOptions\r\t^{\r\t#scanFor: -> #( + optionCompileOnLinkInstallation).\r\t#at:put: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":9,"sourceCode":"keyAtIdentityValue: value ifAbsent: exceptionBlock\r\t\"Answer the key whose value equals the argument, value. If there is\r\tnone, answer the result of evaluating exceptionBlock.\"\r\t1 to: self basicSize do:\r\t\t[:index |\r\t\tvalue == (array at: index)\r\t\t\tifTrue:\r\t\t\t\t[(self basicAt: index) ifNotNil: [ :theKey | ^ theKey]]].\r\t^ exceptionBlock value"},{"name":"keysDo:","linesOfCode":4,"sourceCode":"keysDo: aBlock \r\ttally = 0 ifTrue: [^ self].\r\t1 to: self basicSize do:\r\t\t[:i | (self basicAt: i) ifNotNil: [ :key | aBlock value: key]]"},{"name":"removeAll","linesOfCode":6,"sourceCode":"removeAll\r\t\"Remove all elements from this collection. Preserve the capacity\"\r\t\r\t| newSelf |\r\ttally = 0 ifTrue: [^self].\r\tnewSelf := self species newForCapacity: self basicSize.\r\tself copyFrom: newSelf"},{"name":"isEqualRegardlessMethodsTrailerTo:","linesOfCode":12,"sourceCode":"isEqualRegardlessMethodsTrailerTo: aMethodDictionary\r\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value\"\r\r\tself == aMethodDictionary ifTrue: [ ^ true ].\r\t(aMethodDictionary isDictionary) ifFalse: [^false].\r\tself size = aMethodDictionary size ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t((aMethodDictionary at: assoc key ifAbsent: [^false]) isEqualRegardlessTrailerTo:  assoc value)\r\t\t\tifFalse: [^false]].\r\t^true\r\r"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r      \"Answer the association with the given key.\r       If key is not found, return the result of evaluating aBlock.\"\r\r       ^(array at: (self scanFor: key))\r               ifNil: [ aBlock value ]\r               ifNotNil: [ :value | key -> value ]"},{"name":"fixCollisionsFrom:","linesOfCode":10,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\r\t| key index |\r\tindex := start.\r\t[ (key := self basicAt: (index := index \\\\ array size + 1)) == nil ] whileFalse: [\r\t\t| newIndex |\r\t\t(newIndex := self findElementOrNil: key) = index ifFalse: [\r\t\t\tself swap: index with: newIndex ] ]"},{"name":"at:ifPresent:","linesOfCode":3,"sourceCode":"at: key ifPresent: aBlock\r\r\t^(array at: (self findElementOrNil: key))\r\t\tifNotNil: [ :value | aBlock cull: value ]"},{"name":"compactWithoutBecome","linesOfCode":8,"sourceCode":"compactWithoutBecome\r\t\"Return a copy of self which has the highest possible load factor (between 37.5% and 75%).\"\r\t\r\t| newInstance |\r\tnewInstance := self species new: self size.\r\t1 to: self basicSize do: [ :index | \r\t\t(self basicAt: index) ifNotNil: [ :key |\r\t\t\tnewInstance at: key put: (array at: index) ] ].\r\t^newInstance"},{"name":"at:ifAbsent:","linesOfCode":5,"sourceCode":"at: key ifAbsent: aBlock\r\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(self basicAt: index) ifNil: [ ^ aBlock value ].\r\t^ array at: index"},{"name":"keyAtValue:ifAbsent:","linesOfCode":9,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key whose value equals the argument, value. If there is\r\tnone, answer the result of evaluating exceptionBlock.\"\r\t1 to: self basicSize do:\r\t\t[:index |\r\t\tvalue = (array at: index)\r\t\t\tifTrue:\r\t\t\t\t[(self basicAt: index) ifNotNil: [ :theKey | ^ theKey]]].\r\t^ exceptionBlock value"},{"name":"at:put:","linesOfCode":13,"sourceCode":"at: key put: value\r\t\"Set the value at key to be value.\"\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(self basicAt: index) \r\t\tifNil: \r\t\t\t[tally := tally + 1.\r\t\t\tself basicAt: index put: key].\r\tarray at: index put: value.\r\tkey flushCache. \"flush the vm cache by selector\"\r\tself fullCheck.\r\tvalue cachePragmas.\r\t^ value"}],"meta":{"name":"MethodDictionary class","instanceVariables":[],"methods":[{"name":"compactAllInstances","linesOfCode":13,"sourceCode":"compactAllInstances\r\r\t| instancesToExchange newInstances |\r\tinstancesToExchange := Array streamContents: [ :oldStream |\r\t\tnewInstances := Array streamContents: [ :newStream |\r\t\t\tself allInstances do: [ :each |\r\t\t\t\t| newInstance |\r\t\t\t\tnewInstance := each compactWithoutBecome.\r\t\t\t\tnewInstance capacity = each capacity \r\t\t\t\t\tifTrue: [ each copyFrom: newInstance ]\r\t\t\t\t\tifFalse: [\r\t\t\t\t\t\toldStream nextPut: each.\r\t\t\t\t\t\tnewStream nextPut: newInstance ] ] ] ].\r\tinstancesToExchange elementsForwardIdentityTo: newInstances"},{"name":"new:","linesOfCode":3,"sourceCode":"new: numberOfElements\r\t\"Create an instance large enough to hold numberOfElements methods without growing.\"\r\t\r\t^self newForCapacity: (self sizeFor: numberOfElements)"},{"name":"sizeFor:","linesOfCode":3,"sourceCode":"sizeFor: numberOfElements\r    \"Return the minimum capacity of a dictionary that can hold numberOfElements elements. At least 25% of the array must be empty and the return value must be a nonnegative power of 2. Notice that the max: 1 is because a MethodDictionaries can never be entirely empty, as the #grow method requires it not to be (since it does self basicSize * 2)\"\r\r\t^(numberOfElements * 4 // 3 max: 1) asLargerPowerOfTwo "},{"name":"newForCapacity:","linesOfCode":3,"sourceCode":"newForCapacity: capacity\r\t\"Create an instance with the given capacity which must be a power of two.\"\r\t\r\t^(self basicNew: capacity) initialize: capacity\r"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Create a new instance with 32 slots, which can hold at most 24 methods before growing is necessary.\"\r\t\r\t^self newForCapacity: 32"}],"meta":null}},{"name":"PluggableDictionary","instanceVariables":[{"name":"hashBlock"},{"name":"equalBlock"}],"methods":[{"name":"=","linesOfCode":15,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself equalBlock = aDictionary equalBlock ifFalse: [^false].\r\tself hashBlock = aDictionary hashBlock ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"hashBlock","linesOfCode":3,"sourceCode":"hashBlock\r\t\"Return the block used for hashing the keys in the receiver.\"\r\t^hashBlock"},{"name":"equalBlock","linesOfCode":3,"sourceCode":"equalBlock\r\t\"Return the block used for comparing the elements in the receiver.\"\r\t^equalBlock"},{"name":"equalBlock:","linesOfCode":3,"sourceCode":"equalBlock: aBlock\r\t\"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise\"\r\tequalBlock := aBlock."},{"name":"scanFor:","linesOfCode":25,"sourceCode":"scanFor: anObject \r\t\"Scan the key array for the first slot containing either a nil\r(indicating \r\t  an empty slot) or an element that matches anObject. Answer the index \r\t  \r\tof that slot or zero if no slot is found. This  method will be\roverridden   \r\tin various subclasses that have different interpretations for matching \r \r\telements.\"\r\t| element start finish |\r\tstart := (hashBlock ifNil: [anObject hash]\r\t\t\t\tifNotNil: [hashBlock value: anObject])\r\t\t\t\t\\\\ array size + 1.\r\tfinish := array size.\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do: [:index | ((element := array at: index) == nil or:\r[equalBlock ifNil: [element key = anObject]\r\t\t\t\tifNotNil: [equalBlock value: element key value: anObject]])\r\t\t\tifTrue: [^ index]].\r\t\"Search from 1 to where we started.\"\r\t1 to: start - 1 do: [:index | ((element := array at: index) == nil or:\r[equalBlock ifNil: [element key = anObject]\r\t\t\t\tifNotNil: [equalBlock value: element key value: anObject]])\r\t\t\tifTrue: [^ index]].\r\t^ 0\"No match AND no empty slot\""},{"name":"copyEmpty","linesOfCode":4,"sourceCode":"copyEmpty\r\t^super copyEmpty\r\t\thashBlock: hashBlock;\r\t\tequalBlock: equalBlock"},{"name":"hash","linesOfCode":4,"sourceCode":"hash\r\t\"hashBlock is used to hash keys for lookup, not the dictionary itself, but its hash is still\r\tconsidered.\"\r\t^ (super hash bitXor: self equalBlock hash) bitXor: self hashBlock hash"},{"name":"scanForEmptySlotFor:","linesOfCode":10,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := (hashBlock\r\t\tifNil: [ aKey hash ]\r\t\tifNotNil: [ hashBlock value: aKey ]) \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"hashBlock:","linesOfCode":3,"sourceCode":"hashBlock: aBlock\r\t\"Set a new hash block. The block must accept one argument and must return the hash value of the given argument.\"\r\thashBlock := aBlock."}],"meta":{"name":"PluggableDictionary class","instanceVariables":[],"methods":[{"name":"integerDictionary","linesOfCode":2,"sourceCode":"integerDictionary\r\t^ self new hashBlock: [:integer | integer hash \\\\ 1064164 * 1009]"}],"meta":null}},{"name":"WeakKeyDictionary","instanceVariables":[{"name":"expired"},{"name":"finalizer"}],"methods":[{"name":"allAssociationsDo:","linesOfCode":6,"sourceCode":"allAssociationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations). This includes associations with nil keys, except for\r\tthe expired ones.\"\r\r\tsuper associationsDo: [:association | \r\t\tassociation expired ifFalse:[aBlock value: association]]."},{"name":"grow","linesOfCode":3,"sourceCode":"grow\r\tsuper grow.\r\texpired := 0."},{"name":"expiredValuesDo:","linesOfCode":10,"sourceCode":"expiredValuesDo: aBlock\r\t\"Clear all associations with nil keys\"\r\t1 to: array size do:[:i | | assoc |\r\t\tassoc := array at: i.\r\t\t(assoc notNil and: [ assoc key isNil and: [assoc expired not ]])\r\t\tifTrue: [ \r\t\t\taBlock value: assoc value.\r\t\t\tassoc expire.\r\t\t\texpired := expired + 1.\r\t\t\ttally := tally - 1.\t]]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself at: anAssociation key put: anAssociation value.\r\t^ anAssociation"},{"name":"rehash","linesOfCode":4,"sourceCode":"rehash\r\t\"Rehash the receiver.\"\r\tsuper rehash.\r\texpired := 0."},{"name":"associationsDo:","linesOfCode":7,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).\"\r\r\t\r\r\tsuper associationsDo: [:association | | key | \r\t\t\"Hold onto the key so it won't be collected while the block is evaluated.\"\r\t\tkey := association key.\r\t\tkey ifNotNil:[aBlock value: association]]."},{"name":"overridingAt:put:","linesOfCode":19,"sourceCode":"overridingAt: key put: anObject\r\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\r\tMay override an association with key == nil\"\r\r\t| index element |\r\r\tkey ifNil: [ ^ anObject ].\r\tindex := self scanForKeyOrNil: key.\t\"There should always be room.\"\r\tindex = 0\r\t\tifTrue: [ self error: 'No space left in dictionary' ].\r\r\telement := array at: index.\r\telement == nil\r\t\tifTrue: [ self atNewIndex: index put: ( WeakKeyAssociation key: key value: anObject ) ]\r\t\tifFalse: [ element expired\r\t\t\t\tifTrue: [ tally := tally + 1 ].\r\t\t\telement key: key.\r\t\t\telement value: anObject.\r\t\t\tself fullCheck\r\t\t\t].\r\t^ anObject"},{"name":"scanFor:","linesOfCode":15,"sourceCode":"scanFor: anObject\r\t\"mvl 10/21/2007: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForEmpty: must be changed in the receiver as well.\"\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. Expired associations are ignored, since callers take non-nil slots as a successful search. Subclasses should override startIndexFor: and compare:to: if they have a different semantics for matching elements.\"\r\t| element start finish |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForKeyOrNil:","linesOfCode":14,"sourceCode":"scanForKeyOrNil: anObject\r\t\"Same as scanFor: , but treats association with key == nil as empty slot\"\r\t\r\t| element start finish |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"valueAtNewKey:put:atIndex:declareFrom:","linesOfCode":2,"sourceCode":"valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary \r\tself shouldNotImplement."},{"name":"valuesDo:","linesOfCode":9,"sourceCode":"valuesDo: aBlock\r\t\"See comments in Dictionary>>valuesDo:\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\t1 to: array size do: [ :eachIndex | \r\t\t(array at: eachIndex) ifNotNil: [ :eachAssociation | \r\t\t\t| eachKey |\r\t\t\t\"The code keeps the key so it's not collected during the evaluation of aBlock\"\r\t\t\teachKey := eachAssociation key.\r\t\t\taBlock value: eachAssociation value ] ]"},{"name":"postCopy","linesOfCode":9,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\roriginal and the copy\"\r\r\tarray := array\r\t\tcollect: [ :assoc | \r\t\t\tassoc\r\t\t\t\tifNotNil: [ assoc expired\r\t\t\t\t\t\tifTrue: [ WeakKeyAssociation expired ]\r\t\t\t\t\t\tifFalse: [ WeakKeyAssociation key: assoc key value: assoc value ] ] ]"},{"name":"isHealthy","linesOfCode":14,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in the receiver,\r\tanswer true if everything ok, false otherwise\r\t\r\tWeakKeyDictionary allInstances select: [:dict |\r\t\tdict isHealthy not ]\r\tDictionary allSubInstances select: [:dict |\r\t\tdict isHealthy not ]\r\t\"\r\tarray withIndexDo: [:elem :i |\r\t\t(elem notNil and: [elem key notNil ])\r\t\t\t\tifTrue:  [(self scanFor: elem key) == i ifFalse: [ ^ false ]\r\t\t\t]\r\t].\r\t^ true"},{"name":"fullCheck","linesOfCode":8,"sourceCode":"fullCheck\r\t\"Inlined super fullCheck, since the correct + X value for rehash check depends on its implementation\"\r\t\"Keep array at least 1/4 free for decent hash behavior\"\r\tarray size - tally < (array size // 4 max: 1)\r\t\tifTrue: [self grow].\r\t\"Make sure we never have so many expired entries that adding might fail\"\r\t4 * expired + 4 > array size \r\t\tifTrue: [self rehash]."},{"name":"removeKey:ifAbsent:","linesOfCode":14,"sourceCode":"removeKey: key ifAbsent: aBlock\r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index result assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\t(assoc == nil or: [assoc key isNil]) ifTrue: [ ^ aBlock value ].\r\tassoc key: nil.\r\tresult := assoc value.\r\tassoc expire.\r\texpired := expired + 1.\r\ttally := tally - 1.\r\t^result"},{"name":"startIndexFor:","linesOfCode":3,"sourceCode":"startIndexFor: anObject\r\t\"Return the index at which the scan for anObject should start.\"\r\t\r\t^(anObject hash \\\\ array size) + 1"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":12,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tassociation key \r\t\t\t\tifNil: [ finalizer ifNotNil: [ finalizer value: association value ] ]\r\t\t\t\tifNotNil: [ :key | \"Don't let the key go away\"\r\t\t\t\t\tarray\r\t\t\t\t\t\tat: (self scanForEmptySlotFor: key)\r\t\t\t\t\t\tput: association.\r\t\t\t\t\ttally := tally + 1 ] ] ]"},{"name":"finalizeValues:","linesOfCode":9,"sourceCode":"finalizeValues: finiObjects\r\t\"Clear all associations with key == nil and value is in finiObjects.\"\r\tarray do:[:assoc|\r\t\t(assoc notNil and:[finiObjects includes: assoc value]) ifTrue:[\r\t\t\tassoc expire.\r\t\t\texpired := expired + 1.\r\t\t\ttally := tally - 1.\r\t\t].\r\t].\r"},{"name":"noCheckAddForRehash:","linesOfCode":2,"sourceCode":"noCheckAddForRehash: anAssociation\r\t^self noCheckAdd: anAssociation"},{"name":"finalizeValues","linesOfCode":13,"sourceCode":"finalizeValues\r\t\"Clear all associations with nil keys.\r\tAvoid using block closures, so it won't produce many garbage \r\t(since pushing closure as argument requires creating its preinitialized copy)\"\r\t1 to: array size do:[:i | | assoc |\r\t\tassoc := array at: i.\r\t\tassoc ifNotNil:[\r\t\t\tassoc expire ifTrue:[\r\t\t\t\texpired := expired + 1.\r\t\t\t\ttally := tally - 1.\r\t\t\t].\r\t\t].\r\t].\r"},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: n\r\texpired := 0.\r\t^super initialize: n"},{"name":"noCheckAdd:","linesOfCode":18,"sourceCode":"noCheckAdd: anAssociation\r\t\"Add anAssociation to the receiver. Discard expired associations. Put nil keys at the beginning.\"\r\t\r\t| key |\r\t\r\tkey := anAssociation key. \"Hold on to the key during this method\"\r\r\tanAssociation expired ifFalse:[\r\t\tkey ifNotNil:[\r\t\t\tsuper noCheckAdd: anAssociation\r\t\t] ifNil: [\r\t\t\t1 to: array size do:[:n|\r\t\t\t\t(array at: n) ifNil:[\r\t\t\t\t\tarray at: n put: anAssociation. \r\t\t\t\t\ttally := tally + 1.\r\t\t\t\t\t^self\r\t\t\t\t].\r\t\t\t].\r\t\t\tself error: 'could not find an empty slot.'\r\t\t].\r\t]."},{"name":"slowSize","linesOfCode":11,"sourceCode":"slowSize\r\t\"Careful! Answer the maximum amount\r\tof elements in the receiver, not the\r\texact amount\"\r\r\t| count |\r\tcount := 0.\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject expired ifFalse: [\r\t\t\t\tcount := count + 1 ] ] ].\r\t^count"},{"name":"fixCollisionsFrom:","linesOfCode":3,"sourceCode":"fixCollisionsFrom: oldIndex\r\t\"This is an internal method that should not be needed in WeakKeyDictionary\"\r\tself shouldNotImplement."},{"name":"scanForEmpty:","linesOfCode":35,"sourceCode":"scanForEmpty: anObject\r\t\"Scan the key array for the first slot containing either a nil or an expired association (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found.\"\r\t| element start finish firstNil |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\tfirstNil := nil.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil \r\t\t\t\t\t\tor: [self compare: element key to: anObject])\r\t\t\tifTrue: [\r\t\t\t\t\"If we found no match, and have an expired slot, use that one.\"\r\t\t\t\t(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].\r\t\t\t\t^ index \r\t\t\t].\r\t\t\t\"If this slot is expired, and we haven't seen an earlier expired slot, record it\"\r\t\t\t(element notNil \r\t\t\t\tand: [element expired \r\t\t\t\t\t\tand: [firstNil isNil]]) ifTrue: [firstNil := index].\r\t\t].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil \r\t\t\t\t\tor: [self compare: element key to: anObject])\r\t\t\tifTrue: [\r\t\t\t\t(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].\r\t\t\t\t^ index \r\t\t\t].\r\t\t\t(element notNil \r\t\t\t\tand: [element expired \r\t\t\t\t\t\tand: [firstNil isNil]]) ifTrue: [firstNil := index].\r\t\t].\r\r\t\"If there is no empty slot, but an expired one, return it.\"\t\r\tfirstNil notNil ifTrue:[^firstNil].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"at:put:","linesOfCode":18,"sourceCode":"at: key put: anObject\r\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\"\r\r\t| index element |\r\r\tkey ifNil: [ ^ anObject ].\r\tindex := self scanForEmpty: key.\t\"There should always be room.\"\r\tindex = 0\r\t\tifTrue: [ self error: 'No space left in dictionary' ].\r\r\telement := array at: index.\r\telement == nil\r\t\tifTrue: [ self atNewIndex: index put: ( WeakKeyAssociation key: key value: anObject ) ]\r\t\tifFalse: [ element expired\r\t\t\t\tifTrue: [ tally := tally + 1 ].\r\t\t\telement key: key.\r\t\t\telement value: anObject.\r\t\t\tself fullCheck\r\t\t\t].\r\t^ anObject"},{"name":"compare:to:","linesOfCode":2,"sourceCode":"compare: object1 to: object2\r\t^object1 = object2"}],"meta":{"name":"WeakKeyDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakValueDictionary","instanceVariables":[],"methods":[{"name":"size","linesOfCode":5,"sourceCode":"size\r\t| count |\r\tcount := 0.\r\tself valuesDo: [ :each | count := count + 1 ].\r\t^ count"},{"name":"clyIncludesCleanedKey:","linesOfCode":3,"sourceCode":"clyIncludesCleanedKey: key\r\t\"Answer whether the receiver has a key which value was collected as garbage\"\r\t\r\t^ (array at: (self scanFor: key)) value == nil"},{"name":"valuesDo:","linesOfCode":7,"sourceCode":"valuesDo: aBlock\r\t\"See comments in Dictionary>>valuesDo:.  The code keeps\r\ta reference to the value to facilitate debugging\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\t1 to: array size do: [ :eachIndex | \r\t\t(array at: eachIndex) value\r\t\t\tifNotNil: [ :assocValue | aBlock value: assocValue enclosedElement ] ]"},{"name":"includesKey:","linesOfCode":5,"sourceCode":"includesKey: key\r\t\"Answer whether the receiver has a key equal to the argument and also that the value associated to this key was not garbage collected.\"\r\r\t^ (array at: (self scanFor: key))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :value | value value isNotNil ]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself at: anAssociation key put: anAssociation value.\r\t^ anAssociation"},{"name":"rehash","linesOfCode":5,"sourceCode":"rehash\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tarray do: [ :each | each value ifNotNil: [ :asso | newSelf noCheckAdd: each ] ].\r\tarray := newSelf array"},{"name":"associationsDo:","linesOfCode":4,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value associations).\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\tarray do: [ :each | each value ifNotNil: [ :value | aBlock value: each key -> value enclosedElement ] ]"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r\t\"Answer the association with the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNil: [ aBlock value ]\r\t\tifNotNil: [ :assoc | assoc key -> assoc value enclosedElement ]"},{"name":"at:ifPresent:ifAbsentOrNil:","linesOfCode":8,"sourceCode":"at: key ifPresent: presentBlock ifAbsentOrNil: absentBlock\r\r\t^ self \r\t\tat: key\r\t\tifPresent: [:valueOrNil | \r\t\t\tvalueOrNil\r\t\t\t\tifNotNil: presentBlock\r\t\t\t\tifNil: absentBlock ]\r\t\tifAbsent: absentBlock"},{"name":"clyCleanGarbage","linesOfCode":9,"sourceCode":"clyCleanGarbage\r\r\t| firstFound |\r\tarray withIndexDo: [:ass :index | \r\t\t(ass notNil and: [ass value isNil]) ifTrue: [ \r\t\t\tarray at: index put: nil.\r\t\t\ttally := tally - 1.\r\t\t\tfirstFound ifNil: [firstFound := index]]].\r\t\r\tfirstFound ifNotNil: [ \r\t\tself fixCollisionsFrom: firstFound]"},{"name":"at:ifPresent:","linesOfCode":6,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t^ (array at: (self findElementOrNil: key)) value ifNotNil: [ :value | aBlock cull: value enclosedElement ]"},{"name":"privateAssociations","linesOfCode":3,"sourceCode":"privateAssociations\r\t\"I am a method used for test to return the WeakValueAssociations instead of Associations.\"\r\r\t^ array select: [ :each | each value isNotNil ]"},{"name":"at:ifAbsent:","linesOfCode":6,"sourceCode":"at: key ifAbsent: aBlock\r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key)) value\r\t\t\tifNil: aBlock\r\t\t\tifNotNil: [ :value | value enclosedElement ]"},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: key put: anObject\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\"\r\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(array at: index)\r\t\tifNil: [ self atNewIndex: index put: (WeakValueAssociation key: key value: anObject asCollectionElement) ]\r\t\tifNotNil: [ :element | element value: anObject asCollectionElement ].\r\t^ anObject"}],"meta":{"name":"WeakValueDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ZnMultiValueDictionary","instanceVariables":[{"name":"limit"}],"methods":[{"name":"limit:","linesOfCode":2,"sourceCode":"limit: numberOfEntries\r\tlimit := numberOfEntries "},{"name":"addAllMulti:","linesOfCode":4,"sourceCode":"addAllMulti: keyedCollection\r\t\"Note that we use #at:add:\"\r\r\tkeyedCollection keysAndValuesDo: [ :key :value | \r\t\tself at: key add: value ]"},{"name":"limit","linesOfCode":2,"sourceCode":"limit\r\t^ limit"},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: n\r\tsuper initialize: n.\r\tlimit := self class defaultLimit"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself checkLimitForKey: anAssociation key.\r\t^ super add: anAssociation"},{"name":"at:add:","linesOfCode":11,"sourceCode":"at: key add: value\r\t\"Store value under key. If key already exists, store multiple values as Array\"\r\t\r\t| existingValue newValue |\r\texistingValue := self at: key ifAbsent: [ nil ].\r\tnewValue := existingValue isNil\r\t\tifTrue: [ value ] \r\t\tifFalse: [\r\t\t\texistingValue isArray \r\t\t\t\tifTrue: [ existingValue copyWith: value ]\r\t\t\t\tifFalse: [ Array with: existingValue with: value ] ].\r\t^ self at: key put: newValue \r\r"},{"name":"checkLimitForKey:","linesOfCode":4,"sourceCode":"checkLimitForKey: aKey\r\t\"Signal an exception when the limit, if present, is exceeded.\"\r\t\r\t(self limit notNil and: [ self size >= self limit and: [ (self includesKey: aKey) not ]])\r\t\tifTrue: [ (ZnTooManyDictionaryEntries limit: self limit) signal ].\r"},{"name":"keysAndValuesDo:","linesOfCode":10,"sourceCode":"keysAndValuesDo: block\r\t\"Execute a two argument (key, value) block for each header.\r\tMulti-valued headers are handled transparently.\"\r\r\tsuper keysAndValuesDo: [ :key :value |\r\t\tvalue isArray\r\t\t\tifTrue: [ \r\t\t\t\tvalue do: [ :each | \r\t\t\t\t\tblock value: key value: each ] ]\r\t\t\tifFalse: [\r\t\t\t\tblock value: key value: value ] ]"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: key put: anObject\r\tself checkLimitForKey: key.\r\t^ super at: key put: anObject"},{"name":"unlimited","linesOfCode":2,"sourceCode":"unlimited\r\tself limit: nil"}],"meta":{"name":"ZnMultiValueDictionary class","instanceVariables":[],"methods":[{"name":"defaultLimit","linesOfCode":6,"sourceCode":"defaultLimit\r\t\"Return the maximum number dictionary entries to accept.\r\tUsed by ZnMultiValueDictionary and thus for reading headers, \r\turl query and application form url encoded entity fields.\r\tThis helps to protect us from malicious content.\"\r\t\r\t^ ZnMaximumNumberOfDictionaryEntries value"}],"meta":null}},{"name":"STONTestMap","instanceVariables":[],"methods":[{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: stream\r\tstream\r\t\tnextPut: $(;\r\t\tnextPut: $#;\r\t\tprint: self size;\r\t\tnextPut: $)"}],"meta":{"name":"STONTestMap class","instanceVariables":[],"methods":[{"name":"classTree:","linesOfCode":15,"sourceCode":"classTree: topClass\r\t| map |\r\tmap := IdentityDictionary new.\r\ttopClass withAllSubclasses do: [ :eachClass | | info |\r\t\t(info := self new)\r\t\t\tat: #name put: eachClass name asString;\r\t\t\tat: #comment put: eachClass comment;\r\t\t\tat: #isMeta put: eachClass isMeta;\r\t\t\tat: #methods put: eachClass selectors.\t\t\r\t\tmap at: eachClass put: info ].\r\tmap keysAndValuesDo: [ :eachClass :eachInfo |\r\t\teachClass == topClass\r\t\t\tifFalse: [ eachInfo at: #superclass put: (map at: eachClass superclass) ].\r\t\teachInfo at: #subclasses put: (eachClass subclasses collect: [ :subClass | map at: subClass ]) ].\r\t^ map at: topClass"},{"name":"classTree","linesOfCode":2,"sourceCode":"classTree\r\t^ self classTree: Object"},{"name":"stonName","linesOfCode":2,"sourceCode":"stonName\r\t^ #TestMap"},{"name":"classTreeExtended:","linesOfCode":21,"sourceCode":"classTreeExtended: topClass\r\t| map |\r\tmap := IdentityDictionary new.\r\ttopClass withAllSubclasses do: [ :eachClass | | info methodsInfo |\r\t\t(info := self new)\r\t\t\tat: #name put: eachClass name asString;\r\t\t\tat: #comment put: eachClass comment;\r\t\t\tat: #isMeta put: eachClass isMeta;\r\t\t\tat: #methods put: (methodsInfo := self new).\r\t\teachClass methods do: [ :eachMethod | | methodInfo |\r\t\t\t(methodInfo := self new)\r\t\t\t\tat: #name put: eachMethod selector;\r\t\t\t\tat: #numArgs put: eachMethod numArgs;\r\t\t\t\tat: #class put: info.\r\t\t\tmethodsInfo at: eachMethod selector put: methodInfo ].\r\t\tmap at: eachClass put: info ].\r\tmap keysAndValuesDo: [ :eachClass :eachInfo |\r\t\teachClass == topClass \r\t\t\tifFalse: [ eachInfo at: #superclass put: (map at: eachClass superclass) ].\r\t\teachInfo at: #subclasses put: (eachClass subclasses collect: [ :subClass | map at: subClass ]) ].\r\t^ map at: topClass"},{"name":"classTreeExtended","linesOfCode":2,"sourceCode":"classTreeExtended\r\t^ self classTreeExtended: Object"}],"meta":null}},{"name":"NeoJSONObject","instanceVariables":[],"methods":[{"name":"printOn:","linesOfCode":8,"sourceCode":"printOn: stream\r\t\"I use my JSON representation when printing myself\"\r\r\t[ (NeoJSONWriter on: stream) nextPut: self ]\r\t\ton: Error\r\t\tdo: [ :exception | \r\t\t\tstream\r\t\t\t\tnextPutAll: ' Error printing JSON: ';\r\t\t\t\tnextPutAll: exception printString ]"},{"name":"atPath:put:","linesOfCode":10,"sourceCode":"atPath: keyCollection put: newValue\r\t\"Use each key in keyCollection recursively, create new levels when needed\"\r\t\r\t| target |\r\tkeyCollection ifEmpty: [ ^ self ].\r\ttarget := self.\r\tkeyCollection allButLastDo: [ :each |\r\t\t(target at: each)\r\t\t\tifNil: [ target := target at: each put: target species new ]\r\t\t\tifNotNil: [ :subValue | target := subValue ] ].\r\t^ target at: keyCollection last put: newValue"},{"name":"name","linesOfCode":3,"sourceCode":"name\r\t\"Overwritten to make this accessor available as key\"\r\t\r\t^ self at: #name"},{"name":"atPath:","linesOfCode":8,"sourceCode":"atPath: keyCollection\r\t\"Use each key in keyCollection recursively, stop when nil is encountered\"\r\t\r\t| value |\r\tvalue := self.\r\tkeyCollection do: [ :each |\r\t\tvalue := value at: each.\r\t\tvalue ifNil: [ ^ nil ] ].\r\t^ value "},{"name":"at:","linesOfCode":4,"sourceCode":"at: key\r\t\"I return nil for missing keys.\r\tMy superclass would signal a KeyNotFound.\"\r\t\r\t^ self at: key ifAbsent: [ nil ]"},{"name":"doesNotUnderstand:","linesOfCode":10,"sourceCode":"doesNotUnderstand: message\r\t\"Overwritten so that 'self foo' becomes 'self at: #foo'\r\tand 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned\"\r\t\r\t| key |\r\tkey := message selector.\r\tkey isUnary\r\t\tifTrue: [ ^ self at: key ].\r\t^ (key isKeyword and: [ key numArgs = 1 ])\r\t\tifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]\r\t\tifFalse: [ super doesNotUnderstand: message ]"},{"name":"value","linesOfCode":3,"sourceCode":"value\r\t\"Overwritten to make this accessor available as key\"\r\t\r\t^ self at: #value"}],"meta":{"name":"NeoJSONObject class","instanceVariables":[],"methods":[{"name":"fromString:","linesOfCode":6,"sourceCode":"fromString: string\r\t\"Parse string as JSON, so that maps become instances of me\"\r\r\t^ (NeoJSONReader on: string readStream)\r\t\t\tmapClass: NeoJSONObject;\r\t\t\tpropertyNamesAsSymbols: true;\r\t\t\tnext"}],"meta":null}},{"name":"Array","instanceVariables":[],"methods":[{"name":"asTraitComposition","linesOfCode":4,"sourceCode":"asTraitComposition\r\t^ self isEmpty\r\t\tifTrue: [ TaEmptyComposition new ]\r\t\tifFalse: [ TaSequence withAll: (self collect: [:each | each asTraitComposition]) ]"},{"name":"atWrap:","linesOfCode":12,"sourceCode":"atWrap: index \r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \r    \"Optimized to go through the primitive if possible\"\r    \r    \"(#(11 22 33) atWrap: 3) >>> 33\"\r    \"(#(11 22 33) atWrap: 2) >>> 22\"\r    \"(#(11 22 33) atWrap: 4) >>> 11\"\r    \r    <primitive: 60>\r    ^ self at: index - 1 \\\\ self size + 1 "},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ (self allSatisfy: [:each | each isSelfEvaluating]) and: [self class == Array]"},{"name":"literalEqual:","linesOfCode":6,"sourceCode":"literalEqual: other\r\r\tself class == other class ifFalse: [^ false].\r\tself size = other size ifFalse: [^ false].\r\tself with: other do: [:e1 :e2 |\r\t\t(e1 literalEqual: e2) ifFalse: [^ false]].\r\t^ true"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ { #array . self collect: [ :each | each slvmEncodeAsSExpression ]  }"},{"name":"preMultiplyByArray:","linesOfCode":5,"sourceCode":"preMultiplyByArray: a\r\t\"Answer a+*self where a is an Array.  Arrays are always understood as column vectors,\r\t so an n element Array is an n*1 Array.  This multiplication is legal iff self size = 1.\"\r\r\tself size = 1 ifFalse: [self error: 'dimensions do not conform'].\r\t^a * self first"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createArray: self class: objectModel arrayClass"},{"name":"elementsForwardIdentityTo:","linesOfCode":8,"sourceCode":"elementsForwardIdentityTo: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t The identityHashes remain with the pointers rather than with the objects so that\r\t the objects in this array should still be properly indexed in any existing hashed\r\t structures after the mutation.\"\r\t<primitive: 72 error: ec>\r\tself primitiveFailed"},{"name":"asMapArgument","linesOfCode":2,"sourceCode":"asMapArgument\r\t^ self"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer with the receiver itself.\"\r\r\t^ self"},{"name":"gtDisplayString","linesOfCode":2,"sourceCode":"gtDisplayString\r\r\t^ super gtDisplayString contractTo: 200"},{"name":"preMultiplyByMatrix:","linesOfCode":8,"sourceCode":"preMultiplyByMatrix: m\r\t\"Answer m+*self where m is a Matrix.\"\r\r\tm numberOfColumns = self size ifFalse: [self error: 'dimensions do not conform'].\r\t^ (1 to: m numberOfRows) collect: [ :row | \r\t\t\t| s |\r\t\t\ts := 0.\r\t\t\t1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].\r\t\ts ]"},{"name":"isArray","linesOfCode":2,"sourceCode":"isArray\r\t^true"},{"name":"hasLiteral:","linesOfCode":10,"sourceCode":"hasLiteral: literal\r\t\"Answer true if literal is identical to any literal in this array, even \r\tif imbedded in further array structure. This method is only intended \r\tfor private use by CompiledMethod hasLiteralSymbol:\"\r\r\t| lit |\r\t1 to: self size do: \r\t\t[:index | \r\t\t((lit := self at: index) literalEqual: literal) ifTrue: [^true].\r\t\t(Array == lit class and: [lit hasLiteral: literal]) ifTrue: [^true]].\r\t^false"},{"name":"settingStoreOn:","linesOfCode":11,"sourceCode":"settingStoreOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself isLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement settingStoreOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super settingStoreOn: aStream]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #Array earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder]]"},{"name":"atWrap:put:","linesOfCode":4,"sourceCode":"atWrap: index put: anObject\r\t\"Optimized to go through the primitive if possible\"\r\t<primitive: 61>\r\t^ self at: index - 1 \\\\ self size + 1 put: anObject"},{"name":"hasLiteralSuchThat:","linesOfCode":7,"sourceCode":"hasLiteralSuchThat: testBlock\r\t\"Answer true if testBlock returns true for any literal in this array, even if imbedded in \tfurther Arrays or CompiledMethods.  This method is only intended for private use by \tCompiledMethod \thasLiteralSuchThat:\"\r\t| lit |\r\t1 to: self size do: [:index |\r\t\t(testBlock value: (lit := self at: index)) ifTrue: [^ true].\r\t\t(lit hasLiteralSuchThat: testBlock) ifTrue: [^ true]].\r\t^ false"},{"name":"printAsLiteralFormOn:","linesOfCode":3,"sourceCode":"printAsLiteralFormOn: aStream\r\taStream nextPut: $#.\r\tself printElementsOn: aStream\r"},{"name":"elementsForwardIdentityTo:copyHash:","linesOfCode":10,"sourceCode":"elementsForwardIdentityTo: otherArray copyHash: copyHash\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t If copyHash is true, the identityHashes remain with the pointers rather than with the\r\t objects so that the objects in the receiver should still be properly indexed in any\r\t existing hashed structures after the mutation.  If copyHash is false, then the hashes\r\t of the objects in otherArray remain unchanged.  If you know what you're doing this\r\t may indeed be what you want.\"\r\t<primitive: 249 error: ec>\r\tself primitiveFailed"},{"name":"generateSpec","linesOfCode":9,"sourceCode":"generateSpec\r\t| str spec |\r\tstr := self readStream.\t\r\t\r\tspec :=  OrderedCollection with: #SpecLayoutFrame.\r\t\t\r\t#( leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset: ) do: [:sel |\r\t\tspec add: sel.\r\t\tstr next ifNil: [ spec add: 0 ] ifNotNil: [:value | spec add: value ]].\r\t^ spec asArray"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\tself shouldBePrintedAsLiteral ifTrue: [self printAsLiteralFormOn: aStream. ^ self].\r\tself isSelfEvaluating ifTrue: [self printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"asTestMatrix","linesOfCode":5,"sourceCode":"asTestMatrix\r\r\t| matrix |\r\tmatrix := ParametrizedTestMatrix new.\r\tself do: [ :e | matrix addCase: e ].\r\t^ matrix"},{"name":"asLayoutFrame","linesOfCode":2,"sourceCode":"asLayoutFrame\r\t ^ LayoutFrame new fromArray: self"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\t^self class == Array and: [self allSatisfy: [:each | each isLiteral]]"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"shouldBePrintedAsLiteral","linesOfCode":2,"sourceCode":"shouldBePrintedAsLiteral\r\r\t^self class == Array and: [ self allSatisfy: [ :each | each shouldBePrintedAsLiteral ] ]"},{"name":"+*","linesOfCode":4,"sourceCode":"+* aCollection\r\t\"Premultiply aCollection by self.  aCollection should be an Array or Matrix.\r\t The name of this method is APL's +.x squished into Smalltalk syntax.\"\r\r\t^aCollection preMultiplyByArray: self\r"},{"name":"refersToLiteral:","linesOfCode":3,"sourceCode":"refersToLiteral: literal\r\t^ (self literalEqual: literal) \r\t\tor: [ self hasLiteral: literal ]"},{"name":"fuelReplacement","linesOfCode":4,"sourceCode":"fuelReplacement\r\t^ self == Smalltalk specialObjectsArray\r\t\tifTrue: [ nil ]\r\t\tifFalse: [ self ]"},{"name":"copyWithDependent:","linesOfCode":3,"sourceCode":"copyWithDependent: newElement\r\tself size = 0 ifTrue:[^DependentsArray with: newElement].\r\t^self copyWith: newElement"},{"name":"printAsSelfEvaluatingFormOn:","linesOfCode":4,"sourceCode":"printAsSelfEvaluatingFormOn: aStream\r\r\taStream nextPut: ${.\r\tself do: [:el | el printOn: aStream] separatedBy: [ aStream nextPutAll: '. '].\r\taStream nextPut: $}"},{"name":"gtInspectorFastPrintOn:","linesOfCode":9,"sourceCode":"gtInspectorFastPrintOn: aStream\r\t\"Only scan through a limited number of elements to determine how to print the Array.\"\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) shouldBePrintedAsLiteral ]) ifTrue: [\r\t\tself printAsLiteralFormOn: aStream.  ^ self].\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) isSelfEvaluating ])  ifTrue: [\r\t\tself printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"fuelAccept:","linesOfCode":6,"sourceCode":"fuelAccept: aGeneralMapper\r\t\r\t\"This IF is because there are subclasses of Array that are weak. If we do not put this IF, all subclasses fuel be using the #visitVariableObject:, loosing the capability of the weak\r\tHowever, this method is just to optimize the method lookup of the message #fuelAccept:. If this method is removed, the default behavior of Object shuld work as well. If the performance is not that different, then we can remove this method which has an ugly if.\"\r\t^ self class isWeak\r\t\tifTrue: [ aGeneralMapper visitWeakObject: self ]\r\t\tifFalse: [ aGeneralMapper visitVariableObject: self ]\r\t\r\t"},{"name":"storeOn:","linesOfCode":11,"sourceCode":"storeOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself shouldBePrintedAsLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement storeOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super storeOn: aStream]"},{"name":"closureDescriptionForCaching","linesOfCode":11,"sourceCode":"closureDescriptionForCaching\r\t^ ByteString streamContents: [ :out |\r\t\tout << ${.\r\t\tself doWithIndex: [ :element :index |\r\t\t\tindex > 1 ifTrue: [ \r\t\t\t\tout nextPut: $|\r\t\t\t].\r\t\t\tout nextPutAll: element closureDescriptionForCaching\r\t\t].\r\t\tout << $}.\r\t]"},{"name":"elementsExchangeIdentityWith:","linesOfCode":33,"sourceCode":"elementsExchangeIdentityWith: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t At the same time, all pointers to the elements of otherArray are replaced by\r\t pointers to the corresponding elements of this array.  The identityHashes remain\r\t with the pointers rather than with the objects so that objects in hashed structures\r\t should still be properly indexed after the mutation.\"\r\r\t<primitive: 128 error: ec>\r\t| minimalRequiredSize |\r\tec == #'bad receiver' ifTrue:\r\t\t[^self error: 'receiver must be of class Array'].\r\tec == #'bad argument' ifTrue:\r\t\t[^self error: (otherArray class == Array\r\t\t\t\t\t\tifTrue: ['arg must be of class Array']\r\t\t\t\t\t\tifFalse: ['receiver and argument must have the same size'])].\r\tec == #'inappropriate operation' ifTrue:\r\t\t[^self error: 'can''t become immediates such as SmallIntegers or Characters'].\r\tec == #'no modification' ifTrue:\r\t\t[^self error: 'can''t become immutable objects'].\r\tec == #'object is pinned' ifTrue:\r\t\t[^self error: 'can''t become pinned objects'].\r\tec == #'insufficient object memory' ifTrue:\r\t\t[\r\t\t\tminimalRequiredSize := \r\t\t\t\t(self sumNumbers: [ :anElement | anElement sizeInMemory ]) \r\t\t\t\t+ (otherArray sumNumbers: [ :anElement | anElement sizeInMemory ]).\r\t\t\t\r\t\t\tSmalltalk garbageCollect < minimalRequiredSize ifTrue:\r\t\t\t\t[ (Smalltalk growMemoryByAtLeast: minimalRequiredSize) < minimalRequiredSize ifTrue:[\r\t\t\t\t\tself error: 'Could not allocate enought memory for two way become']].\r\t\t\r\t\t ^self elementsExchangeIdentityWith: otherArray].\r\tself primitiveFailed"}],"meta":{"name":"Array class","instanceVariables":[],"methods":[{"name":"braceWith:","linesOfCode":7,"sourceCode":"braceWith: a\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 1.\r\tarray at: 1 put: a.\r\t^ array"},{"name":"braceWith:with:with:with:","linesOfCode":10,"sourceCode":"braceWith: a with: b with: c with: d\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 4.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\tarray at: 4 put: d.\r\t^ array"},{"name":"new:","linesOfCode":6,"sourceCode":"new: sizeRequested \r\t\"Answer an instance of this class with the number of indexable\r\tvariables specified by the argument, sizeRequested.\r\t\r\tThis is a shortcut (direct call of primitive, no #initialize, for performance\"\r\r\t<primitive: 71>  \"This method runs primitively if successful\"\r\t^ self basicNew: sizeRequested  \"Exceptional conditions will be handled in basicNew:\"\r"},{"name":"braceWith:with:","linesOfCode":8,"sourceCode":"braceWith: a with: b \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 2.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\t^ array"},{"name":"braceWithNone","linesOfCode":4,"sourceCode":"braceWithNone\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ self new: 0"},{"name":"braceStream:","linesOfCode":4,"sourceCode":"braceStream: nElements\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ WriteStream basicNew braceArray: (self new: nElements)\r"},{"name":"braceWith:with:with:","linesOfCode":9,"sourceCode":"braceWith: a with: b with: c \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 3.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\t^ array"},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #Array ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext doWithIndex: [ :eachValue :index |\r\t\t\tresult at: index put: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\t\"A canonicalized empty Array instance.\"\r\t^ #()"}],"meta":null}},{"name":"ByteArray","instanceVariables":[],"methods":[{"name":"signedShortAt:put:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex put: value\r\t^ self int16AtOffset: byteIndex - 1 put: value"},{"name":"packAsDoubleToArity:","linesOfCode":4,"sourceCode":"packAsDoubleToArity: arity\r\t\"In case I sending a buffer to get the contents I need to understand this message. \r\t See AthensCairoCanvas>>getCurrentPoint as an example.\"\r\t^ self packToArity: arity "},{"name":"pointerAtOffset:put:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset put: value\r\t<primitive: 624>\r\t\"Store a pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\tself unsignedByteAt: zeroBasedOffset+i put: (value basicAt: i)].\r\t^value"},{"name":"isNull","linesOfCode":3,"sourceCode":"isNull\r\t\"Answer false since only external addresses can be null\"\r\t^false"},{"name":"longPointerAt:","linesOfCode":8,"sourceCode":"longPointerAt: byteIndex\r\t\"Answer an 8-byte pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress basicNew: 8.\r\t1 to: 8 do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: byteIndex+i-1)].\r\t^addr"},{"name":"float32AtOffset:put:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset put: value\r\t<primitive: 628>\r\t\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1 put: value\r"},{"name":"float64AtOffset:","linesOfCode":3,"sourceCode":"float64AtOffset: zeroBasedOffset\r\t<primitive: 614>\r\t\r\t^ FFIBackend current on: self float64At: zeroBasedOffset + 1\r"},{"name":"int32AtOffset:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset\r\t<primitive: 606>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: true"},{"name":"uint16AtOffset:put:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset put: value\r\t<primitive: 618>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: false"},{"name":"lastIndexOfPKSignature:","linesOfCode":15,"sourceCode":"lastIndexOfPKSignature: aSignature\r\t\"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found\"\r\t| a b c d |\r\ta := aSignature first.\r\tb := aSignature second.\r\tc := aSignature third.\r\td := aSignature fourth.\r\t(self size - 3) to: 1 by: -1 do: [ :i |\r\t\t(((self at: i) = a)\r\t\t\tand: [ ((self at: i + 1) = b)\r\t\t\t\tand: [ ((self at: i + 2) = c)\r\t\t\t\t\tand: [ ((self at: i + 3) = d) ]]])\r\t\t\t\t\t\tifTrue: [ ^i ]\r\t].\r\t^0"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Use a hex representation\"\r\t\r\tstonWriter writeObject: self listSingleton: self hex"},{"name":"oldIntegerAt:put:size:signed:","linesOfCode":7,"sourceCode":"oldIntegerAt: byteOffset put: value size: nBytes signed: aBoolean\r\t\"Primitive. Store the given value as integer of nBytes size\r\tin the receiver. Fail if the value is out of range.\r\tNote: This primitive will access memory in the outer space if\r\tinvoked from ExternalAddress.\"\r\t<primitive: 'primitiveFFIIntegerAtPut' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"platformSizeTAt:put:","linesOfCode":6,"sourceCode":"platformSizeTAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture sizeTTypeSize\r\t\tsigned: false"},{"name":"platformUnsignedLongAt:put:","linesOfCode":6,"sourceCode":"platformUnsignedLongAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize \r\t\tsigned: false"},{"name":"bgraColorAt:","linesOfCode":7,"sourceCode":"bgraColorAt: index\r\t| b g r a |\r\tb := (self unsignedByteAt: index) asFloatFromNormalizedUByte.\r\tg := (self unsignedByteAt: index + 1) asFloatFromNormalizedUByte.\r\tr := (self unsignedByteAt: index + 2) asFloatFromNormalizedUByte.\r\ta := (self unsignedByteAt: index + 3) asFloatFromNormalizedUByte.\r\t^ Float32x4 x: r y: g z: b w: a"},{"name":"floatAt:put:","linesOfCode":2,"sourceCode":"floatAt: byteIndex put: value\r\t^ self float32AtOffset: byteIndex - 1 put: value"},{"name":"nbInt16AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt16AtOffset: zeroBasedOffset put: value\r\t\"Store signed 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedShortAt: zeroBasedOffset + 1 put: value"},{"name":"indexOf:startingAt:","linesOfCode":3,"sourceCode":"indexOf: anInteger startingAt: start\r\r\t(anInteger isInteger and: [ anInteger between: 0 and: 255 ]) ifFalse: [ ^0 ].\r\t^ByteString indexOfAscii: anInteger inString: self startingAt: start"},{"name":"unsignedLongAt:put:bigEndian:","linesOfCode":19,"sourceCode":"unsignedLongAt: index put: value bigEndian: aBool\r\t\"Store a 32bit unsigned integer quantity starting from the given byte index\"\r\t| b0 b1 b2 b3 |\r\tb0 := value bitShift: -24.\r\tb1 := (value bitShift: -16) bitAnd: 255.\r\tb2 := (value bitShift: -8) bitAnd: 255.\r\tb3 := value bitAnd: 255.\r\taBool ifTrue:[\r\t\tself at: index put: b0.\r\t\tself at: index+1 put: b1.\r\t\tself at: index+2 put: b2.\r\t\tself at: index+3 put: b3.\r\t] ifFalse:[\r\t\tself at: index put: b3.\r\t\tself at: index+1 put: b2.\r\t\tself at: index+2 put: b1.\r\t\tself at: index+3 put: b0.\r\t].\r\t^value"},{"name":"boolean8AtOffset:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset\r\t<primitive: 600>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) ~= 0"},{"name":"nbInt8AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt8AtOffset: zeroBasedOffset put: value\r\t\"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self signedByteAt: zeroBasedOffset + 1 put: value"},{"name":"zipped","linesOfCode":7,"sourceCode":"zipped\r\t\"Return a ByteArray containing a GZIP compressed version of the receiver\"\r\t\r\t\"#[ 1 2 3 ] zipped >>> #[31 139 8 0 0 0 0 0 0 0 99 100 98 6 0 29 128 188 85 3 0 0 0]\"\r\r\t^ ByteArray streamContents: [ :out | \r\t\t(GZipWriteStream on: out)\r\t\t\tnextPutAll: self;\r\t\t\tclose ]"},{"name":"pointerAt:","linesOfCode":2,"sourceCode":"pointerAt: byteIndex\r\t^ self pointerAtOffset: byteIndex - 1"},{"name":"nbUInt16AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt16AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedShortAt: zeroBasedOffset + 1 put: value"},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"int16AtOffset:put:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset put: value\r\t<primitive: 619>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: true"},{"name":"int8AtOffset:put:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset put: value\r\t<primitive: 617>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: true"},{"name":"putOn:","linesOfCode":6,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tThis is an optimisation.\r\tReturn self.\"\r\r\taStream nextPutAll: self"},{"name":"uint32AtOffset:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset\r\t<primitive: 605>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: false"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\r\taStream nextPutAll: '#['.\r\tself\r\t\tdo: [ :each | each printOn: aStream ]\r\t\tseparatedBy: [ aStream nextPut: $ ].\r\taStream nextPut: $]"},{"name":"unzipped","linesOfCode":5,"sourceCode":"unzipped\r\t\"Assuming the receiver contains GZIP compressed data, \r\treturn a ByteArray with the decompressed data.\"\r\t\r\t\"#[31 139 8 0 0 0 0 0 0 0 99 100 98 6 0 29 128 188 85 3 0 0 0] unzipped >>> #[1 2 3]\"\r\r\t^ (GZipReadStream on: self) upToEnd"},{"name":"int64AtOffset:put:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset put: value\r\t<primitive: 623>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: true"},{"name":"gtInspectorHexDumpIn:","linesOfCode":16,"sourceCode":"gtInspectorHexDumpIn: composite\r\t<gtInspectorPresentationOrder: 40>\r\tcomposite text\r\t\t\ttitle: 'Hex Dump';\r\t\t\tformat: #asText;\r\t\t\twhen: [ self isCompiledMethod not ];\r\t\t\tdisplay: [ | maxBytes displayStream displayString |\r\t\t\t\tmaxBytes := 10000.\r\t\t\t\tdisplayStream := (String new: maxBytes * 5) writeStream.\r\t\t\t\tself hexDumpOn: displayStream max: maxBytes.\r\t\t\t\tdisplayString := displayStream contents asText.\r\t\t\t\tdisplayString addAttribute: (TextFontReference\r\t\t\t\t\t\ttoFont: (LogicalFont \r\t\t\t\t\t\t\tfamilyName: 'Source Code Pro' \r\t\t\t\t\t\t\tpointSize: StandardFonts defaultFont pointSize)).\r\t\t\t\tdisplayString asText ]"},{"name":"isLiteral","linesOfCode":4,"sourceCode":"isLiteral\r\t\"so that #(1 #[1 2 3] 5) prints itself\"\r\t\"\"\r\t^ self class == ByteArray"},{"name":"asByteArrayOfSize:","linesOfCode":14,"sourceCode":"asByteArrayOfSize: size\r\t\"\r\t\t'34523' asByteArray asByteArrayOfSize: 100.\r\r\t\u0010(((\r\t\t| repeats bytes | \r\t\trepeats := 1000000.\r\t\tbytes := '123456789123456789123456789123456789123456789123456789' asByteArray.\r\t\t [repeats timesRepeat: (bytes asByteArrayOfSize: 1024) ] timeToRun.\r\t)))\"\r\r\t| bytes |\r\tsize < self size\r\t\tifTrue: [^ self error: 'bytearray bigger than ', size asString].\r\tbytes := self asByteArray.\r\t^ (ByteArray new: (size - bytes size)), bytes\r"},{"name":"nbUInt8AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt8AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedByteAt: zeroBasedOffset + 1 put: value"},{"name":"longPointerAt:put:","linesOfCode":8,"sourceCode":"longPointerAt: byteIndex put: value\r\t\"Store an 8-byte pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: 8 do:\r\t\t[:i|\r\t\tself unsignedByteAt: byteIndex+i-1 put: (value basicAt: i)].\r\t^value"},{"name":"shortPointerAt:put:","linesOfCode":8,"sourceCode":"shortPointerAt: byteIndex put: value\r\t\"Store a 4-byte pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: 4 do:\r\t\t[:i|\r\t\tself unsignedByteAt: byteIndex+i-1 put: (value basicAt: i)].\r\t^value"},{"name":"shortAt:put:bigEndian:","linesOfCode":4,"sourceCode":"shortAt: index put: value bigEndian: aBool\r\t\"Store a 16 bit integer quantity starting from the given byte index\"\r\tself unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.\r\t^value"},{"name":"oldFFIPrimFloat64At:","linesOfCode":3,"sourceCode":"oldFFIPrimFloat64At: byteOffset\r\t<primitive:'primitiveFFIDoubleAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"nbFloat32AtOffset:","linesOfCode":3,"sourceCode":"nbFloat32AtOffset: zeroBasedOffset\r\t\"Read 32-bit float at ZERO-based index.\"\r\t^ self floatAt: zeroBasedOffset + 1"},{"name":"unsignedLongAt:put:","linesOfCode":2,"sourceCode":"unsignedLongAt: byteIndex put: value\r\t^ self uint32AtOffset: byteIndex - 1 put: value"},{"name":"decodeWith:","linesOfCode":5,"sourceCode":"decodeWith: encoding\r\t\"Produce a String that decodes the receiver, using a specified encoding.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\"\r\t\r\t\"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] decodeWith: #utf8\"\r\t\r\t^ encoding asZnCharacterEncoder decodeBytes: self"},{"name":"uint16AtOffset:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset\r\t<primitive: 603>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: false"},{"name":"pointerAt:put:","linesOfCode":2,"sourceCode":"pointerAt: byteIndex put: value\r\t^ self pointerAtOffset: byteIndex - 1 put: value"},{"name":"byteAt:put:","linesOfCode":3,"sourceCode":"byteAt: index put: value\r\t<primitive: 61>\r\t^self at: index put: value"},{"name":"platformBitAt:put:","linesOfCode":6,"sourceCode":"platformBitAt: byteOffset put: value\r\t\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize\r\t\tsigned: true"},{"name":"signedLongLongAt:put:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex put: value\r\t^ self int64AtOffset: byteIndex - 1 put: value"},{"name":"shortPointerAt:","linesOfCode":8,"sourceCode":"shortPointerAt: byteIndex\r\t\"Answer a 4-byte pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress basicNew: 4.\r\t1 to: 4 do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: byteIndex+i-1)].\r\t^addr"},{"name":"nbInt8AtOffset:","linesOfCode":3,"sourceCode":"nbInt8AtOffset: zeroBasedOffset\r\t\"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedByteAt: zeroBasedOffset + 1"},{"name":"nbFloat64AtOffset:put:","linesOfCode":3,"sourceCode":"nbFloat64AtOffset: zeroBasedOffset put: value\r\t\"Store 64-bit float at ZERO-based index.\"\r\t^ self doubleAt: zeroBasedOffset + 1 put: value"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createObjectBytes: self class: objectModel byteArrayClass"},{"name":"bitXor:","linesOfCode":11,"sourceCode":"bitXor: aByteArray \r\t| answer |\r\tanswer := self copy.\r\t1 \r\t\tto: (self size min: aByteArray size)\r\t\tdo: \r\t\t\t[ :each | \r\t\t\tanswer \r\t\t\t\tat: each\r\t\t\t\tput: ((self at: each) bitXor: (aByteArray at: each)) ].\r\t^ answer"},{"name":"asSocketAddress","linesOfCode":2,"sourceCode":"asSocketAddress\r\t^SocketAddress fromOldByteAddress: self"},{"name":"sBGR_A_colorAt:","linesOfCode":7,"sourceCode":"sBGR_A_colorAt: index\r\t| b g r a |\r\tb := (self unsignedByteAt: index) asFloatFromNormalizedUByte decodeSRGBComponent.\r\tg := (self unsignedByteAt: index + 1) asFloatFromNormalizedUByte decodeSRGBComponent.\r\tr := (self unsignedByteAt: index + 2) asFloatFromNormalizedUByte decodeSRGBComponent.\r\ta := (self unsignedByteAt: index + 3) asFloatFromNormalizedUByte.\r\t^ Float32x4 x: r y: g z: b w: a"},{"name":"char16AtOffset:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset\r\t<primitive: 611>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 2 signed: false) asCharacter"},{"name":"unsignedLongLongAt:","linesOfCode":2,"sourceCode":"unsignedLongLongAt: byteIndex\r\t^ self uint64AtOffset: byteIndex - 1"},{"name":"signedCharAt:","linesOfCode":2,"sourceCode":"signedCharAt: byteOffset\r\t^ self char8AtOffset: byteOffset - 1"},{"name":"signedShortAt:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex\r\t^ self int16AtOffset: byteIndex - 1"},{"name":"platformSizeTAt:","linesOfCode":5,"sourceCode":"platformSizeTAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture sizeTTypeSize\r\t\tsigned: false"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"signedLongLongAt:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex\r\t^ self int64AtOffset: byteIndex - 1"},{"name":"uint32AtOffset:put:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset put: value\r\t<primitive: 620>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: false"},{"name":"pointerAtOffset:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset\r\t<primitive: 609>\r\t\"Answer a pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress new.\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: zeroBasedOffset+i)].\r\t^addr"},{"name":"hex","linesOfCode":7,"sourceCode":"hex\r\t\"Answer a lowercase hexadecimal String representation of the receiver\"\r\t\t\r\t^ String\r\t\tnew: self size * 2\r\t\tstreamContents: [ :out |\r\t\t\tself do: [ :each | each printLowercaseHexByteOn: out ] ]"},{"name":"signedCharAt:put:","linesOfCode":2,"sourceCode":"signedCharAt: byteIndex put: aCharacter\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"nbInt32AtOffset:","linesOfCode":3,"sourceCode":"nbInt32AtOffset: zeroBasedOffset\r\t\"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1"},{"name":"uint64AtOffset:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset\r\t<primitive: 607>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: false"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"},{"name":"unsignedByteAt:put:","linesOfCode":2,"sourceCode":"unsignedByteAt: byteIndex put: value\r\t^ self uint8AtOffset: byteIndex - 1 put: value"},{"name":"signedByteAt:","linesOfCode":3,"sourceCode":"signedByteAt: byteOffset\r    \"Return a 8bit signed integer starting at the given byte offset\"\r    ^self integerAt: byteOffset size: 1 signed: true"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^self at: index"},{"name":"unpackHandleFromArity:","linesOfCode":4,"sourceCode":"unpackHandleFromArity: arity\r\t\"This will 'unpack' a long (handle) from a certain arity. See #packToArity: for a better explanation.\"\r\r\tarity > 1 ifTrue: [ ^ self error: 'Use ExternalAddress instead!' ].\r\t^ self unsignedLongAt: 1\r"},{"name":"doubleAt:bigEndian:","linesOfCode":12,"sourceCode":"doubleAt: index bigEndian: bool \r\t\"Return a 64 bit float starting from the given byte index\"\r\t| w1 w2 dbl |\r\tw1 := self unsignedLongAt: index bigEndian: bool.\r\tw2 := self unsignedLongAt: index + 4 bigEndian: bool.\r\tdbl := Float new: 2. \r\tbool\r\t\tifTrue: [dbl basicAt: 1 put: w1.\r\t\t\tdbl basicAt: 2 put: w2]\r\t\tifFalse: [dbl basicAt: 1 put: w2.\r\t\t\tdbl basicAt: 2 put: w1].\r\t^ dbl"},{"name":"readHexFrom:","linesOfCode":4,"sourceCode":"readHexFrom: characterReadStream\r\t\"Initialize the receiver from a hexadecimal representation.\"\r\t\r\t1 to: self size do: [ :offset |\r\t\tself at: offset put: (Integer readHexByteFrom: characterReadStream) ]"},{"name":"nbUInt8AtOffset:","linesOfCode":3,"sourceCode":"nbUInt8AtOffset: zeroBasedOffset\r\t\"Reads unsigned 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedByteAt: zeroBasedOffset + 1"},{"name":"bgraColorAt:put:","linesOfCode":11,"sourceCode":"bgraColorAt: index put: aColor\r\t| r g b a |\r\tr := aColor r asNormalizedUByte.\r\tg := aColor g asNormalizedUByte.\r\tb := aColor b asNormalizedUByte.\r\ta := aColor a asNormalizedUByte.\r\tself\r\t\tat: index put: b;\r\t\tat: index + 1 put: g;\r\t\tat: index + 2 put: r;\r\t\tat: index + 3 put: a"},{"name":"int64AtOffset:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset\r\t<primitive: 608>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: true"},{"name":"base64Encoded","linesOfCode":8,"sourceCode":"base64Encoded\r\t\"Encode the receiver using Base64, returning a String.\r\tBase64 encoding is a technique to represent binary data as ASCII text.\r\tThe inverse operation is String>>#base64Decoded\"\r\t\r\t\"(0 to: 255) asByteArray base64Encoded\"\r\t\"(Integer primesUpTo: 255) asByteArray base64Encoded\"\r\t\"'Hello World!' utf8Encoded base64Encoded\"\r\t\r\t^ ZnBase64Encoder new encode: self"},{"name":"unsignedLongAt:","linesOfCode":2,"sourceCode":"unsignedLongAt: byteIndex\r\t^ self uint32AtOffset: byteIndex - 1"},{"name":"nbUlongAt:put:","linesOfCode":3,"sourceCode":"nbUlongAt: index put: value\r\t\"Store unsigned long at one-based index.\"\r\t^ self unsignedLongAt: index put: value\t"},{"name":"char32AtOffset:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset\r\t<primitive: 612>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 4 signed: false) asCharacter"},{"name":"integerAt:size:signed:","linesOfCode":6,"sourceCode":"integerAt: byteOffset size: nBytes signed: aBoolean\r\r\t^ FFIBackend current\r\t\t  integerOfObject: self\r\t\t  at: byteOffset\r\t\t  size: nBytes\r\t\t  signed: aBoolean"},{"name":"unsignedCharAt:put:","linesOfCode":2,"sourceCode":"unsignedCharAt: byteIndex put: aCharacter\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"nbFloat32AtOffset:put:","linesOfCode":3,"sourceCode":"nbFloat32AtOffset: zeroBasedOffset put: value\r\t\"Store 32-bit float at ZERO-based index.\"\r\t^ self floatAt: zeroBasedOffset + 1 put: value"},{"name":"nbUInt16AtOffset:","linesOfCode":3,"sourceCode":"nbUInt16AtOffset: zeroBasedOffset\r\t\"Reads unsigned 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedShortAt: zeroBasedOffset + 1"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitBytesObject: self"},{"name":"storeOn:","linesOfCode":6,"sourceCode":"storeOn: aStream\r\taStream nextPutAll: '#['.\r\tself\r\t\tdo: [ :each | each storeOn: aStream ]\r\t\tseparatedBy: [ aStream nextPut: $ ].\r\taStream nextPut: $]"},{"name":"unsignedShortAt:put:","linesOfCode":2,"sourceCode":"unsignedShortAt: byteIndex put: value\r\t^ self uint16AtOffset: byteIndex - 1 put: value"},{"name":"floatAt:","linesOfCode":2,"sourceCode":"floatAt: byteIndex\r\t^ self float32AtOffset: byteIndex - 1"},{"name":"signedByteAt:put:","linesOfCode":3,"sourceCode":"signedByteAt: byteOffset put: value\r\t\"Store a 8bit signed integer starting at the given byte offset\"\r\t^self integerAt: byteOffset put: value size: 1 signed: true"},{"name":"gtInspectorBytesIn:","linesOfCode":24,"sourceCode":"gtInspectorBytesIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t^ composite table\r\t\ttitle: 'Bytes';\r\t\tdisplay: [ \r\t\t\t(self size < 2048 or: [ self confirm: 'Looking at more than 2048 bytes might be slow. Continue ?' ])\r\t\t\t\tifTrue: [ {\r\t\t\t\t\t'hex string' -> (String streamContents: [ :out | \r\t\t\t\t\t\tself printHexOn: out ]).\r\t\t\t\t\t'hex lines' -> (String streamContents: [ :out |\r\t\t\t\t\t\tself withIndexDo: [ :each :index |\r\t\t\t\t\t\t\tindex = 1 ifFalse: [ \r\t\t\t\t\t\t\t\tindex - 1 \\\\ 8 = 0 ifTrue: [ out cr ] ifFalse: [ out space ] ].\r\t\t\t\t\t\t\t\teach printHexByteOn: out ] ]).\r\t\t\t\t\t'latin1' -> ([ ZnCharacterEncoder latin1 decodeBytes: self ]\r\t\t\t\t\t\t\t\t\t\t\ton: ZnCharacterEncodingError do: [ :exception | exception ]).\r\t\t\t\t\t'utf8' -> ([ ZnUTF8Encoder new decodeBytes: self ] \r\t\t\t\t\t\t\t\t\t\t\ton: ZnCharacterEncodingError do: [ :exception | exception ]).\r\t\t\t\t\t'integer' -> self asInteger.\r\t\t\t\t\t'integer reversed' -> self reversed asInteger } ]\r\t\t\t\tifFalse: [ #() ] ];\r\t\tcolumn: 'Key' evaluated: #key;\r\t\tcolumn: 'Value' evaluated: #value;\r\t\tsend: #value"},{"name":"nbInt64AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt64AtOffset: zeroBasedOffset put: value\r\t\"Store signed 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1 put: value"},{"name":"int32AtOffset:put:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset put: value\r\t<primitive: 621>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: true"},{"name":"unsignedShortAt:put:bigEndian:","linesOfCode":10,"sourceCode":"unsignedShortAt: index put: value bigEndian: aBool\r\t\"Store a 16 bit unsigned integer quantity starting from the given byte index\"\r\taBool ifTrue:[\r\t\tself at: index put: (value bitShift: -8).\r\t\tself at: index+1 put: (value bitAnd: 255).\r\t] ifFalse:[\r\t\tself at: index+1 put: (value bitShift: -8).\r\t\tself at: index put: (value bitAnd: 255).\r\t].\r\t^value"},{"name":"unsignedShortAt:bigEndian:","linesOfCode":5,"sourceCode":"unsignedShortAt: index bigEndian: aBool\r\t\"Return a 16 bit unsigned integer quantity starting from the given byte index\"\r\t^aBool \r\t\tifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]\r\t\tifFalse:[((self at: index+1) bitShift: 8) + (self at: index)]."},{"name":"utf8Decoded","linesOfCode":5,"sourceCode":"utf8Decoded\r\t\"Produce a String decoding the receiver using UTF-8,\r\tthe recommended encoding for Strings, unless you know what you are doing.\"\r\r\t\"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] utf8Decoded\"\r\t\r\t^ self decodeWith: ZnCharacterEncoder utf8"},{"name":"uint8AtOffset:put:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset put: value\r\t<primitive: 616>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: false"},{"name":"nbUlongAt:","linesOfCode":3,"sourceCode":"nbUlongAt: index\r\t\"Read unsigned long at one-based index.\"\r\t^ self unsignedLongAt: index"},{"name":"oldFFIPrimFloat32At:","linesOfCode":3,"sourceCode":"oldFFIPrimFloat32At: byteOffset\r\t<primitive:'primitiveFFIFloatAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"nbUInt32AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt32AtOffset: zeroBasedOffset  put: value\r\t\"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongAt: zeroBasedOffset + 1 put: value"},{"name":"nbInt64AtOffset:","linesOfCode":3,"sourceCode":"nbInt64AtOffset: zeroBasedOffset\r\t\"Reads signed 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1"},{"name":"destroy","linesOfCode":4,"sourceCode":"destroy\r\t1 to: self size do: \r\t\t[ : x |\r\t\tself at: x put: 0 ]"},{"name":"utf8ToIso","linesOfCode":35,"sourceCode":"utf8ToIso\r\t| s i v1 v2 v3 v4 |\r\ts := WriteStream on: (String new: self size).\r\ti := 1.\r\t[i <= self size] whileTrue:\r\t\t[v1 := self at: i.\r\t\t i := i + 1.\r\t\t v1 < 128\r\t\t\tifTrue: [ s nextPut: v1 asCharacter ]\r\t\t\tifFalse:\r\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t[self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].\r\t\t\t\t v2 := self at: i.\r\t\t\t\t i := i + 1.\r\t\t\t\t v1 < 224\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[s nextPut: ((v2 bitAnd: 63) bitOr: ((v1 bitAnd: 31) bitShift: 6)) asCharacter]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t\t\t[self error: 'illegal end-of-string, expected 3rd byte of UTF-8'].\r\t\t\t\t\t\t v3 := self at: i.\r\t\t\t\t\t\t i := i + 1.\r\t\t\t\t\t\t v1 < 240\r\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t[s nextPut: ((v3 bitAnd: 63) bitOr: (((v2 bitAnd: 63) bitShift: 6) bitOr: ((v1 bitAnd: 31) bitShift: 12))) asCharacter]\r\t\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t\t\t[self error: 'illegal end-of-string, expected 4th byte of UTF-8'].\r\t\t\t\t\t\t\t v4 := self at: i.\r\t\t\t\t\t\t\t i := i + 1.\r\t\t\t\t\t\t\t v1 < 248\r\t\t\t\t\t\t\t\t\tifTrue: [s nextPut: ((v4 bitAnd: 63) bitOr: (((v3 bitAnd: 63) bitShift: 6) bitOr: (((v2 bitAnd: 63) bitShift: 12) bitOr: ((v1 bitAnd: 15) bitShift: 18)))) asCharacter]\r\t\t\t\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t\t\t\t[self error: 'illegal UTF-8 character']]]]].\r\t^s contents"},{"name":"defaultElement","linesOfCode":2,"sourceCode":"defaultElement\r\r\t^0"},{"name":"shortAt:bigEndian:","linesOfCode":5,"sourceCode":"shortAt: index bigEndian: aBool\r\t\"Return a 16 bit integer quantity starting from the given byte index\"\r\t| uShort |\r\tuShort := self unsignedShortAt: index bigEndian: aBool.\r\t^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size values: self"},{"name":"asInteger","linesOfCode":7,"sourceCode":"asInteger\r\t\"Convert me to an Integer, network byte order, most significant byte first, big endian\"\r\t\r\t| integer |\r\tinteger := 0.\r\tself withIndexDo: [ :each :index | \r\t\tinteger := integer + (each bitShift: (self size - index) * 8) ].\r\t^ integer"},{"name":"doubleAt:put:bigEndian:","linesOfCode":11,"sourceCode":"doubleAt: index put: value bigEndian: bool \r\t\"Store a 64 bit float starting from the given byte index\"\r\t| w1 w2 |\r\tbool\r\t\tifTrue: [w1 := value basicAt: 1.\r\t\t\tw2 := value basicAt: 2]\r\t\tifFalse: [w1 := value basicAt: 2.\r\t\t\tw2 := value basicAt: 1]. \r\tself unsignedLongAt: index put: w1 bigEndian: bool.\r\tself unsignedLongAt: index + 4 put: w2 bigEndian: bool.\r\t^ value"},{"name":"asByteArrayPointer","linesOfCode":3,"sourceCode":"asByteArrayPointer\r\t\"Return a ByteArray describing a pointer to the contents of the receiver.\"\r\t^self shouldNotImplement"},{"name":"nbLongAt:","linesOfCode":3,"sourceCode":"nbLongAt: index\r\t\"Read signed long at one-based index\"\r\t^ self signedLongAt: index"},{"name":"sBGR_A_colorAt:put:","linesOfCode":11,"sourceCode":"sBGR_A_colorAt: index put: aColor\r\t| r g b a |\r\tr := aColor r encodeSRGBComponent asNormalizedUByte.\r\tg := aColor g encodeSRGBComponent asNormalizedUByte.\r\tb := aColor b encodeSRGBComponent asNormalizedUByte.\r\ta := aColor a asNormalizedUByte.\r\tself\r\t\tat: index put: b;\r\t\tat: index + 1 put: g;\r\t\tat: index + 2 put: r;\r\t\tat: index + 3 put: a"},{"name":"oldFFIPrimFloat64At:put:","linesOfCode":5,"sourceCode":"oldFFIPrimFloat64At: byteOffset put: value\r\t<primitive:'primitiveFFIDoubleAtPut' module:'SqueakFFIPrims'>\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #oldFFIPrimFloat64At:put: index: byteOffset value: value ].\r\t^self primitiveFailed"},{"name":"stonContainSubObjects","linesOfCode":2,"sourceCode":"stonContainSubObjects \r\t^ false"},{"name":"platformLongAt:","linesOfCode":5,"sourceCode":"platformLongAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize \r\t\tsigned: true"},{"name":"platformUnsignedLongAt:","linesOfCode":5,"sourceCode":"platformUnsignedLongAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize\r\t\tsigned: false"},{"name":"structAt:length:","linesOfCode":7,"sourceCode":"structAt: byteOffset length: length\r\t\"Return a structure of the given length starting at the indicated byte offset.\"\r\t| value |\r\tvalue := ByteArray new: length.\r\t1 to: length do:[:i|\r\t\tvalue unsignedByteAt: i put: (self unsignedByteAt: byteOffset+i-1)].\r\t^value"},{"name":"isExternalAddress","linesOfCode":3,"sourceCode":"isExternalAddress\r\t\"Return true if the receiver describes the address of an object in the outside world\"\r\t^false"},{"name":"nbLongAt:put:","linesOfCode":3,"sourceCode":"nbLongAt: index put: value\r\t\"Store signed long at one-based index\"\r\t^ self signedLongAt: index put: value"},{"name":"booleanAt:","linesOfCode":5,"sourceCode":"booleanAt: byteIndex\r\t\"Returns the boolean the byte at index byteOffset of this ByteArray represents in the C convention ( A byte representing the 0 integer corresponds to false, while all other integers corresponds to true).\"\r\t\r\t\"(#[1 2 0 4] booleanAt: 2) >>> true.\"\r\t\"(#[1 2 0 4] booleanAt: 3) >>> false.\"\r\t\r\t^ self boolean8AtOffset: byteIndex - 1"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":13,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\treplacement isString\r\t\tifFalse:\r\t\t\t[super replaceFrom: start to: stop with: replacement startingAt: repStart]\r\t\tifTrue:\r\t\t\t[ \"use String>>byteAt: to mimic prim 105\"\r\t\t\t| index repOff |\r\t\t\trepOff := repStart - start.\r\t\t\tindex := start - 1.\r\t\t\t[(index := index + 1) <= stop]\r\t\t\t\twhileTrue: [self at: index put: (replacement byteAt: repOff + index)]]\r"},{"name":"unsignedLongAt:bigEndian:","linesOfCode":19,"sourceCode":"unsignedLongAt: index bigEndian: aBool\r\t\"Return a 32bit unsigned integer quantity starting from the given byte index\"\r\t| b0 b1 b2 w |\r\taBool ifTrue:[\r\t\tb0 := self at: index.\r\t\tb1 := self at: index+1.\r\t\tb2 := self at: index+2.\r\t\tw := self at: index+3.\r\t] ifFalse:[\r\t\tw := self at: index.\r\t\tb2 := self at: index+1.\r\t\tb1 := self at: index+2.\r\t\tb0 := self at: index+3.\r\t].\r\t\"Minimize LargeInteger arithmetic\"\r\tb2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].\r\tb1 = 0 ifFalse:[w := (b1 bitShift: 16) + w].\r\tb0 = 0 ifFalse:[w := (b0 bitShift: 24) + w].\r\t^w"},{"name":"signedLongAt:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex\r\t^ self int32AtOffset: byteIndex - 1"},{"name":"voidAt:","linesOfCode":3,"sourceCode":"voidAt: byteOffset\r\t\"no accessors for void\"\r\t^self shouldNotImplement"},{"name":"referenceStructAt:length:","linesOfCode":4,"sourceCode":"referenceStructAt: byteOffset length: length\r\t^ FFIExternalStructureReferenceHandle \r\t\thandle: self \r\t\toffset: byteOffset"},{"name":"nbFloat64AtOffset:","linesOfCode":3,"sourceCode":"nbFloat64AtOffset: zeroBasedOffset\r\t\"Read 64-bit float at ZERO-based index.\"\r\t^ self doubleAt: zeroBasedOffset + 1"},{"name":"integerAt:put:size:signed:","linesOfCode":7,"sourceCode":"integerAt: byteOffset put: value size: nBytes signed: aBoolean\r\r\t^ FFIBackend current\r\t\t  integerOfObject: self\r\t\t  at: byteOffset\r\t\t  put: value\r\t\t  size: nBytes\r\t\t  signed: aBoolean"},{"name":"writeString:","linesOfCode":2,"sourceCode":"writeString: aString\r\tLibC memCopy: aString to: self size: aString size"},{"name":"unsignedLongLongAt:put:","linesOfCode":2,"sourceCode":"unsignedLongLongAt: byteIndex put: value\r\t^ self uint64AtOffset: byteIndex - 1 put: value"},{"name":"packAsFloatToArity:","linesOfCode":4,"sourceCode":"packAsFloatToArity: arity\r\t\"In case I sending a buffer to get the contents I need to understand this message. \r\t See AthensCairoCanvas>>getCurrentPoint as an example.\"\r\t^ self packToArity: arity "},{"name":"llvmPrintEscapedStringOn:addNull:","linesOfCode":13,"sourceCode":"llvmPrintEscapedStringOn: aStream addNull: addNull\r\t| element |\r\taStream nextPut: $\".\r\tself do: [ :byte |\r\t\telement := byte asCharacter.\r\t\t(Character space <= element and: [ element <= $~ and: [('\\\"' includes: element) not]]) ifTrue: [ \r\t\t\taStream nextPut: element\r\t\t] ifFalse: [\r\t\t\taStream nextPut: $\\; nextPutAll: (byte printStringBase: 16 length: 2 padded: true)\r\t\t]\r\t].\r\t\r\taddNull ifTrue: [ aStream nextPutAll: '\\00' ].\r\taStream nextPut: $\".\r"},{"name":"signedLongAt:put:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex put: value\r\t^ self int32AtOffset: byteIndex - 1 put: value"},{"name":"char8AtOffset:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset\r\t<primitive: 610>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) asCharacter"},{"name":"oldFFIPrimFloat32At:put:","linesOfCode":5,"sourceCode":"oldFFIPrimFloat32At: byteOffset put: value\r\t<primitive:'primitiveFFIFloatAtPut' module:'SqueakFFIPrims'>\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #oldFFIPrimFloat32At:put: index: byteOffset value: value ].\r\t^self primitiveFailed"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString\r\r\t^ WideString fromByteArray: self.\r"},{"name":"longAt:bigEndian:","linesOfCode":19,"sourceCode":"longAt: index bigEndian: aBool\r\t\"Return a 32bit integer quantity starting from the given byte index\"\r\t| b0 b1 b2 w h |\r\taBool ifTrue:[\r\t\tb0 := self at: index.\r\t\tb1 := self at: index+1.\r\t\tb2 := self at: index+2.\r\t\tw := self at: index+3.\r\t] ifFalse:[\r\t\tw := self at: index.\r\t\tb2 := self at: index+1.\r\t\tb1 := self at: index+2.\r\t\tb0 := self at: index+3.\r\t].\r\t\"Minimize LargeInteger arithmetic\"\r\th := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.\r\tb2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].\r\th = 0 ifFalse:[w := (h bitShift: 16) + w].\r\t^w"},{"name":"unsignedShortAt:","linesOfCode":2,"sourceCode":"unsignedShortAt: byteIndex\r\t^ self uint16AtOffset: byteIndex - 1"},{"name":"nbInt16AtOffset:","linesOfCode":3,"sourceCode":"nbInt16AtOffset: zeroBasedOffset\r\t\"Reads signed 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedShortAt: zeroBasedOffset + 1"},{"name":"oldIntegerAt:size:signed:","linesOfCode":6,"sourceCode":"oldIntegerAt: byteOffset size: nBytes signed: aBoolean\r\t\"Primitive. Return an integer of nBytes size from the receiver.\r\tNote: This primitive will access memory in the outer space if\r\tinvoked from ExternalAddress.\"\r\t<primitive: 'primitiveFFIIntegerAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"doubleAt:put:","linesOfCode":2,"sourceCode":"doubleAt: byteIndex put: value\r\t^ self float64AtOffset: byteIndex - 1 put: value"},{"name":"asByteArray","linesOfCode":2,"sourceCode":"asByteArray\r\t^ self"},{"name":"char32AtOffset:put:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset put: value\r\t<primitive: 627>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 4 signed: false"},{"name":"unsignedByteAt:","linesOfCode":2,"sourceCode":"unsignedByteAt: byteIndex\r\t^ self uint8AtOffset: byteIndex - 1"},{"name":"platformUnsignedBitAt:put:","linesOfCode":6,"sourceCode":"platformUnsignedBitAt: byteOffset put: value\r\t\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize\r\t\tsigned: false"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self"},{"name":"printHexOn:","linesOfCode":4,"sourceCode":"printHexOn: characterWriteStream\r\t\"Print a hexadecimal representation of the receiver on characterWriteStream\r\tusing exactly 2 characters for each byte\"\r\r\tself do: [ :each | each printHexByteOn: characterWriteStream ]"},{"name":"packToArity:","linesOfCode":26,"sourceCode":"packToArity: arity\r\t\"This is complicated... I assuming this ways of calling a function: \r\t \r   arity == 1: \r\t-----------\r\tByteArray works as pointer buffer of single pointer to something: \r\tex 1)\r\t\tbuffer := ByteArray new: 4.\r\t\tself ffiCall: #( void function (int *buffer) ).\r\tex 2)\r\t\tbuffer := 'Hello, World' asByteArray.\r\t\tself ffiCall: #( void function (char *buffer) ).\r\t\r\tarity > 1: \r\t----------\r\tByteArray works as pointer to allocate results:\r\tex 1)\r\t\tpointer := ByteArray new: (FFIExternalType pointerSize).\r\t\tself ffiCall: #( void function ( char **answer )).\r\t   \r\tIn this case this will not work fine because content of ByteArray needs to be a \r\tpointer too, and then it needs to be allocated in the heap... while this could be \r\tmanaged, I'm puting for the moment just an error and a recommendation of using an \r\tExternalAddress.\r\t\"\r\tarity = 1 ifTrue: [ ^ self ].\r\tself error: 'Use ExternalAddress instead!'"},{"name":"platformBitAt:","linesOfCode":5,"sourceCode":"platformBitAt: byteOffset\r\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize \r\t\tsigned: true"},{"name":"float32AtOffset:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset\r\t<primitive: 613>\r\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1"},{"name":"nbInt32AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt32AtOffset: zeroBasedOffset put: value\r\t\"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1 put: value"},{"name":"float64AtOffset:put:","linesOfCode":6,"sourceCode":"float64AtOffset: zeroBasedOffset put: value\r\r\t<primitive: 629>\r\t^ FFIBackend current\r\t\t  on: self\r\t\t  float64At: zeroBasedOffset + 1\r\t\t  put: value"},{"name":"uint64AtOffset:put:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset put: value\r\t<primitive: 622>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: false"},{"name":"char16AtOffset:put:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset put: value\r\t<primitive: 626>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 2 signed: false"},{"name":"nbUInt64AtOffset:","linesOfCode":3,"sourceCode":"nbUInt64AtOffset: zeroBasedOffset\r\t\"Reads unsigned 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongLongAt: zeroBasedOffset + 1"},{"name":"readStringUTF8","linesOfCode":2,"sourceCode":"readStringUTF8\r\t^ (ExternalData fromHandle: self type: ExternalType string) readStringUTF8."},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t\"#hash is implemented, because #= is implemented\"\r\r\t^self class\r\t\thashBytes: self\r\t\tstartingWith: self species hash"},{"name":"voidAt:put:","linesOfCode":3,"sourceCode":"voidAt: byteOffset put: value\r\t\"no accessors for void\"\r\t^self shouldNotImplement"},{"name":"platformLongAt:put:","linesOfCode":6,"sourceCode":"platformLongAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize\r\t\tsigned: true"},{"name":"int16AtOffset:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset\r\t<primitive: 604>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: true"},{"name":"readString","linesOfCode":2,"sourceCode":"readString\r\t^ (ExternalData fromHandle: self type: ExternalType string) readString"},{"name":"nbUInt32AtOffset:","linesOfCode":3,"sourceCode":"nbUInt32AtOffset: zeroBasedOffset\r\t\"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongAt: zeroBasedOffset + 1"},{"name":"hexDumpOn:max:","linesOfCode":39,"sourceCode":"hexDumpOn: aStream max: maxBytes\r\t\"Print a hex dump of the receiver on the supplied stream, up to maxBytes long\"\r\r\t| ch i string remainder |\r\r\ti := 0.\r\tself readStreamDo: [ :stream |\r\t\tch := stream next.\r\t\t[ch notNil and: [ i < maxBytes ]] whileTrue: [ \r\t\t\tremainder := i \\\\ 16.\r\t\t\tremainder = 0 ifTrue: [ \r\t\t\t\ti = 0 ifFalse: [ aStream cr ].\r\t\t\t\taStream \r\t\t\t\t\t<< (i printPaddedWith: $0 to: 8 base: 16);\r\t\t\t\t\t<< '  '.\r\t\t\t\tstring := String new writeStream ].\r\t\t\tch printHexByteOn: aStream.\r\t\t\taStream space.\r\t\t\t(ch between: 32 and: 126) ifTrue: \r\t\t\t\t[ string nextPut: (Character value: ch) ]\r\t\t\tifFalse:\r\t\t\t\t[ string nextPut: $. ].\r\t\t\tremainder = 15 ifTrue: [ \r\t\t\t\taStream\r\t\t\t\t\t<< '  |';\r\t\t\t\t\t<< string contents;\r\t\t\t\t\t<< '|' ].\r\t\t\tch := stream next.\r\t\t\ti := i + 1 ].\r\t\tremainder := i \\\\ 16.\r\t\t(ch isNil and: [remainder between: 1 and: 15]) ifTrue: [ \r\t\t\t(16 - remainder) timesRepeat: [ aStream nextPutAll: '   ' ].\r\t\t\taStream\r\t\t\t\t<< '  |';\r\t\t\t\t<< string contents.\r\t\t\t(16 - remainder timesRepeat: [ aStream nextPut: Character space ]).\r\t\t\taStream\r\t\t\t\t<< '|' ].\r\t\taStream cr.\r\t\tself size > maxBytes ifTrue: \r\t\t\t[ aStream nextPutAll: '  ... truncated ...'; cr ] ].\r"},{"name":"nbUInt64AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt64AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedLongLongAt: zeroBasedOffset + 1 put: value"},{"name":"doubleAt:","linesOfCode":2,"sourceCode":"doubleAt: byteIndex\r\t^ self float64AtOffset: byteIndex - 1"},{"name":"asExternalPointer","linesOfCode":3,"sourceCode":"asExternalPointer\r\t\"Convert the receiver assuming that it describes a pointer to an object.\"\r\t^ self pointerAt: 1"},{"name":"uint8AtOffset:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset\r\t<primitive: 601>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: false"},{"name":"structAt:put:length:","linesOfCode":5,"sourceCode":"structAt: byteOffset put: value length: length\r\t\"Store a structure of the given length starting at the indicated byte offset.\"\r\t1 to: length do:[:i|\r\t\tself unsignedByteAt: byteOffset+i-1 put: (value unsignedByteAt: i)].\r\t^value"},{"name":"floatAt:bigEndian:","linesOfCode":3,"sourceCode":"floatAt: index bigEndian: boolean \r\t^ Float\r\t\tfromIEEE32Bit: (self unsignedLongAt: index bigEndian: boolean)"},{"name":"asString","linesOfCode":4,"sourceCode":"asString\r\t\"Convert to a String with Characters for each byte.\r\tFast code uses primitive that avoids character conversion\"\r\r\t^ (String new: self size) replaceFrom: 1 to: self size with: self"},{"name":"booleanAt:put:","linesOfCode":2,"sourceCode":"booleanAt: byteIndex put: value\r\t^ self boolean8AtOffset: byteIndex - 1 put: value"},{"name":"longAt:put:bigEndian:","linesOfCode":21,"sourceCode":"longAt: index put: value bigEndian: aBool\r\t\"Return a 32bit integer quantity starting from the given byte index\"\r\t| b0 b1 b2 b3 |\r\tb0 := value bitShift: -24.\r\tb0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).\r\tb0 < 0 ifTrue:[b0 := 256 + b0].\r\tb1 := (value bitShift: -16) bitAnd: 255.\r\tb2 := (value bitShift: -8) bitAnd: 255.\r\tb3 := value bitAnd: 255.\r\taBool ifTrue:[\r\t\tself at: index put: b0.\r\t\tself at: index+1 put: b1.\r\t\tself at: index+2 put: b2.\r\t\tself at: index+3 put: b3.\r\t] ifFalse:[\r\t\tself at: index put: b3.\r\t\tself at: index+1 put: b2.\r\t\tself at: index+2 put: b1.\r\t\tself at: index+3 put: b0.\r\t].\r\t^value"},{"name":"unsignedCharAt:","linesOfCode":2,"sourceCode":"unsignedCharAt: byteIndex\r\t^ self char8AtOffset: byteIndex - 1"},{"name":"int8AtOffset:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset\r\t<primitive: 602>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: true"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeByteArray: self"},{"name":"boolean8AtOffset:put:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset put: value\r\t<primitive: 615>\r\t^ self integerAt: zeroBasedOffset + 1 put: (value ifTrue:[1] ifFalse:[0]) size: 1 signed: false"},{"name":"closureDescriptionForCaching","linesOfCode":6,"sourceCode":"closureDescriptionForCaching\r\t^ 'ba ' , (self size < 32 ifTrue: [\r\t\t self hex\r\t] ifFalse: [\r\t\t(SHA256 hashMessage: self) hex\r\t])"},{"name":"platformUnsignedBitAt:","linesOfCode":5,"sourceCode":"platformUnsignedBitAt: byteOffset\r\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize \r\t\tsigned: false"},{"name":"char8AtOffset:put:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset put: value\r\t<primitive: 625>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 1 signed: false"}],"meta":{"name":"ByteArray class","instanceVariables":[],"methods":[{"name":"hashBytes:startingWith:","linesOfCode":19,"sourceCode":"hashBytes: aByteArray startingWith: speciesHash\r\t\"Answer the hash of a byte-indexed collection,\r\tusing speciesHash as the initial value.\r\tSee SmallInteger>>hashMultiply.\r\r\tThe primitive should be renamed at a\r\tsuitable point in the future\"\r\r\t| byteArraySize hash low |\r\t<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>\r\r\t<var: #aHash declareC: 'int speciesHash'>\r\t<var: #aByteArray declareC: 'unsigned char *aByteArray'>\r\r\tbyteArraySize := aByteArray size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: byteArraySize do: [:pos |\r\t\thash := hash + (aByteArray basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash"},{"name":"readHexFrom:","linesOfCode":3,"sourceCode":"readHexFrom: aString\r\t\"Create a byte array from a hexadecimal representation\"\r\t^(self new: aString size // 2) readHexFrom: aString readStream"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeByteArrayInspector"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Use a hex representation\"\r\t\r\t^ self readHexFrom: stonReader parseListSingleton"}],"meta":null}},{"name":"String","instanceVariables":[],"methods":[{"name":"withPlatformSpecificLineEndings","linesOfCode":4,"sourceCode":"withPlatformSpecificLineEndings\r\t^ Smalltalk os isWindows\r\t\tifTrue: [ self withInternetLineEndings ]\r\t\tifFalse: [ self withUnixLineEndings ]"},{"name":"llvmNameString","linesOfCode":5,"sourceCode":"llvmNameString\r\tself isValidLLVMSymbol ifTrue: [ ^ self ].\r\t^ ByteString streamContents: [ :out |\r\t\tself llvmPrintEscapedStringOn: out\r\t]"},{"name":"contractTo:","linesOfCode":14,"sourceCode":"contractTo: smallSize\r\t\"return myself or a copy shortened by ellipsis to smallSize\"\r\t\"('abcd' contractTo: 10) >>> 'abcd'\"\r\t\"('Pharo is really super cool' contractTo: 10) >>> 'Phar...ool'\"\r\t\"('A clear but rather long-winded summary' contractTo: 18) >>> 'A clear ...summary'\"\r\t\r\t| leftSize |\r\tself size <= smallSize\r\t\tifTrue: [^ self].  \"short enough\"\r\tsmallSize < 5\r\t\tifTrue: [^ self copyFrom: 1 to: smallSize].    \"First N characters\"\r\tleftSize := smallSize-2//2.\r\t^ self copyReplaceFrom: leftSize+1\t\t\"First N/2 ... last N/2\"\r\t\tto: self size - (smallSize - leftSize - 3)\r\t\twith: '...'\r"},{"name":"withInternetLineEndings","linesOfCode":3,"sourceCode":"withInternetLineEndings\r\t\"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet\"\r\t\r\t^self withLineEndings: String crlf"},{"name":"asRegex","linesOfCode":6,"sourceCode":"asRegex\r\t\"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal\r\tor RxParser>>compilationErrorSignal.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^RxParser preferredMatcherClass for: (RxParser new parse: self)"},{"name":"trimRight:","linesOfCode":3,"sourceCode":"trimRight: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from the right side of the receiving string.\"\r\r\t^ self trimLeft: [ :char | false ] right: aBlock"},{"name":"skipAnySubstring:startingAt:","linesOfCode":20,"sourceCode":"skipAnySubstring: delimiters startingAt: start \r\t\"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1.\"\r\r\t| any this ind ii |\r\tii := start-1.\r\t[(ii := ii + 1) <= self size] whileTrue: [ \"look for char that does not match\"\r\t\tany := false.\r\t\tdelimiters do: [:delim |\r\t\t\tdelim isCharacter \r\t\t\t\tifTrue: [(self at: ii) == delim ifTrue: [any := true]]\r\t\t\t\tifFalse: [\"a substring\"\r\t\t\t\t\tdelim size > (self size - ii + 1) ifFalse: \"Here's where the one-off error was.\"\r\t\t\t\t\t\t[ind := 0.\r\t\t\t\t\t\tthis := true.\r\t\t\t\t\t\tdelim do: [:dd | \r\t\t\t\t\t\t\tdd == (self at: ii+ind) ifFalse: [this := false].\r\t\t\t\t\t\t\tind := ind + 1].\r\t\t\t\t\t\tthis ifTrue: [ii := ii + delim size - 1.  any := true]]\r\t\t\t\t\t\t\tifTrue: [any := false] \"if the delim is too big, it can't match\"]].\r\t\tany ifFalse: [^ ii]].\r\t^ self size + 1"},{"name":"surroundedBySingleQuotes","linesOfCode":6,"sourceCode":"surroundedBySingleQuotes\r\t\"Answer the receiver with leading and trailing quotes.\"\r\t\"'hello' surroundedBySingleQuotes >>>  '''hello'''\"\r\t\"'he''llo' surroundedBySingleQuotes >>> '''he''llo'''\"\r\t\"'  hello  ' surroundedBySingleQuotes >>>  '''  hello  '''\"\r\t\r\t^ self surroundedBy: ($' asString)"},{"name":"asZnMimeType","linesOfCode":2,"sourceCode":"asZnMimeType\r\t^ ZnMimeType fromString: self"},{"name":"findDelimiters:startingAt:","linesOfCode":7,"sourceCode":"findDelimiters: delimiters startingAt: start \r\t\"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.\"\r\r\tstart to: self size do: [:i |\r\t\tdelimiters do: [:delim | \r\t\t\tdelim = (self at: i) \r\t\t\t\tifTrue: [^ i]]].\r\t^ self size + 1"},{"name":"lastIndexOfPKSignature:","linesOfCode":15,"sourceCode":"lastIndexOfPKSignature: aSignature\r\t\"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found\"\r\t| a b c d |\r\ta := aSignature first.\r\tb := aSignature second.\r\tc := aSignature third.\r\td := aSignature fourth.\r\t(self size - 3) to: 1 by: -1 do: [ :i |\r\t\t(((self at: i) = a)\r\t\t\tand: [ ((self at: i + 1) = b)\r\t\t\t\tand: [ ((self at: i + 2) = c)\r\t\t\t\t\tand: [ ((self at: i + 3) = d) ]]])\r\t\t\t\t\t\tifTrue: [ ^i ]\r\t].\r\t^0"},{"name":"asClassIfPresent:","linesOfCode":3,"sourceCode":"asClassIfPresent: presentBlock\r\t\"returns a global class with my name\"\r\t^ presentBlock cull: (self asClassIfAbsent: [ ^ nil ])"},{"name":"displayStringOn:","linesOfCode":2,"sourceCode":"displayStringOn: aStream\r\t\r\taStream nextPutAll: self\r\t"},{"name":"removeFromMetacelloRepositories:","linesOfCode":5,"sourceCode":"removeFromMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec removeMember \r\t\t\tname: self;\r\t\t\tyourself)"},{"name":"findCloseParenthesisFor:","linesOfCode":14,"sourceCode":"findCloseParenthesisFor: startIndex\r\t\"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest.\"\r\t\" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 \"\r\t\" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 \"\r\t| pos nestLevel |\r\tpos := startIndex+1.\r\tnestLevel := 1.\r\t[ pos <= self size ] whileTrue: [\r\t\t(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].\r\t\t(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].\r\t\tnestLevel = 0 ifTrue: [ ^pos ].\r\t\tpos := pos + 1.\r\t].\r\t^self size + 1"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeString: self"},{"name":"asDraggableMorph","linesOfCode":2,"sourceCode":"asDraggableMorph\r\r\t^ self asStringMorph"},{"name":"widthToDisplayInList:","linesOfCode":2,"sourceCode":"widthToDisplayInList: aList\r\r\t^ aList font widthOfStringOrText: self contents"},{"name":"substrings","linesOfCode":5,"sourceCode":"substrings\r\t\"Answer an array of non-empty substrings from the receiver separated by\r\tone or more whitespace characters.\"\r\t\r\t\"'let us make seperate strings' substrings >>>  #('let' 'us' 'make' 'seperate' 'strings')\"\r\r\t^ self substrings: CSSeparators"},{"name":"gtDebuggerSUnitPrint","linesOfCode":2,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ self printString"},{"name":"isValidGlobalName","linesOfCode":9,"sourceCode":"isValidGlobalName\r\r\tself ifEmpty: [ ^ false ].\r\t\r\t\"reserverd default names\"\r\tself = 'NameOfSubclass' ifTrue: [ ^ false ].\r\tself = 'TNameOfTrait' ifTrue: [ ^ false ].\r\t\r\t^ (self first isLetter \r\t\t\t\tand: [self first isUppercase]) \r\t\t\t\tand: [ self allSatisfy: [:character | \r\t\t\t\t\t\tcharacter isAlphaNumeric or: [ character = $_ ]]]"},{"name":"listBuildSceneGraphWith:atRow:bounds:color:backgroundColor:from:","linesOfCode":2,"sourceCode":"listBuildSceneGraphWith: builder atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\t^ builder string: self in: bounds font: aMorph font color: color"},{"name":"expandMacrosWith:with:with:","linesOfCode":5,"sourceCode":"expandMacrosWith: anObject with: anotherObject with: thirdObject \r\t^self expandMacrosWithArguments: (Array \r\t\t\t\twith: anObject\r\t\t\t\twith: anotherObject\r\t\t\t\twith: thirdObject)"},{"name":"findSelector","linesOfCode":31,"sourceCode":"findSelector\r\t\"Extract a selector with keyword parts from the receiver. While this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it.\"\r\t\r\t\"'isSymbol' findSelector >>> #isSymbol\"\r\t\"'x isSymbol' findSelector >>> nil\"\r\t\"'x isSymbol: 33' findSelector >>> #isSymbol:\"\r\t\"'between:and:' findSelector >>> #'between:and:'\"\r\t\"'2 between: 0 and: 4' findSelector >>> #'between:and:'\"\r\t\"'2 between: ( 1 and: 4)' findSelector >>> #between:\"\r\t\"'( 1 and: 4)' findSelector >>> nil\"\r\t\r\t| sel possibleParens |\r\tsel := self trimBoth.\r\tsel := sel copyReplaceAll: '#' with: ''.\r\tsel := sel copyReplaceAll: '[' with: ' [ '.\r\t(sel includes: $:) ifTrue:\r\t\t[sel := sel copyReplaceAll: ':' with: ': '.\t\"for the style (aa max:bb) with no space\"\r\t\tpossibleParens := sel findTokens: Character separators.\r\t\tsel := self species streamContents:\r\t\t\t[:s | | level | level := 0.\r\t\t\tpossibleParens do:\r\t\t\t\t[:token | | n |\r\t\t\t\t(level = 0 and: [token endsWith: ':'])\r\t\t\t\t\tifTrue: [s nextPutAll: token]\r\t\t\t\t\tifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].\r\r\tsel isEmpty ifTrue: [^ nil].\r\tsel isOctetString ifTrue: [sel := sel asOctetString].\r\tSymbol hasInterned: sel ifTrue:\r\t\t[:aSymbol | ^ aSymbol].\r\t^ nil"},{"name":"zipped","linesOfCode":7,"sourceCode":"zipped\r\t| gzstream |\r\r\t^ String streamContents: [ :stream |\r\t\tgzstream := GZipWriteStream on: stream.\r\t\tgzstream nextPutAll: self.\r\t\tgzstream close.\r \t]"},{"name":"putOn:","linesOfCode":6,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tThis is an optimisation.\r\tReturn self.\"\r\r\taStream nextPutAll: self"},{"name":"unzipped","linesOfCode":6,"sourceCode":"unzipped\r\t| magic1 magic2 |\r\tmagic1 := (self at: 1) asInteger.\r\tmagic2 := (self at: 2) asInteger.\r\t(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].\r\t^(GZipReadStream on: self) upToEnd"},{"name":"trimBoth","linesOfCode":3,"sourceCode":"trimBoth\r\t\"Trim separators from both sides of the receiving string.\"\r\t\r\t^ self trimBoth: [ :char | char isSeparator ]"},{"name":"search:","linesOfCode":3,"sourceCode":"search: aString\r\t\"compatibility method to make regexp and strings work polymorphicly\"\r\t^ aString includesSubstring: self"},{"name":"includesUnifiedCharacter","linesOfCode":2,"sourceCode":"includesUnifiedCharacter\r\t^false"},{"name":"decodeMimeHeader","linesOfCode":42,"sourceCode":"decodeMimeHeader\r\t\"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  \r\tText. Text containing non-ASCII characters is encoded by the sequence  \r\t=?character-set?encoding?encoded-text?=  \r\tEncoding is Q (quoted printable) or B (Base64), handled by  \r\tBase64MimeConverter / RFC2047MimeConverter.\r\r\tThanks to Yokokawa-san, it works in m17n package.  Try the following:\r\r\t'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader.\r\"\r\t| input |\r\tinput := self readStream.\r\t^String streamContents: [ :output | | temp |\r\t\t[ output nextPutAll: (input upTo: $=).\r\t\t\"ASCII Text\"\r\t\tinput atEnd ] whileFalse: \r\t\t[ (temp := input next) = $? \r\t\t\tifTrue: \r\t\t\t\t[ | pos charset mimeEncoding mimeDecoder charsetStream  |\r\t\t\t\tcharset := input upTo: $?.\r\t\t\t\t(charset isNil or: [ charset isEmpty ]) ifTrue: [ charset := 'LATIN-1' ].\r\t\t\t\tmimeEncoding := (input upTo: $?) asUppercase.\r\t\t\t\ttemp := input upTo: $?.\r\t\t\t\t\"Skip final =\"\r\t\t\t\tinput next.\r\t\t\t\tpos := input position.\r\t\t\t\tinput skipSeparators.\r\t\t\t\t\"Delete spaces if followed by =\"\r\t\t\t\tinput peek = $= ifFalse: [ input position: pos ]. \r\t\t\t\t\t\r\t\t\t\tcharsetStream :=  String new writeStream.\r\t\t\t\tmimeDecoder := mimeEncoding = 'B' \r\t\t\t\t\tifTrue: [ Base64MimeConverter new ]\r\t\t\t\t\tifFalse: [ RFC2047MimeConverter new ].\r\t\t\t\tmimeDecoder\r\t\t\t\t\tmimeStream: temp readStream;\r\t\t\t\t\tdataStream: charsetStream;\r\t\t\t\t\tmimeDecode.\r\t\t\t\toutput nextPutAll: (charsetStream contents convertFromEncoding: charset).\r\t\t\t\t]\r\t\t\tifFalse: \r\t\t\t\t[ output\r\t\t\t\t\tnextPut: $=;\r\t\t\t\t\tnextPut: temp ] ] ]"},{"name":"copyUpToSubstring:","linesOfCode":6,"sourceCode":"copyUpToSubstring: aSubstring\r\r\taSubstring ifEmpty: [ \r\t\t\"preserve compatiblity with `readStream upToAll:`\"\r\t\t^ String new ].\r\t\r\t^ (self findString: aSubstring)\r\t\tin: [ :index | index > 0 ifTrue: [ self copyFrom: 1 to: index-1 ] ifFalse: [ self ] ]"},{"name":"withoutPrefix:","linesOfCode":3,"sourceCode":"withoutPrefix: prefix\r\t\"Remove the given prefix, if present.\"\r\r\t^(self beginsWith: prefix) ifTrue: [ self copyFrom: 1 + prefix size to: self size ] ifFalse: [ self ]"},{"name":"copyReplaceTokens:with:","linesOfCode":4,"sourceCode":"copyReplaceTokens: oldSubstring with: newSubstring \r\t\"Replace all occurrences of oldSubstring that are surrounded by non-alphanumeric characters\"\r\t\"('File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick') >>> 'Snick asFile Files Snick''s Snick'\"\r\t\r\t^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true\r\t"},{"name":"encodedCharSetAt:","linesOfCode":3,"sourceCode":"encodedCharSetAt: index\r\t\"return the character encoding in place at index; the actual EncodedCharSet, not just a number. A bad index is an Error\"\r\t^EncodedCharSet charsetAt: 0 \"previous leadingChar\""},{"name":"uncapitalized","linesOfCode":7,"sourceCode":"uncapitalized\r\t\"Return a copy with the first letter downShifted (in lower case)\"\r\t\r\t| answer |\r\tself ifEmpty: [ ^ self copy ].\r\tanswer := self copy.\r\tanswer at: 1 put: answer first asLowercase.\r\t^ answer"},{"name":"findTokens:includes:","linesOfCode":5,"sourceCode":"findTokens: delimiters includes: substring\r\t\"Divide self into pieces using delimiters.  Return the piece that includes substring anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive).\"\r\r^ (self findTokens: delimiters) \r\tdetect: [:str | (str includesSubstring: substring)] \r\tifNone: [nil]"},{"name":"parseLiterals","linesOfCode":2,"sourceCode":"parseLiterals\r\t^ self class compiler parseLiterals: self"},{"name":"occursInWithEmpty:caseSensitive:","linesOfCode":14,"sourceCode":"occursInWithEmpty: prefix caseSensitive: aBoolean \r\t\"Answer whether the receiver begins with the given prefix string. \r\tThe comparison is case-sensitive.\" \r\t| matchTable |\r\tprefix isEmpty ifTrue: [ ^ true ].\r\tself size < prefix size ifTrue: [ ^ false ].\r\tmatchTable := aBoolean \r\t\tifTrue: [ CaseSensitiveOrder ]\r\t\tifFalse: [ CaseInsensitiveOrder ].\r\t^ (self \r\t\tfindSubstring: prefix\r\t\tin: self\r\t\tstartingAt: 1\r\t\tmatchTable: matchTable) > 0"},{"name":"regex:matchesDo:","linesOfCode":2,"sourceCode":"regex: rxString matchesDo: aBlock\r\r\t^rxString asRegex matchesIn: self do: aBlock"},{"name":"setDescriptionInMetacelloVersion:","linesOfCode":5,"sourceCode":"setDescriptionInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setDescription: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"displayOn:at:textColor:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium at: aPoint textColor: aColor\r\t\"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color\"\r\taDisplayMedium getCanvas drawString: self from: 1 to: self size at: aPoint font: nil color: aColor\r"},{"name":"asStringOrText","linesOfCode":3,"sourceCode":"asStringOrText\r\t\"Answer this string.\"\r\r\t^ self\r"},{"name":"asMorph","linesOfCode":4,"sourceCode":"asMorph \r\t\"Answer the receiver as a StringMorph\"\r\r\t^ StringMorph contents: self\r\r\"'bugs black blood' asMorph openInHand\""},{"name":"splitCamelCase","linesOfCode":15,"sourceCode":"splitCamelCase\r\t\r\t| results accum previousIsLower |\r\t\r\tresults := OrderedCollection new.\r\taccum := \tself first asString.\r\tpreviousIsLower := self first isLowercase.\r\t\r\t2 to: self size do: [ :index | | currentCharacter |\r\t\tcurrentCharacter := self at: index.\r\t\t(currentCharacter isUppercase and: [ previousIsLower ])\r\t\t\tifTrue: [ results add: accum. accum := '' ].\r\t\t\t\r\t\taccum := accum copyWith: currentCharacter.\r\t\tpreviousIsLower := currentCharacter isLowercase.\r\t].\t\r\t\r\tresults add: accum.\r\t\r\t^ results."},{"name":"byteAt:put:","linesOfCode":2,"sourceCode":"byteAt: index put: value\r\t^self subclassResponsibility"},{"name":"expandMacros","linesOfCode":5,"sourceCode":"expandMacros\r\t\"'<t>' expandMacros >>> String tab\"\r\t\"'<r>' expandMacros >>> String cr\"\r\t\"'<n>' expandMacros >>> OSPlatform current lineEnding\"\r\t\r\t^self expandMacrosWithArguments: #()"},{"name":"hasWideCharacterFrom:to:","linesOfCode":4,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Return true if one of my character in the range does not fit in a single byte\"\r\t\r\t\"Implementation note: inline #anySatisfy: here for efficiency reasons\"\r\t^(self indexOfWideCharacterFrom: start to: stop) ~= 0"},{"name":"deepCopy","linesOfCode":4,"sourceCode":"deepCopy\r\t\"DeepCopy would otherwise mean make a copy of the character;  since \r\tcharacters are unique, just return a shallowCopy.\"\r\r\t^self shallowCopy"},{"name":"endsWithAColon","linesOfCode":5,"sourceCode":"endsWithAColon \r\t\"Answer whether the final character of the receiver is a colon\"\r\t\"'displayStringOn:' endsWithAColon >>> true\"\r\t\"'displayStringOn:foo' endsWithAColon >>> false\"\r\t\r\t^ self notEmpty and: [ self last == $: ]\r"},{"name":"asPathWith:","linesOfCode":2,"sourceCode":"asPathWith: anObject \r\t^ anObject pathFromString: self"},{"name":"indentationIfBlank:","linesOfCode":15,"sourceCode":"indentationIfBlank: aBlock \r\t\"Answer the number of leading tabs in the receiver.  If there are\r\t no visible characters, pass the number of tabs to aBlock and return its value.\"\r\t| reader leadingTabs lastSeparator cr tab ch |\r\tcr := Character cr.\r\ttab := Character tab.\r\treader := self readStream.\r\tleadingTabs := 0.\r\t[ reader atEnd not and: [ (ch := reader next) = tab ] ] whileTrue: [ leadingTabs := leadingTabs + 1 ].\r\tlastSeparator := leadingTabs + 1.\r\t[ reader atEnd not and: [ ch isSeparator and: [ ch ~= cr ] ] ] whileTrue: \r\t\t[ lastSeparator := lastSeparator + 1.\r\t\tch := reader next ].\r\t(lastSeparator = self size or: [ ch = cr ]) ifTrue: [ ^ aBlock value: leadingTabs ].\r\t^ leadingTabs"},{"name":"withSqueakLineEndings","linesOfCode":8,"sourceCode":"withSqueakLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with CR.\"\r\t\r\tself\r\t\tdeprecated: 'Should use withInternalLineEndings instead'\r\t\ton: '30 October 2020'\r\t\tin: #Pharo9\r\t\ttransformWith: '`@rec withSqueakLineEndings' -> '`@rec withInternalLineEndings'.\r\t\r\t^ self withInternalLineEndings"},{"name":"asPrettySymbolName","linesOfCode":2,"sourceCode":"asPrettySymbolName\r\t^ self"},{"name":"withoutPeriodSuffix","linesOfCode":7,"sourceCode":"withoutPeriodSuffix\r\t\"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. \"\r\r\t| likely |\r\tlikely := self copyUpTo: $..\r\t^ likely size = 0\r\t\tifTrue: [ self ]\r\t\tifFalse: [ likely ]"},{"name":"beginsWith:fromList:","linesOfCode":2,"sourceCode":"beginsWith: aString fromList: aMorph\r\r\t^ self trimBoth asLowercase beginsWith: aString"},{"name":"slvmUTF8Encoded","linesOfCode":2,"sourceCode":"slvmUTF8Encoded\r\t^ self utf8Encoded"},{"name":"isPatternVariable","linesOfCode":2,"sourceCode":"isPatternVariable\r\r\t ^self keywords anySatisfy: [:each | each first = $`]"},{"name":"asDateAndTime","linesOfCode":3,"sourceCode":"asDateAndTime\r \t\"Convert from UTC format\" \t\r\t\r\t^ DateAndTime fromString: self"},{"name":"lineIndicesDo:","linesOfCode":32,"sourceCode":"lineIndicesDo: aBlock\r\t\"execute aBlock with 3 arguments for each line:\r\t- start index of line\r\t- end index of line without line delimiter\r\t- end index of line including line delimiter(s) CR, LF or CRLF\"\r\t\r\t| cr lf start sz nextLF nextCR |\r\tstart := 1.\r\tsz := self size.\r\tcr := Character cr.\r\tnextCR := self indexOf: cr startingAt: 1.\r\tlf := Character lf.\r\tnextLF := self indexOf: lf startingAt: 1.\r\t[ start <= sz ] whileTrue: [\r\t\t(nextLF = 0 and: [ nextCR = 0 ])\r\t\t\tifTrue: [ \"No more CR, nor LF, the string is over\"\r\t\t\t\t\taBlock value: start value: sz value: sz.\r\t\t\t\t\t^self ].\r\t\t(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])\r\t\t\tifTrue: [ \"Found a LF\"\r\t\t\t\t\taBlock value: start value: nextLF - 1 value: nextLF.\r\t\t\t\t\tstart := 1 + nextLF.\r\t\t\t\t\tnextLF := self indexOf: lf startingAt: start ]\r\t\t\tifFalse: [ 1 + nextCR = nextLF\r\t\t\t\tifTrue: [ \"Found a CR-LF pair\"\r\t\t\t\t\taBlock value: start value: nextCR - 1 value: nextLF.\r\t\t\t\t\tstart := 1 + nextLF.\r\t\t\t\t\tnextCR := self indexOf: cr startingAt: start.\r\t\t\t\t\tnextLF := self indexOf: lf startingAt: start ]\r\t\t\t\tifFalse: [ \"Found a CR\"\r\t\t\t\t\taBlock value: start value: nextCR - 1 value: nextCR.\r\t\t\t\t\tstart := 1 + nextCR.\r\t\t\t\t\tnextCR := self indexOf: cr startingAt: start ]]]"},{"name":"withoutQuoting","linesOfCode":10,"sourceCode":"withoutQuoting\r\t\"remove the initial and final quote marks (single quote for string, or double quotes for comments), if present (and if matches nesting quotes). Have a look at testWithoutQuoting. If you want to remove single/double quotes not in first and last positions of the strings, have a look at copyWithout: $' \"\r\r\t\"'''h''' withoutQuoting >>> 'h'\"\r\r\t\"' ''h'' ' withoutQuoting >>>  ' ''h'' '\"\r\r\t| quote |\r\tself size < 2 ifTrue: [ ^ self ].\r\tquote := self first.\r\t^ (quote = self last and: [ quote = $' or: [ quote = $\" ] ])\r\t\tifTrue: [ self copyFrom: 2 to: self size - 1 ]\r\t\tifFalse: [ self ]"},{"name":"isAsciiString","linesOfCode":2,"sourceCode":"isAsciiString\r\r\t^ self allSatisfy: [ :each | each asciiValue <= 127 ]\r"},{"name":"nullTerminatedEncodeWith:","linesOfCode":8,"sourceCode":"nullTerminatedEncodeWith: encoding\r\t\"Produce a ByteArray that encodes the receiver, using a specified encoding and adding a null terminator.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\r\tUseful extension for FFI and C integration\"\r\t\r\t\" 'Les élèves français' nullTerminatedEncodeWith: #utf8 \"\r\t\r\t^ ByteArray streamContents: [ :stream |\r\t\tencoding asZnCharacterEncoder next: self size putAll: self startingAt: 1 toStream: stream.\r\t\tstream nextPut: 0 \"Null terminator\" ]"},{"name":"wordBefore:","linesOfCode":15,"sourceCode":"wordBefore: anIndex \r\t\"('word before index' wordBefore: 4) >>> 'word'\"\r\t\"('word before index' wordBefore: 16) >>> 'inde'\"\r\t\r\t| sep tok |\r\ttok := false.\r\tsep := anIndex.\r\t[ sep > 0 and: [ (self at: sep) tokenish ] ] whileTrue: \r\t\t[ tok := true.\r\t\tsep := sep - 1 ]. \r\t^ tok \r\t\tifTrue: \r\t\t\t[ self \r\t\t\t\tcopyFrom: sep + 1\r\t\t\t\tto: anIndex ]\r\t\tifFalse: [ String new ]"},{"name":"findTokens:","linesOfCode":14,"sourceCode":"findTokens: delimiters\r\t\"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character.\"\r\r\t| tokens keyStart keyStop separators |\r\r\ttokens := OrderedCollection new.\r\tseparators := delimiters isCharacter \r\t\tifTrue: [Array with: delimiters]\r\t\tifFalse: [delimiters].\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipDelimiters: separators startingAt: keyStop.\r\t\tkeyStop := self findDelimiters: separators startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"asFileReference","linesOfCode":2,"sourceCode":"asFileReference\r\r\t^ FileSystem disk referenceTo: self"},{"name":"stemAndNumericSuffix","linesOfCode":12,"sourceCode":"stemAndNumericSuffix\r\t\"Parse the receiver into a string-valued stem and a numeric-valued suffix.\"\r\t\"'Fred2305' stemAndNumericSuffix\"\r\r\t| stem suffix position |\r\r\tstem := self.\r\tsuffix := 0.\r\tposition := 1.\r\t[stem endsWithDigit and: [stem size > 1]] whileTrue:\r\t\t[suffix :=  stem last digitValue * position + suffix.\r\t\tposition := position * 10.\r\t\tstem := stem copyFrom: 1 to: stem size - 1].\r\t^ Array with: stem with: suffix\r"},{"name":"withoutSuffix:","linesOfCode":3,"sourceCode":"withoutSuffix: suffix\r\t\"Remove the given suffix, if present.\"\r\r\t^(self endsWith: suffix) ifTrue: [ self copyFrom: 1 to: self size - suffix size ] ifFalse: [ self ]"},{"name":"encompassLine:","linesOfCode":8,"sourceCode":"encompassLine: anInterval\r\t\"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.\r\tAnswer starts at the position following a cr (or eventually 1) and ends before a cr (or eventually at self size)\r\tSee also encompassParagraph:\"\r\t| left right |\r\tleft := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.\r\tright := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.\r\t^left to: right"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: encoder\r\t^ self"},{"name":">=","linesOfCode":7,"sourceCode":">= aString \r\t\"Answer whether the receiver sorts after or equal to aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'def' >= 'abc' >>> true\"\r\t\" 'def' >= 'def' >>> true\"\r\t\" 'abc' >= 'def' >>> false\"\r\r\t^ (self compare: self with: aString collated: AsciiOrder) >= 2"},{"name":"asAlphaNumeric:extraChars:mergeUID:","linesOfCode":87,"sourceCode":"asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart \r\t\"Generates a String with unique identifier ( UID ) qualities, the difference to a\r\t UUID is that its beginning is derived from the receiver, so that it has a meaning\r\t for a human reader.\r\r\t Answers a String of totalSize, which consists of 3 parts\r\t 1.part: the beginning of the receiver only consisting of\r\t\ta-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )\r\t 2.part: a single _\r\t 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of\r\t\ta-z, A-Z, 0-9\r\r\t Starting letters are capitalized. \r\t TotalSize must be at least 1.\r\t Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).\r\t The random part has even for small sizes good UID qualitites for many practical purposes.\r\t If only lower- or uppercase letters are demanded, simply convert the answer with\r\t say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).\r\r\t Example: \r\t\tsize of random part = 10\r\t\tin n generated UIDs the chance p of having non-unique UIDs is\r\t\t\tn = 10000 ->  p < 1e-10\t\tif answer is reduced to lowerCase: p < 1.4 e-8\r\t\t\tn = 100000 -> p < 1e-8\r\t\tat the bottom is a snippet for your own calculations  \r\t\tNote: the calculated propabilites are theoretical,\r\t\t\tfor the actually used random generator they may be much worse\"\r\t| stream out sizeOfFirstPart index ascii ch skip array random |\r\ttotalSize > minimalSizeOfRandomPart ifFalse: [ self errorOutOfBounds ].\r\tstream := self readStream.\r\tout :=  (String new: totalSize) writeStream.\r\tindex := 0.\r\tskip := true.\r\tsizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.\r\t[ stream atEnd or: [ index >= sizeOfFirstPart ] ] whileFalse: \r\t\t[ (((ascii := (ch := stream next) asciiValue) between: 65 and: 90) or: \r\t\t\t[ (ascii between: 97 and: 122) or: \r\t\t\t\t[ ch isDigit or: [ additionallyAllowed notNil and: [ additionallyAllowed includes: ch ] ] ] ]) \r\t\t\tifTrue: \r\t\t\t\t[ skip \r\t\t\t\t\tifTrue: [ out nextPut: ch asUppercase ]\r\t\t\t\t\tifFalse: [ out nextPut: ch ].\r\t\t\t\tindex := index + 1.\r\t\t\t\tskip := false ]\r\t\t\tifFalse: [ skip := true ] ].\r\tout nextPut: $_.\r\tarray := Array new: 62.\r\t1 \r\t\tto: 26\r\t\tdo: \r\t\t\t[ :i | \r\t\t\tarray \r\t\t\t\tat: i\r\t\t\t\tput: (i + 64) asCharacter.\r\t\t\tarray \r\t\t\t\tat: i + 26\r\t\t\t\tput: (i + 96) asCharacter ].\r\t53 \r\t\tto: 62\r\t\tdo: \r\t\t\t[ :i | \r\t\t\tarray \r\t\t\t\tat: i\r\t\t\t\tput: (i - 5) asCharacter ].\r\trandom := UUIDGenerator default randomGenerator.\r\ttotalSize - index - 1 timesRepeat: [ out nextPut: (array atRandom: random) ].\r\t^ out contents\r\r\t\"\tcalculation of probability p for failure of uniqueness in n UIDs\r\t\tNote: if answer will be converted to upper or lower case replace 62 with 36\r\t| n i p all |\r\tall := 62 raisedTo: sizeOfRandomPart.\r\ti := 1.\r\tp := 0.0 .\r\tn := 10000.\r\t[ i <= n ]\r\twhileTrue: [\r\t\tp := p + (( i - 1 ) / all ).\r\t\ti := i + 1 ].\r\tp   \r\r\tapproximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 \r\t\"\r\r\t\"'Crop SketchMorphs and Grab Screen Rect to JPG' \r\t\t\tasAlphaNumeric: 31 extraChars: nil mergeUID: 10  \r\t \t\t\t'CropSketchMorphsAndG_iOw94jquN6'\r\t 'Monticello' \r\t\t\tasAlphaNumeric: 31 extraChars: nil mergeUID: 10    \r\t\t\t\t'Monticello_kp6aV2l0IZK9uBULGOeG' \r\t 'version-', ( '1.1.2' replaceAll: $. with: $- )\r\t\t\tasAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    \r\t\t\t\t'Version-1-1-2_kuz2tMg2xX9iRLDVR'\""},{"name":"numArgs","linesOfCode":29,"sourceCode":"numArgs\r\t\"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector. It is intended mostly for the assistance of spelling correction.\"\r\r\t| firstChar numColons start ix |\r\tself size = 0 ifTrue: [ ^ -1 ].\r\tfirstChar := self at: 1.\r\t(firstChar isLetter or: [ firstChar = $_ ])\r\t\tifTrue: [ \"Fast reject if any chars are non-alphanumeric\r\t\tNOTE: fast only for Byte things - Broken for Wide\"\r\t\t\tself class isBytes\r\t\t\t\tifTrue: [ (self\r\t\t\t\t\t\tfindSubstring: '~'\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: 1\r\t\t\t\t\t\tmatchTable: Tokenish) > 0 ifTrue: [ ^ -1 ] ]\r\t\t\t\tifFalse: [ 2 to: self size do: [ :i | (self at: i) tokenish ifFalse: [ ^ -1 ] ] ].\r\t\t\t\"Fast colon count\"\r\t\t\tnumColons := 0.\r\t\t\tstart := 1.\r\t\t\t[ (ix := self indexOf: $: startingAt: start) > 0 ]\r\t\t\t\twhileTrue: [ (ix = start or: [ (self at: start) isDigit ]) ifTrue: [ ^ -1 ].\r\t\t\t\t\tnumColons := numColons + 1.\r\t\t\t\t\tstart := ix + 1 ].\r\t\t\tnumColons = 0 ifTrue: [ ^ 0 ].\r\t\t\t^ self last = $:\r\t\t\t\tifTrue: [ numColons ]\r\t\t\t\tifFalse: [ -1 ] ].\r\t\"Test case of binary selector, if self allSatisfy: #isSpecial (inlined for speed)\"\r\t1 to: self size do: [ :i | (self at: i) isSpecial ifFalse: [ ^ -1 ] ].\r\t^ 1"},{"name":"byteAt:","linesOfCode":2,"sourceCode":"byteAt: index\r\t^self subclassResponsibility"},{"name":"prefixMatchesRegex:","linesOfCode":6,"sourceCode":"prefixMatchesRegex: regexString\r\t\"Test if the receiver's prefix matches a regex.\t\r\tMay raise RxParser class>>regexErrorSignal or child signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegex matchesPrefix: self"},{"name":"padLeftTo:with:","linesOfCode":2,"sourceCode":"padLeftTo: length with: char\r\t^ (String new: (length - self size max: 0) withAll: char) , self."},{"name":"withSeparatorsCompacted","linesOfCode":19,"sourceCode":"withSeparatorsCompacted\r    \"Returns a copy of the receiver with each sequence of whitespace (separator) \r    characters replaced by a single space character\"\r    \"' test ' withSeparatorsCompacted >>> ' test '\"\r    \"' test  test' withSeparatorsCompacted >>> ' test test'\"\r    \"'test  test      ' withSeparatorsCompacted >>> 'test test '\"\r\r    self isEmpty ifTrue: [ ^ self ].\r    ^ self species new: self size streamContents: [:stream | \r        | lastBlank |\r        lastBlank := false.\r        self do: [ :eachChar | \r            lastBlank \r                ifTrue: [\r                    (lastBlank := eachChar isSeparator)\r                        ifFalse: [ stream nextPut: eachChar ] ] \r                ifFalse: [\r                    (lastBlank := eachChar isSeparator)\r                        ifTrue: [ stream nextPut: $  ]\r                        ifFalse: [ stream nextPut: eachChar ] ] ] ]"},{"name":"asHTMLString","linesOfCode":5,"sourceCode":"asHTMLString\r\t\"substitute the < & > into HTML compliant elements\"\r\t\"'<a>' asHTMLString\"\r\t^ self species new: self size streamContents: [ :s| \r\t\tself do: [:c | s nextPutAll: c asHTMLString ]]\r"},{"name":"removeFromMetacelloPackages:","linesOfCode":5,"sourceCode":"removeFromMetacelloPackages: aMetacelloPackagesSpec\r\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec removeMember \r\t\t\tname: self;\r\t\t\tyourself)"},{"name":"setPackage:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setPackage: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setPackage: aString withString: self"},{"name":"copyReplaceAll:with:","linesOfCode":15,"sourceCode":"copyReplaceAll: oldSubstring with: newSubstring\r\t\"Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring\"\r\t\"('ab cd ab ef ab' copyReplaceAll: 'ab' with: 'zk') >>> 'zk cd zk ef zk'\"\r    | idx |        \r    self = oldSubstring ifTrue: [ ^ newSubstring copy ].\r    oldSubstring isEmpty ifTrue: [ ^ self copy ].\r    idx := 1.\r    ^ self species new: self size streamContents: [ :stream | | foundIdx |\r        [ (foundIdx := self findString: oldSubstring startingAt: idx) isZero ] whileFalse: [ \r            stream \r                next: (foundIdx - idx) putAll: self startingAt: idx;\r                nextPutAll: newSubstring.\r            idx := foundIdx + oldSubstring size ].\r        idx <= self size ifTrue: [ \r            stream next: (self size - idx + 1) putAll: self startingAt: idx ] ]"},{"name":"endsWith:","linesOfCode":9,"sourceCode":"endsWith: suffix\r\t\"Answer whether the tail end of the receiver is the same as suffix.\r\tThe comparison is case-sensitive.\"\r \r\t\"('Elvis' endsWith: 'vis') >>> true\"\r\t\r\t| extra |\r\textra := self size - suffix size.\r\t^extra < 0 \r\t\tifTrue: [ false]\r\t   ifFalse: [ (self findString: suffix startingAt: extra + 1) > 0 ]"},{"name":"convertToWithConverter:","linesOfCode":7,"sourceCode":"convertToWithConverter: converter \r\tconverter\r\t\tifNil: [^ self].\r\t^ String new: self size streamContents: [:writeStream | \r\t\tconverter \r\t\t\tnextPutAll: self toStream: writeStream;\r\t\t\temitSequenceToResetStateIfNeededOn: writeStream]"},{"name":"trimLeft","linesOfCode":3,"sourceCode":"trimLeft\r\t\"Trim separators from the left side of the receiving string.\"\r\t\r\t^ self trimLeft: [ :char | char isSeparator ] "},{"name":"isValidLLVMSymbol","linesOfCode":8,"sourceCode":"isValidLLVMSymbol\r\tself isLLVMAnon ifTrue: [ ^ true ].\r\tself ifEmpty: [ ^ false ].\r\tself first isDigit ifTrue: [ ^ false ].\r\tself do: [ :c |\r\t\t(('._$' includes: c) or: [ c isAlphaNumeric ]) ifFalse: [ ^ false ].\r\t].\r\t^ true"},{"name":"findTokens:keep:","linesOfCode":14,"sourceCode":"findTokens: delimiters keep: keepers\r\t\"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)\"\r\r\t| tokens keyStart keyStop |\r\ttokens := OrderedCollection new.\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipDelimiters: delimiters startingAt: keyStop.\r\t\tkeyStop to: keyStart-1 do: [:ii | \r\t\t\t(keepers includes: (self at: ii)) ifTrue: [\r\t\t\t\ttokens add: (self copyFrom: ii to: ii)]].\t\"Make this keeper be a token\"\r\t\tkeyStop := self findDelimiters: delimiters startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"asSymbol","linesOfCode":4,"sourceCode":"asSymbol\r\t\"Answer the unique Symbol whose characters are the characters of the \r\tstring.\"\r\t^Symbol intern: self"},{"name":"asLLVMMetadataInContext:","linesOfCode":2,"sourceCode":"asLLVMMetadataInContext: aContext\r\t^ LLVMMDString new context: aContext; value: self; yourself"},{"name":"slvmUTF16EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF16EncodedSize\r\t^ self slvmUTF16Encoded size"},{"name":"encodeDoublingQuoteOn:","linesOfCode":3,"sourceCode":"encodeDoublingQuoteOn: aStream\r\tself deprecated: 'Use #storeOn: instead' transformWith: '`@receiver encodeDoublingQuoteOn: `@argument' -> '`@receiver storeOn: `@argument'.\r\tself storeOn: aStream"},{"name":"correctAgainstDictionary:continuedFrom:","linesOfCode":7,"sourceCode":"correctAgainstDictionary: wordDict continuedFrom: oldCollection\r\t\"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary.\"\r\r\t^ wordDict \r\t\tifNil: [ self correctAgainstEnumerator: nil\r\t\t\t\t\tcontinuedFrom: oldCollection ]\r\t\tifNotNil: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]\r\t\t\t\t\tcontinuedFrom: oldCollection ]"},{"name":"storeOn:","linesOfCode":9,"sourceCode":"storeOn: aStream\r\t\"Print inside string quotes, doubling inbedded quotes.\"\r\r\t\"(String streamContents: [ :s | 'Foo''Bar' storeOn: s ]) >>> '''Foo''''Bar'''\"\r\r\t| x |\r\taStream nextPut: $'.\r\t1 to: self size do: [ :i | \r\t\taStream nextPut: (x := self at: i).\r\t\tx = $' ifTrue: [ aStream nextPut: x ] ].\r\taStream nextPut: $'"},{"name":"squeezeOutNumber","linesOfCode":6,"sourceCode":"squeezeOutNumber\r\t\"Try to find a number somewhere in this string, as explained in Number>readFrom:\r\t\r\tthis method returns the first number found\"\r\t\r\t\"'th is is29 a stRI4' squeezeOutNumber >>> 29\"\r\t\"'th is is2 9 a stRI4' squeezeOutNumber >>> 2\"\r\t\r\t^ Number squeezeNumberOutOfString: self"},{"name":"asZnCharacterEncoder","linesOfCode":4,"sourceCode":"asZnCharacterEncoder\r\t\"Return a ZnCharacterEncoder instance using the receiver as identifier\"\r\t\r\t\" 'UTF-8' asZnCharacterEncoder \"\r\t\r\t^ ZnCharacterEncoder newForEncoding: self"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeString: self do: projectSpecBlock"},{"name":"metacelloSemanticStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloSemanticStringLessThanSelf: aString\r    ^ aString < self"},{"name":"setTimestampInMetacelloVersion:","linesOfCode":5,"sourceCode":"setTimestampInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setTimestamp: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"translateFrom:to:table:","linesOfCode":3,"sourceCode":"translateFrom: start  to: stop  table: table\r\t\"translate the characters in the string by the given table, in place\"\r\tself class translate: self from: start to: stop table: table"},{"name":"format:","linesOfCode":22,"sourceCode":"format: collection\r\t\"Format the receiver by interpolating elements from collection, as in the following examples:\" \r\t\"('Five is {1}.' format: { 1 + 4}) >>> 'Five is 5.'\"\r\t\"('Five is {five}.' format: (Dictionary with: #five -> 5)) >>>  'Five is 5.'\"\r\t\"('In {1} you can escape \\{ by prefixing it with \\\\' format: {'strings'}) >>> 'In strings you can escape { by prefixing it with \\' \"\r\t\"('In \\{1\\} you can escape \\{ by prefixing it with \\\\' format: {'strings'}) >>> 'In {1} you can escape { by prefixing it with \\' \"\r\r\t^ self species\r\t\tnew: self size\r\t\tstreamContents: [ :result | \r\t\t\t| stream |\r\t\t\tstream := self readStream.\r\t\t\t[ stream atEnd ]\r\t\t\t\twhileFalse: [ | currentChar |\r\t\t\t\t\t(currentChar := stream next) == ${\r\t\t\t\t\t\tifTrue: [ | expression index |\r\t\t\t\t\t\t\texpression := stream upTo: $}.\r\t\t\t\t\t\t\tindex := Integer readFrom: expression ifFail: [ expression ].\r\t\t\t\t\t\t\tresult nextPutAll: (collection at: index) asString ]\r\t\t\t\t\t\tifFalse: [ currentChar == $\\\r\t\t\t\t\t\t\t\tifTrue: [ stream atEnd\r\t\t\t\t\t\t\t\t\t\tifFalse: [ result nextPut: stream next ] ]\r\t\t\t\t\t\t\t\tifFalse: [ result nextPut: currentChar ] ] ] ]"},{"name":"asFileName","linesOfCode":7,"sourceCode":"asFileName\r\t\"Answer a String made up from the receiver that is an acceptable file \r\tname.\"\r\r\t| string checkedString |\r\tstring := FileSystem disk checkName: self fixErrors: true.\r\tcheckedString := FilePathEncoder encode: string.\r\t^ FilePathEncoder decode: checkedString"},{"name":"wbtSubstituteVariables:","linesOfCode":2,"sourceCode":"wbtSubstituteVariables: variables\r\t^ self wbtSubstituteVariablesWith: [ :varName | (variables at: varName ifAbsent: [ nil ]) asWBTVarSubstitution ]"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\t\taStream nextPut: self"},{"name":"asMetacelloVersionNumber","linesOfCode":2,"sourceCode":"asMetacelloVersionNumber\r\r\t^MetacelloVersionNumber fromString: self"},{"name":"asInteger","linesOfCode":8,"sourceCode":"asInteger \r\t\"Return the integer present in the receiver, or nil. In case of float, returns the integer part.\"\r\t\"'1' asInteger >>> 1\"\r\t\"'-1' asInteger >>> -1\"\r\t\"'10' asInteger >>> 10\"\r\t\"'a' asInteger >>> nil\"\r\t\"'1.234' asInteger >>> 1\"\r\t^self asSignedInteger\r"},{"name":"isOctetString","linesOfCode":8,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t1 to: self size do: [:pos |\r\t\t(self at: pos) asInteger >= 256 ifTrue: [^ false].\r\t].\r\t^ true.\r"},{"name":"=","linesOfCode":8,"sourceCode":"= aString \r\t\"Answer whether the receiver sorts equally as aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' = 'def' >>> false\"\r\t\" 'abc' = 'abc' >>> true\"\r\t\" 'def' = 'abc' >>> false\"\r\t\r\t(aString isString and: [self size = aString size]) ifFalse: [^false].\r\t^ (self compare: self with: aString collated: AsciiOrder) = 2"},{"name":"displayProgressFrom:to:during:","linesOfCode":13,"sourceCode":"displayProgressFrom: minVal to: maxVal during: workBlock \r\t\"Display this string as a caption over a progress bar while workBlock is evaluated.\r\rEXAMPLE (Select next 6 lines and Do It)\r'Now here''s some real progress'\r\tdisplayProgressFrom: 0 to: 10\r\tduring: [:bar |\r\t1 to: 10 do: [:x | bar value: x.\r\t\t\t(Delay forMilliseconds: 500) wait]].\r\"\r\t^ UIManager default \r\t\tdisplayProgress: self \r\t\tfrom: minVal \r\t\tto: maxVal \r\t\tduring: workBlock"},{"name":"asClassVariable","linesOfCode":2,"sourceCode":"asClassVariable\r\t^ ClassVariable named: self"},{"name":"<","linesOfCode":7,"sourceCode":"< aString \r\t\"Answer whether the receiver sorts before aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' < 'def' >>> true\"\r\t\" 'abc' < 'abc' >>> false\"\r\t\" 'def' < 'abc' >>> false\"\r\t\r\t\r\t^ (self compare: self with: aString collated: AsciiOrder) = 1"},{"name":"findString:","linesOfCode":5,"sourceCode":"findString: substring\r\t\"Answer the index of the first substring within the receiver. If the receiver does not contain substring, answer 0.\"\r\t\"('salkjsdlkgfee' findString: 'al') >>> 2\"\r\t\"('salkjsdlkgfeesd' findString: 'sd') >>> 6\"\r\t\r\t^self findString: substring startingAt: 1."},{"name":"initialIntegerOrNil","linesOfCode":16,"sourceCode":"initialIntegerOrNil\r\t\"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit\"\r\t\"'234Whoopie' initialIntegerOrNil >>> 234\"\r\t\"'wimpy' initialIntegerOrNil >>> nil\"\r\t\"'234' initialIntegerOrNil >>> 234\"\r\t\"'2N' initialIntegerOrNil >>> 2\"\r\t\"'2' initialIntegerOrNil >>> 2\"\r\t\"'  89Ten ' initialIntegerOrNil >>> nil\"\r\t\"'78 92' initialIntegerOrNil >>> 78\"\r\t\"'3.1415' initialIntegerOrNil >>> 3\"\r\t\r\t| firstNonDigit |\r\t(self size = 0 or: [ self first isDigit not ]) \r\t\tifTrue: [ ^ nil ].\r\tfirstNonDigit := (self findFirst: [ :m | m isDigit not ]).\r\tfirstNonDigit = 0 ifTrue: [ firstNonDigit := self size + 1 ].\r\t^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"},{"name":"padRightTo:with:","linesOfCode":2,"sourceCode":"padRightTo: length with: char\r\t^ self, (String new: (length - self size max: 0) withAll: char)"},{"name":"urlDecoded","linesOfCode":4,"sourceCode":"urlDecoded\r\t\"URL Decode the receiver and return the resulting String.\r\tThis is an encoding where characters that are illegal in a URL are escaped.\"\r\r    ^ ZnPercentEncoder new decode: self"},{"name":"allRegexMatches:","linesOfCode":2,"sourceCode":"allRegexMatches: rxString\r\r\t^rxString asRegex matchesIn: self"},{"name":"regex:matchesCollect:","linesOfCode":2,"sourceCode":"regex: rxString matchesCollect: aBlock\r\r\t^rxString asRegex matchesIn: self collect: aBlock"},{"name":"addToMetacelloRepositories:","linesOfCode":11,"sourceCode":"addToMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloRepositoriesSpec project repositorySpec)\r\t\t\tdescription: self;\r\t\t\tyourself.\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec addMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"packageFileSpecFor:","linesOfCode":4,"sourceCode":"packageFileSpecFor: aMetacelloPackagesSpec\r\r\t^(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself"},{"name":"resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:","linesOfCode":4,"sourceCode":"resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock\r    ^ aMetacelloMCVersion\r        allPackagesForSpecs: {(aMetacelloMCVersion packageNamed: self ifAbsent: aBlock)}\r        visited: visited"},{"name":"asText","linesOfCode":3,"sourceCode":"asText\r\t\"Answer a Text whose string is the receiver.\"\r\r\t^Text fromString: self"},{"name":"caseSensitiveLessOrEqual:","linesOfCode":4,"sourceCode":"caseSensitiveLessOrEqual: aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is case sensitive.\"\r\t^(self compare: aString caseSensitive: true) <= 2"},{"name":"trimLeft:","linesOfCode":3,"sourceCode":"trimLeft: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from the left side of the receiving string.\"\r\t\r\t^ self trimLeft: aBlock right: [ :char | false ]"},{"name":"widthToDisplayInTree:","linesOfCode":2,"sourceCode":"widthToDisplayInTree: aTree\r\r\t^ aTree fontToUse widthOfStringOrText: self contents"},{"name":"addedToZnUrl:","linesOfCode":4,"sourceCode":"addedToZnUrl: url\r\t| segments |\r\tsegments := self findTokens: '/'.\r\t^ url withPathSegments: segments"},{"name":"convertToEncoding:","linesOfCode":2,"sourceCode":"convertToEncoding: encodingName\r\t^self convertToWithConverter: (TextConverter newForEncoding: encodingName)."},{"name":"setPostLoadDoItInMetacelloSpec:","linesOfCode":2,"sourceCode":"setPostLoadDoItInMetacelloSpec: aMetacelloSpec\r    self asSymbol setPostLoadDoItInMetacelloSpec: aMetacelloSpec"},{"name":"findLastOccurrenceOfString:startingAt:","linesOfCode":10,"sourceCode":"findLastOccurrenceOfString: substring startingAt: start \r\t\"Answer the index of the last occurrence of substring within the receiver, starting at start. If \r\tthe receiver does not contain substring, answer 0.  Case-sensitive match used.\"\r\r\t| last now |\r\tlast := self findString: substring startingAt: start.\r\tlast = 0 ifTrue: [^ 0].\r\t[last > 0] whileTrue:\r\t\t[now := last.\r\t\tlast := self findString: substring startingAt: last + 1].\r\r\t^ now\r"},{"name":"correctAgainst:","linesOfCode":6,"sourceCode":"correctAgainst: wordList\r\t\"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:\"\r\t| results |\r\tresults := self correctAgainst: wordList continuedFrom: nil.\r\tresults := self correctAgainst: nil continuedFrom: results.\r\t^ results"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"withoutTrailingDigits","linesOfCode":4,"sourceCode":"withoutTrailingDigits\r\t\"Answer the portion of the receiver that precedes any leading series of digits and separators.\r\tIf the receiver consists entirely of digits and separators, return an empty string\"\r\r\t^ self trimRight: [ :char | char isDigit or: [ char isSeparator ] ]"},{"name":"trimBoth:","linesOfCode":3,"sourceCode":"trimBoth: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from both sides of the receiving string.\"\r\r\t^ self trimLeft: aBlock right: aBlock"},{"name":"metacelloSemanticIntegerLessThanSelf:","linesOfCode":3,"sourceCode":"metacelloSemanticIntegerLessThanSelf: anInteger\r    \"integer version components are always '>' string component\"\r\r    ^ true"},{"name":"metacelloVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloVersionComponentLessThan: aMetacelloVersonComponent\r\r\t^aMetacelloVersonComponent metacelloStringLessThanSelf: self"},{"name":"asClassIfAbsent:","linesOfCode":3,"sourceCode":"asClassIfAbsent: absentBlock\r\t\"returns a global class with my name\"\r\t^ self asClassInEnvironment: Smalltalk globals ifAbsent: absentBlock"},{"name":"withoutTrailingNewlines","linesOfCode":3,"sourceCode":"withoutTrailingNewlines\r\t\"Return a copy of the receiver with any combination of cr/lf characters at the end removed\"\r\r\t^ self trimRight: [ :char | char = Character cr or: [ char = Character lf ] ]"},{"name":"typeTable","linesOfCode":2,"sourceCode":"typeTable\r\t^ self class typeTable"},{"name":"includesSubstring:","linesOfCode":4,"sourceCode":"includesSubstring: substring\r\t\"Returns whether the receiver contains the argument.\"\r\t\"('abcdefgh' includesSubstring: 'de') >>> true\"\r\t\r\t^ substring isEmpty or: [ (self findString: substring startingAt: 1) > 0 ]"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ WideString from: self"},{"name":"trimLineSpaces","linesOfCode":7,"sourceCode":"trimLineSpaces\r\t\"Trim the spaces from the right side of each line. Useful for code\"\r\t\r\t^ self species streamContents: [ :str |\r\t\tself lines \r\t\t\tdo: [ :line | str nextPutAll: line trimRight]\r\t\t\tseparatedBy: [str cr]]\r\t\t\r"},{"name":"isValidSelector","linesOfCode":4,"sourceCode":"isValidSelector\r\t\"check I could be a valid selector (name of method). \r\t For checking if there is symbol like me used as a selector, see #isSelectorSymbol on Symbol\"\r\t^ RBScanner isSelector: self"},{"name":"slvmUTF32Encoded","linesOfCode":2,"sourceCode":"slvmUTF32Encoded\r\t^ self asWideString asArray collect: [ :each | each asInteger ]"},{"name":"displayAt:","linesOfCode":3,"sourceCode":"displayAt: aPoint \r\t\"Display the receiver as a DisplayText at aPoint on the display screen.\"\r\r\tself displayOn: Display at: aPoint"},{"name":"indexOfFirstUppercaseCharacter","linesOfCode":11,"sourceCode":"indexOfFirstUppercaseCharacter\r\t\"Returns the index of the first Uppercase character.\r\t'uouFauhZ ' indexOfFirstUppercaseCharacter2 -> 4\r\tNew implementation much faster than older one.\r\t\"\r\t| size |\r\tsize := self size.\r\t1 to: size do: [:i| \r\t\t(self at: i) isUppercase \r\t\t\tifTrue: [^ i ]].\r\t^ 0"},{"name":"expandMacrosWith:","linesOfCode":4,"sourceCode":"expandMacrosWith: anObject \r\t\"('Pharo is <1s>' expandMacrosWith: 'cool') >>> 'Pharo is cool'\"\r\t\"('Pharo is <1p>' expandMacrosWith: 'cool') >>> 'Pharo is ''cool'''\"\r\r\t^self expandMacrosWithArguments: (Array with: anObject)"},{"name":"asValidSelector","linesOfCode":25,"sourceCode":"asValidSelector\r\t\"Returns a symbol that is a valid selector by removing any space or forbidden characters\"\r\t\"'234znak ::x43 ''åå) _ : 2' asValidSelector >>> #'v234znak:x43:v2'\"\r\t\"'234znak ::x43 åå) :2' asValidSelector >>> #v234znak:x43:v2\"\r\t\r^(((\r\t$: join: (\t\r\t\t(\r\t\t\t$: split: (\r\t\t\t\tself select: [ :char |\r\t\t\t\t\t(char charCode < 128) and: [ \r\t\t\t\t\t\tchar isAlphaNumeric or: [ \r\t\t\t\t\t\t\tchar = $:\t\r\t\t\t\t\t\t]\t\r\t\t\t\t\t]\t\r\t\t\t\t]\r\t\t\t)\r\t\t)  \r\t\tselect: [ :split | split isNotEmpty ]\r\t\tthenCollect: [ :nonEmptyString |\r\t\t\tnonEmptyString first isLetter\r\t\t\t\tifTrue: [ nonEmptyString uncapitalized ]\r\t\t\t\tifFalse: [ 'v' , nonEmptyString ]\r\t\t]\r\t)\r) ifEmpty: [ 'v' ]), ((self isNotEmpty and: [ self last = $: ]) ifTrue: [ ':' ] ifFalse: [ #() ]) )asSymbol\r"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self"},{"name":"asSpirVStringLiteral","linesOfCode":13,"sourceCode":"asSpirVStringLiteral\r\t| utf8 wordCount wordArray shift word wordIndex |\r\tutf8 := self asUTF8Bytes.\r\twordCount := utf8 size + 1 + 3 // 4.\r\twordArray := (1 to: wordCount) collect: [:i | 0 ].\r\t1 to: utf8 size do: [ :i |\r\t\tshift := (i - 1 \\\\ 4) * 8.\r\t\twordIndex := (i -1) // 4 + 1.\r\t\tword := wordArray at: wordIndex.\r\t\tword := word bitOr: ((utf8 at: i) bitShift: shift).\r\t\twordArray at: wordIndex put: word.\r\t].\r\t^ wordArray"},{"name":"setAuthorInMetacelloVersion:","linesOfCode":5,"sourceCode":"setAuthorInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setAuthor: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"llvmPrintEscapedStringOn:","linesOfCode":2,"sourceCode":"llvmPrintEscapedStringOn: aStream\r\t^ self llvmPrintEscapedStringOn: aStream addNull: false"},{"name":"expandMacrosWithArguments:","linesOfCode":69,"sourceCode":"expandMacrosWithArguments: anArray\r\t\"Interpret the receiver pattern (<1p>, <1s>, <t>...) with argument passed in anArray.\"\r\t\r\t\"<Np> writes the N-th argument using #printString, but without trancating it.\"\r\t\"('<1p>: <2p>' expandMacrosWith: 'Number' with: 5 with: nil) >>> '''Number'': 5'\"\r\t\r\t\"<Ns> writes the N-th argument, which should be a String, or a collection of printable objects.\r\tNote also important distinction for single-quotes inside the argument; with <p> they will be doubled.\"\r\t\"('<1s> vs <1p>' expandMacrosWith: 'it''em') >>> 'it''em vs ''it''''em'''\"\r\t\r\t\"Whitespace characters:\"\r\t\"'<t>' expandMacros >>> String tab\"\r\t\"'<r>' expandMacros >>> String cr\"\r\t\"'<n>' expandMacros >>> OSPlatform current lineEnding\"\r\t\"'<l>' expandMacros >>> String lf\"\r\t\r\t\"Writing '<' character:\r\tTo write '<', prepend it with a percent sign.\"\r\t\"'%<n>' expandMacros >>> '<n>'\"\r\t\r\t\"Ternary operator:\r\tAn if-else string can be written with <N?yes-string:no-string>.\r\tThe N-th argument must be a Boolean.\r\tYes-string cannot contain colon ':', as it terminates the yes-string.\r\tNo-string cannot contain closing angle bracket '>', as it terminates the no-string.\"\r\t\"('<1?success:error>' expandMacrosWith: true) >>> 'success'\"\r\t\"('<1?success:is error>' expandMacrosWith: false) >>> 'is error'\"\r\t\r\t| readStream char index |\r\t^ self species\r\t\tnew: self size\r\t\tstreamContents:\r\t\t\t[ :newStream | \r\t\t\treadStream := self readStream.\r\t\t\t[ readStream atEnd ]\r\t\t\t\twhileFalse:\r\t\t\t\t\t[ char := readStream next.\r\t\t\t\t\tchar == $<\r\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t[ | nextChar |\r\t\t\t\t\t\t\tnextChar := readStream next asUppercase.\r\t\t\t\t\t\t\tnextChar == $R\r\t\t\t\t\t\t\t\tifTrue: [ newStream cr ].\r\t\t\t\t\t\t\tnextChar == $L\r\t\t\t\t\t\t\t\tifTrue: [ newStream lf ].\r\t\t\t\t\t\t\tnextChar == $T\r\t\t\t\t\t\t\t\tifTrue: [ newStream tab ].\r\t\t\t\t\t\t\tnextChar == $N\r\t\t\t\t\t\t\t\tifTrue: [ newStream nextPutAll: OSPlatform current lineEnding ].\r\t\t\t\t\t\t\tnextChar isDigit\r\t\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t\t[ index := nextChar digitValue.\r\t\t\t\t\t\t\t\t\t[ readStream atEnd or: [ (nextChar := readStream next asUppercase) isDigit not ] ]\r\t\t\t\t\t\t\t\t\t\twhileFalse: [ index := index * 10 + nextChar digitValue ] ].\r\t\t\t\t\t\t\tnextChar == $?\r\t\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t\t[ | trueString falseString |\r\t\t\t\t\t\t\t\t\ttrueString := readStream upTo: $:.\r\t\t\t\t\t\t\t\t\tfalseString := readStream upTo: $>.\r\t\t\t\t\t\t\t\t\treadStream position: readStream position - 1.\r\t\t\t\t\t\t\t\t\tnewStream\r\t\t\t\t\t\t\t\t\t\tnextPutAll:\r\t\t\t\t\t\t\t\t\t\t\t((anArray at: index)\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ trueString ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ falseString ]) ].\r\t\t\t\t\t\t\tnextChar == $P\r\t\t\t\t\t\t\t\tifTrue: [ (anArray at: index) printOn: newStream  ].\r\t\t\t\t\t\t\tnextChar == $S\r\t\t\t\t\t\t\t\tifTrue: [ newStream nextPutAll: (anArray at: index) ].\r\t\t\t\t\t\t\treadStream skipTo: $> ]\r\t\t\t\t\t\tifFalse: [ newStream\r\t\t\t\t\t\t\t\tnextPut:\r\t\t\t\t\t\t\t\t\t(char == $%\r\t\t\t\t\t\t\t\t\t\tifTrue: [ readStream next ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ char ]) ] ] ]"},{"name":"expandMacrosWith:with:with:with:","linesOfCode":6,"sourceCode":"expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject \r\t^self expandMacrosWithArguments: (Array \r\t\t\t\twith: anObject\r\t\t\t\twith: anotherObject\r\t\t\t\twith: thirdObject\r\t\t\t\twith: fourthObject)"},{"name":"trim","linesOfCode":4,"sourceCode":"trim\r\t\"Trim separators from both sides of the receiving string.\"\r\t\"' this string will be trimmed   ' trim >>> 'this string will be trimmed'\"\r\t\r\t^ self trimBoth"},{"name":"withLineEndings:","linesOfCode":25,"sourceCode":"withLineEndings: lineEndingString\r\t\"Answer a new instance where all occurrences of CRLF, CR, and LF are substituted with the specified line ending string.\"\r\t\r\t^ self species streamContents: [ :out |\r\t\t| in c |\r\t\tin := self readStream.\r\t\t[ in atEnd ] whileFalse: [\r\t\t\tc := in next.\r\t\t\t\"CR\"\r\t\t\tc == Character cr ifTrue: [\r\t\t\t\tc := in peek.\r\t\t\t\t\"CR LF\"\r\t\t\t\tc == Character lf ifTrue: [\r\t\t\t\t\tin next.\r\t\t\t\t].\r\t\t\t\tout nextPutAll: lineEndingString\r\t\t\t] ifFalse: [\r\t\t\t\t\"LF\"\r\t\t\t\tc == Character lf ifTrue: [\r\t\t\t\t\tout nextPutAll: lineEndingString\r\t\t\t\t] ifFalse: [\r\t\t\t\t\tout nextPut: c\r\t\t\t\t]\r\t\t\t]\r\t\t]\r\t]\r"},{"name":"asCamelCase","linesOfCode":7,"sourceCode":"asCamelCase\r\t\"Convert to CamelCase, i.e, remove spaces, and convert starting lowercase to uppercase.\"\r   \"'A man, a plan, a canal, panama' asCamelCase >>> 'AMan,APlan,ACanal,Panama'\"\r \t\"'Here 123should % be 6 the name6 of the method' asCamelCase  >>> 'Here123should%Be6TheName6OfTheMethod'\"\r\t\t^ self species streamContents: [:stream |\r               self substrings do: [:sub |\r                       stream nextPutAll: sub capitalized]]"},{"name":"asUppercase","linesOfCode":3,"sourceCode":"asUppercase\r\t\"Answer a String made up from the receiver whose characters are all uppercase.\"\r\r\t^self copy asString translateToUppercase"},{"name":"beginsWithEmpty:caseSensitive:","linesOfCode":14,"sourceCode":"beginsWithEmpty: prefix caseSensitive: aBoolean \r\t\"Answer whether the receiver begins with the given prefix string. \r\tThe comparison is case-sensitive.\" \r\t| matchTable |\r\tprefix isEmpty ifTrue: [ ^ true ].\r\tself size < prefix size ifTrue: [ ^ false ].\r\tmatchTable := aBoolean \r\t\tifTrue: [ CaseSensitiveOrder ]\r\t\tifFalse: [ CaseInsensitiveOrder ].\r\t^ (self \r\t\tfindSubstring: prefix\r\t\tin: self\r\t\tstartingAt: 1\r\t\tmatchTable: matchTable) = 1"},{"name":"findString:startingAt:caseSensitive:","linesOfCode":36,"sourceCode":"findString: key startingAt: start caseSensitive: caseSensitive \r\t\"Answer the index in this String at which the substring key first occurs,\r\tat or beyond start. The match can be case-sensitive or not. If no match\r\tis found, zero will be returned.\"\r\t\r\t\"IMPLEMENTATION NOTE: do not use CaseSensitiveOrder because it is broken for WideString\r\tThis is a temporary work around until Wide CaseSensitiveOrder search is fixed\r\tCode should revert to:\r\tcaseSensitive\r\t\tifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]\r\t\tifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]\"\r\t\t\r\t^caseSensitive\r\t\tifTrue: [\r\t\t\t(self class isBytes and: [key class isBytes])\r\t\t\t\tifTrue: [self\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseSensitiveOrder]\r\t\t\t\tifFalse: [WideString new\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: nil]]\r\t\tifFalse: [\r\t\t\t(self class isBytes and: [key class isBytes])\r\t\t\t\tifTrue: [self\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseInsensitiveOrder]\r\t\t\t\tifFalse: [WideString new\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseInsensitiveOrder]]"},{"name":"repeat:","linesOfCode":8,"sourceCode":"repeat: aNumber\r\t\"Returns a new string concatenated by itself repeated n times\"\r\t\"('abc' repeat: 3) >>> 'abcabcabc'\"\r\r\taNumber < 0 ifTrue: [ self error: 'aNumber cannot be negative' ].\t\r\t^ self species \r\t\tnew: self size * aNumber \r\t\tstreamContents: [ :stringStream |\r\t\t\t1 to: aNumber do: [ :idx | stringStream nextPutAll: self ] ]"},{"name":"asNumber","linesOfCode":4,"sourceCode":"asNumber \r\t\"Answer the Number created by interpreting the receiver as the string \r\trepresentation of a number.\"\r\r\t^Number readFromString: self"},{"name":"asClass","linesOfCode":3,"sourceCode":"asClass\r\t\"returns a global class with my name\"\r\t^ self asClassInEnvironment: Smalltalk globals"},{"name":"matchesRegex:","linesOfCode":6,"sourceCode":"matchesRegex: regexString\r\t\"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or\r\tchild signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegex matches: self"},{"name":"recordRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"recordRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self)."},{"name":"asLGitExternalString","linesOfCode":8,"sourceCode":"asLGitExternalString\r\t| data |\r\tdata := ExternalData\r\t\tfromHandle: (ExternalAddress allocate: self size + 1)\r\t\ttype: ExternalType char asPointerType.\r\tLibC memCopy: self to: data size: self size.\r\tdata getHandle byteAt: self size + 1 put: 0.\r\t^ data"},{"name":"skipDelimiters:startingAt:","linesOfCode":6,"sourceCode":"skipDelimiters: delimiters startingAt: start \r\t\"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string.\"\r\r\tstart to: self size do: [:i |\r\t\tdelimiters detect: [:delim | delim = (self at: i)]\r\t\t\t\tifNone: [^ i]].\r\t^ self size + 1"},{"name":"asPath","linesOfCode":8,"sourceCode":"asPath\r\t\"convert myself to a path\"\r\t\"Examples:\r\t\t'.' asPath\r\t\t'~/Desktop' asPath\r\t\t'/home/foo' asPath\r\t\t'../../foo.bar' asPath\"\r\t^ FileSystem disk resolve: self"},{"name":"setAuthorInMetacelloConfig:","linesOfCode":2,"sourceCode":"setAuthorInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setAuthorWithString: self"},{"name":"asDuration","linesOfCode":3,"sourceCode":"asDuration\r \t\"Convert from [-]D:HH:MM:SS[.S] format. What is between [] implies optional elements\"\r \r \t^ Duration fromString: self\r "},{"name":"lineNumber:","linesOfCode":7,"sourceCode":"lineNumber: anIndex\r\t\"Answer a string containing the characters in the given line number.\"\r\r\t| lineCount |\r\tlineCount := 0.\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\t(lineCount := lineCount + 1) = anIndex ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].\r\t^nil"},{"name":"howManyMatch:","linesOfCode":13,"sourceCode":"howManyMatch: string \r\t\"Count the number of characters in a substring that matches up in self and aString.\"\r\t\"('ab ab ac de' howManyMatch: 'ab') >>> 2\"\r\t\"('abab ac de' howManyMatch: 'abab') >>> 4\"\r\t\"('ab ab ac de' howManyMatch: 'a') >>> 1\"\r\t\"('ab ab ac de' howManyMatch: 'z') >>> 0\"\r\t\r\t| count shorterLength |\r\tcount := 0.\r\tshorterLength := self size min: string size.\r\t1 to: shorterLength do: [:index |\r\t\t(self at: index) = (string at: index )\r\t\t\tifTrue: [ count := count + 1 ]].\r\t^  count \r\t\r\t"},{"name":"loadRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"loadRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self)."},{"name":"asUrl","linesOfCode":2,"sourceCode":"asUrl\r\t^ self asZnUrl "},{"name":"asVmPathName","linesOfCode":6,"sourceCode":"asVmPathName\r\t\"This method returns self encoded in the encoding the system expects.\r\tWe default to utf8 as this is the most common encoding, but we should ask the system the current encoding instead.\r\t\r\tAlso, note the method name is wrong, this should be fixed\"\r\tself flag: #TODO.\r\t^ self utf8Encoded"},{"name":"substrings:","linesOfCode":18,"sourceCode":"substrings: separators\r\t\"Answer an array of non-empty substrings from the receiver separated by\r\tone or more characters from the 'separators' argument collection.\"\r\r\t| substrings substringStart |\r\tsubstrings := (Array new: 10) writeStream.\r\t1 to: self size do: [ :i | \r\t\t| nextChar |\r\t\tnextChar := self at: i.\r\t\t(separators includes: nextChar)\r\t\t\tifTrue: [\r\t\t\t\tsubstringStart\r\t\t\t\t\tifNotNil: [\r\t\t\t\t\t\tsubstrings nextPut: (self copyFrom: substringStart to: i - 1).\r\t\t\t\t\t\tsubstringStart := nil ] ]\r\t\t\tifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].\r\tsubstringStart\r\t\tifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].\r\t^ substrings contents"},{"name":"mergeIntoMetacelloPackages:","linesOfCode":11,"sourceCode":"mergeIntoMetacelloPackages: aMetacelloPackagesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself.\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec mergeMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"asSlot","linesOfCode":2,"sourceCode":"asSlot\r\t^ InstanceVariableSlot named: self"},{"name":"stringhash","linesOfCode":2,"sourceCode":"stringhash\r\r\t^ self hash.\r"},{"name":"setRequiresInMetacelloPackage:","linesOfCode":2,"sourceCode":"setRequiresInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setRequires: { self }."},{"name":"metacelloSemanticVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent\r    ^ aMetacelloVersonComponent metacelloSemanticStringLessThanSelf: self"},{"name":"inspectionString","linesOfCode":5,"sourceCode":"inspectionString\r\t<inspectorPresentationOrder: -10 title: 'String'>\r\t\r\t^ SpTextPresenter new\r\t\ttext: (self truncateWithElipsisTo: 100000);\r\t\tyourself"},{"name":"convertFromWithConverter:","linesOfCode":10,"sourceCode":"convertFromWithConverter: converter\r\r\t| readStream c |\r\treadStream := self readStream.\r\t^ self species new: self size streamContents: [ :writeStream|\r\t\tconverter ifNil: [^ self].\r\t\t[readStream atEnd] whileFalse: [\r\t\t\tc := converter nextFromStream: readStream.\r\t\t\tc\r\t\t\t\tifNotNil: [writeStream nextPut: c] \r\t\t\t\tifNil: [^ writeStream contents]]].\r"},{"name":"findSubstringViaPrimitive:in:startingAt:matchTable:","linesOfCode":23,"sourceCode":"findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\r\r\tThe algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter.\"\r\t| index |\r\t<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>\r\t<var: #key declareC: 'unsigned char *key'>\r\t<var: #body declareC: 'unsigned char *body'>\r\t<var: #matchTable declareC: 'unsigned char *matchTable'>\r\r\tkey size = 0 ifTrue: [^ 0].\r\t(start max: 1) to: body size - key size + 1 do:\r\t\t[:startIndex |\r\t\tindex := 1.\r\t\t\t[(matchTable at: (body basicAt: startIndex+index-1) + 1)\r\t\t\t\t= (matchTable at: (key basicAt: index) + 1)]\r\t\t\t\twhileTrue:\r\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\tindex := index+1]].\r\t^ 0\r\"\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0\r' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0\r' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7\r\""},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"slvmUTF8EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF8EncodedSize\r\t^ self utf8Encoded size"},{"name":"asCStringForGDB","linesOfCode":4,"sourceCode":"asCStringForGDB\r\t^ ByteString streamContents: [ :out |\r\t\tself asCStringForGDBInto: out\r\t]"},{"name":"llvmPrintEscapedStringOn:addNull:","linesOfCode":11,"sourceCode":"llvmPrintEscapedStringOn: aStream addNull: addNull\r\taStream nextPut: $\".\r\tself do: [ :element |\r\t\t(Character space <= element and: [ element <= $~ and: [('\\\"' includes: element) not]]) ifTrue: [ \r\t\t\taStream nextPut: element\r\t\t] ifFalse: [\r\t\t\taStream nextPut: $\\; nextPutAll: (element asInteger printStringBase: 16 length: 2 padded: true)\r\t\t]\r\t].\r\t\r\taddNull ifTrue: [ aStream nextPutAll: '\\00' ].\r\taStream nextPut: $\".\r"},{"name":"asStringMorph","linesOfCode":4,"sourceCode":"asStringMorph \r\t\"Answer the receiver as a StringMorph\"\r\r\t^ StringMorph contents: self\r\r\"'bugs black blood' asStringMorph openInHand\""},{"name":"llvmPrintNameOn:","linesOfCode":6,"sourceCode":"llvmPrintNameOn: aStream\r\tself isValidLLVMSymbol ifTrue: [\r\t\taStream nextPutAll: self\r\t] ifFalse: [\r\t\tself llvmPrintEscapedStringOn: aStream\r\t]"},{"name":"asPhanideRegex","linesOfCode":2,"sourceCode":"asPhanideRegex\r\t^ (PhanideRegexParser parse: self) simplified"},{"name":"asHex","linesOfCode":5,"sourceCode":"asHex\r\t\"'A' asHex >>> '16r41'\"\r\t\"'AA' asHex >>> '16r4116r41'\"\r\t^ self species new: self size * 4 streamContents: [ :stream |\r\t\tself do: [ :ch | stream nextPutAll: ch hex ]]"},{"name":"leadingCharRunLengthAt:","linesOfCode":7,"sourceCode":"leadingCharRunLengthAt: index\r\r\t| leadingChar |\r\tleadingChar := (self at: index) leadingChar.\r\tindex to: self size do: [:i |\r\t\t(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].\r\t].\r\t^ self size - index + 1.\r"},{"name":"startingAt:match:startingAt:","linesOfCode":43,"sourceCode":"startingAt: keyStart match: text startingAt: textStart\r\t\"Answer whether text matches the pattern in this string.\r\tMatching ignores upper/lower case differences.\r\tWhere this string contains #, text may contain any character.\r\tWhere this string contains *, text may contain any sequence of characters.\"\r\t\r\t| anyMatch matchStart matchEnd i matchStr j ii jj |\r\ti := keyStart.\r\tj := textStart.\r\t\r\t\"Process consecutive *s and #s at the beginning.\"\r\tanyMatch := false.\r\t[ i <= self size and: [\r\t\t(self at: i)\r\t\t\tcaseOf: {\r\t\t\t\t[ $* ] -> [ \r\t\t\t\t\tanyMatch := true.\r\t\t\t\t\ti := i + 1.\r\t\t\t\t\ttrue ].\r\t\t\t\t[ $# ] -> [\r\t\t\t\t\ti := i + 1.\r\t\t\t\t\tj := j + 1.\r\t\t\t\t\ttrue ] }\r\t\t\totherwise: [ false ] ] ] whileTrue.\r\ti > self size ifTrue: [\r\t\t^j - 1 = text size or: [ \"We reached the end by matching the character with a #.\"\r\t\t\tanyMatch and: [ j <= text size ] \"Or there was a * before the end.\" ] ].\r\tmatchStart := i.\r\r\t\"Now determine the match string\"\r\tmatchEnd := self size.\r\t(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue: [ matchEnd := ii-1 ].\r\t(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue: [ matchEnd := matchEnd min: ii-1 ].\r\tmatchStr := self copyFrom: matchStart to: matchEnd.\r\r\t\"Now look for the match string\"\r\t[jj := text findString: matchStr startingAt: j caseSensitive: false.\r\tanyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]\r\t\twhileTrue:\r\t\t[\"Found matchStr at jj.  See if the rest matches...\"\r\t\t(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:\r\t\t\t[^ true \"the rest matches -- success\"].\r\t\t\"The rest did not match.\"\r\t\tanyMatch ifFalse: [^ false].\r\t\t\"Preceded by * -- try for a later match\"\r\t\tj := j+1].\r\t^ false \"Failed to find the match string\""},{"name":"asString","linesOfCode":3,"sourceCode":"asString\r\t\"Answer this string.\"\r\r\t^ self\r"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget literalStringType"},{"name":"trimRight","linesOfCode":3,"sourceCode":"trimRight\r\t\"Trim separators from the right side of the receiving string.\"\r\t\r\t^ self trimRight: [ :char | char isSeparator ]"},{"name":"setBlessingInMetacelloVersion:","linesOfCode":5,"sourceCode":"setBlessingInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setBlessing: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"treeRenderSceneNodeWith:bounds:color:font:from:","linesOfCode":6,"sourceCode":"treeRenderSceneNodeWith: builder bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\t^ builder\r\t\tstring: self\r\t\tin: drawBounds \r\t\tfont: aMorph font\r\t\tcolor: drawColor"},{"name":"setTimestampInMetacelloConfig:","linesOfCode":2,"sourceCode":"setTimestampInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setTimestampWithString: self"},{"name":"writeLeadingCharRunsOn:","linesOfCode":7,"sourceCode":"writeLeadingCharRunsOn: stream\r\r\tself isEmpty ifTrue: [^ self].\r\r\tstream nextPut: $(.\r\tstream print: self size.\r\tstream skip: -1; nextPut: $).\r\tstream print: 0 \"was leading char\".\r\tstream skip: -1"},{"name":"numericSuffix","linesOfCode":4,"sourceCode":"numericSuffix\r\t\"'abc98' numericSuffix >>> 98\"\r\t\"'98abc' numericSuffix >>> 0\"\r\t^ self stemAndNumericSuffix last"},{"name":"wbtSubstituteVariablesWith:","linesOfCode":16,"sourceCode":"wbtSubstituteVariablesWith: aSubstitutionBlock\r\t| regex shouldContinue result |\r\tregex := '\\$\\(\\w*\\)' asRegex.\r\tshouldContinue := true.\r\tresult := self.\r\t[ shouldContinue ] whileTrue: [\r\t\tshouldContinue := false.\r\t\tresult := regex copy: result translatingMatchesUsing: [:varExpression |\r\t\t\t| rawVariableExpressionContent variableExpressionContentValue|\r\t\t\tshouldContinue := true.\r\t\t\trawVariableExpressionContent := (varExpression copyFrom: 3 to: varExpression size - 1).\r\t\t\tvariableExpressionContentValue := rawVariableExpressionContent wbtSubstituteVariablesWith: aSubstitutionBlock.\r\t\t\taSubstitutionBlock value: variableExpressionContentValue.\r\t\t]\r\t].\r\r\t^ result  "},{"name":"withAccentuatedCharacter:","linesOfCode":10,"sourceCode":"withAccentuatedCharacter: aKey\r\r\t| text index | \r\ttext := self asText.\r\taKey ifNil: [ ^ text ].\r\tindex := self asLowercase indexOf: aKey name asLowercase.\r\tindex isZero\r\t\tifTrue: [ ^ text ].\r\r\t^ text\r\t\taddAttribute: TextEmphasis underlined from: index to: index;\r\t\tyourself"},{"name":"asUncommentedCode","linesOfCode":19,"sourceCode":"asUncommentedCode\r\t\"this string reprensent a commented code, let's uncomment it\"\r\t\r\t^String streamContents:  [ :str |\r\t\t\r\t\t|doubleQuoteAlreadyFound|\r\t\tdoubleQuoteAlreadyFound := false.\r\t\t\r\t\tself withoutQuoting do: [ :char |\r\t\t\tchar = $\"\r\t\t\t\tifTrue: [ \r\t\t\t\t\tdoubleQuoteAlreadyFound \tifTrue: [ \r\t\t\t\t\t\t\tstr nextPut: $\" ].\r\t\t\t\t\tdoubleQuoteAlreadyFound := doubleQuoteAlreadyFound not.\r\t\t\t\t]\r\t\t\t\tifFalse: [ \r\t\t\t\t\tstr nextPut: char\r\t\t\t\t]\r\t\t ]\r\t]\r\r"},{"name":"metacelloIntegerLessThanSelf:","linesOfCode":3,"sourceCode":"metacelloIntegerLessThanSelf: anInteger\r\t\"integer version components are always '>' string component\"\r\r\t^false"},{"name":"asUTF8Bytes","linesOfCode":2,"sourceCode":"asUTF8Bytes\r\t^ ZnUTF8Encoder new encodeString: self"},{"name":"trimLeft:right:","linesOfCode":12,"sourceCode":"trimLeft: aLeftBlock right: aRightBlock\r\t\"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string.\"\r\r\t| left right |\r\tleft := 1.\r\tright := self size.\r\t\r\t[ left <= right and: [ aLeftBlock value: (self at: left) ] ]\r\t\twhileTrue: [ left := left + 1 ].\r\t\t\r\t[ left <= right and: [ aRightBlock value: (self at: right) ] ]\r\t\twhileTrue: [ right := right - 1 ].\r\t\t\r\t^ self copyFrom: left to: right"},{"name":"listRenderOn:atRow:bounds:color:backgroundColor:from:","linesOfCode":6,"sourceCode":"listRenderOn: aCanvas atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\r\taCanvas\r\t\tdrawString: self\r\t\tin: bounds\r\t\tfont: aMorph font\r\t\tcolor: color"},{"name":"romanNumber","linesOfCode":13,"sourceCode":"romanNumber\r\t| value v1 v2 |\r\tvalue := v1 := v2 := 0.\r\tself\r\t\treverseDo: [ :each | \r\t\t\teach = $-\r\t\t\t\tifTrue: [ ^ value negated ].\r\t\t\tv1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).\r\t\t\tvalue := v1 >= v2\r\t\t\t\tifTrue: [ value + v1 ]\r\t\t\t\tifFalse: [ value - v1 ].\r\t\t\tv2 := v1 ].\r\t^ value"},{"name":"treeRenderOn:bounds:color:font:from:","linesOfCode":6,"sourceCode":"treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\taCanvas\r\t\tdrawString: self\r\t\tin: drawBounds \r\t\tfont: aMorph font\r\t\tcolor: drawColor"},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a parser that accepts the receiving string.\"\r\r\t^ PPLiteralSequenceParser on: self"},{"name":"asLowercase","linesOfCode":6,"sourceCode":"asLowercase\r\t\"Answer a String made up from the receiver whose characters are all lowercase.\"\r\t\"'PhaRo' asLowercase >>> 'pharo'\"\r\t\"'' asLowercase >>> ''\"\r\t\"' ' asLowercase >>> ' '\"\t\r\t^ self copy asString translateToLowercase"},{"name":"fetchRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self)."},{"name":"urlEncoded","linesOfCode":4,"sourceCode":"urlEncoded\r\t\"URL Encode the receiver and return the resulting String.\r\tThis is an encoding where characters that are illegal in a URL are escaped.\"\r\r    ^ ZnPercentEncoder new encode: self\r"},{"name":"base64Decoded","linesOfCode":7,"sourceCode":"base64Decoded\r\t\"Decode the receiver assuming it was encoded using Base64, returning a ByteArray.\r\tBase64 encoding is a technique to represent binary data as ASCII text.\r\tThe inverse operation is ByteArray>>#base64Encoded\"\r\t\r\t\"'AgMFBwsNERMXHR8lKSsvNTs9Q0dJT1NZYWVna21xf4OJi5WXnaOnrbO1v8HFx9Pf4+Xp7/H7' base64Decoded\"\r\t\"'SGVsbG8gV29ybGQh' base64Decoded utf8Decoded\"\r\t\r\t^ ZnBase64Encoder new decode: self"},{"name":"slvmUTF32EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF32EncodedSize\r\t^ self slvmUTF32Encoded size"},{"name":"startsWithDigit","linesOfCode":7,"sourceCode":"startsWithDigit\r\t\"Answer whether the receiver's first character represents a digit\"\r\t\"'abc' startsWithDigit >>> false\"\r\t\"'0abc' startsWithDigit >>> true\"\r\t\"'1abc' startsWithDigit >>> true\"\r\t\"'11abc' startsWithDigit >>> true\"\r\t\r\t^ self size > 0 and: [self first isDigit]"},{"name":"indexOf:startingAt:","linesOfCode":6,"sourceCode":"indexOf: aCharacter startingAt: start\r\t\"Return the index of the argument in the receiver, only elements after the start of the element are considered zero if not present.\"\r\t\r\t\"('abcdf abcedf' indexOf: $a startingAt: 4) >>> 7\"\r\t\"('abddf bcdef' indexOf: $a startingAt: 100 ) >>> 0\"\r\t\r\t(aCharacter isCharacter) ifFalse: [^ 0].\r\t^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start"},{"name":"caseInsensitiveLessOrEqual:","linesOfCode":4,"sourceCode":"caseInsensitiveLessOrEqual: aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is case insensitive.\"\r\t^(self compare: aString caseSensitive: false) <= 2"},{"name":"asPackageIfAbsent:","linesOfCode":2,"sourceCode":"asPackageIfAbsent: aBlock\r\t^ RPackageOrganizer default packageNamed: self ifAbsent: aBlock"},{"name":"matchesRegexIgnoringCase:","linesOfCode":6,"sourceCode":"matchesRegexIgnoringCase: regexString\r\t\"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or\r\tchild signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegexIgnoringCase matches: self"},{"name":"withBlanksCondensed","linesOfCode":13,"sourceCode":"withBlanksCondensed\r\t\"Return a copy of the receiver with leading/trailing blanks (separators) removed\r\t and consecutive white spaces (separators) condensed to the first one.\"\r\r\t| trimmed lastBlank |\r\ttrimmed := self trimBoth.\r\t^ String streamContents: [ :stream | \r\t\t\tlastBlank := false.\r\t\t\ttrimmed\r\t\t\t\tdo: [ :eachChar | \r\t\t\t\t\t(eachChar isSeparator and: [ lastBlank ])\r\t\t\t\t\t\tifFalse: [ stream nextPut: eachChar ].\r\t\t\t\t\tlastBlank := eachChar isSeparator ] ]\r\r\t\" ' abc  d   ' withBlanksCondensed\""},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self subclassResponsibility"},{"name":"copyReplaceAll:with:asTokens:","linesOfCode":26,"sourceCode":"copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens\r\t\"Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring. ifTokens (valid for Strings only) specifies that the characters surrounding the replacement must not be alphanumeric (space). When ifTokens is set, it means that the replacement will not occur inside word.\"\r\r\t\"('test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true) >>> 'test longone string'\"\r\t\"('test te string' copyReplaceAll: 'te' with: 'longone' asTokens: false) >>> 'longonest longone string'\"\r\r\t| aString startSearch currentIndex endIndex |\r\r\taString := self.\r\tstartSearch := 1.\r\t[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)\r\t\t\t > 0]\r\t\twhileTrue: \r\t\t[endIndex := currentIndex + oldSubstring size - 1.\r\t\t(ifTokens not\r\t\t\tor: [(currentIndex = 1\r\t\t\t\t\tor: [(aString at: currentIndex-1) isAlphaNumeric not])\r\t\t\t\tand: [endIndex = aString size\r\t\t\t\t\tor: [(aString at: endIndex+1) isAlphaNumeric not]]])\r\t\t\tifTrue: [aString := aString\r\t\t\t\t\tcopyReplaceFrom: currentIndex\r\t\t\t\t\tto: endIndex\r\t\t\t\t\twith: newSubstring.\r\t\t\t\tstartSearch := currentIndex + newSubstring size]\r\t\t\tifFalse: [\r\t\t\t\tifTokens \r\t\t\t\t\tifTrue: [startSearch := currentIndex + 1]\r\t\t\t\t\tifFalse: [startSearch := currentIndex + newSubstring size]]].\r\t^ aString\r\r"},{"name":"surroundedBy:","linesOfCode":8,"sourceCode":"surroundedBy: aString\r\t\"Answer the receiver with leading and trailing aString.\"\r\t\"('hello' surroundedBy: 'abd') >>> 'abdhelloabd'\"\r\t\"('hello' surroundedBy: ' abd ') >>> ' abd hello abd '\"\r\t\r\t^ self species streamContents: [ :s|\r\t\ts nextPutAll: aString.\r\t\ts nextPutAll: self.\r\t\ts nextPutAll: aString ]."},{"name":"withNoLineLongerThan:","linesOfCode":25,"sourceCode":"withNoLineLongerThan: aNumber\r\t\"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number\"\r\t(aNumber isNumber not or: [ aNumber < 1 ]) ifTrue: [self error: 'too narrow'].\r\t^self species\r\t\tnew: self size * (aNumber + 1) // aNumber \"provision for supplementary line breaks\"\r\t\tstreamContents: [ :stream |\r\t\t\tself lineIndicesDo: [ :start :endWithoutDelimiters :end |\r\t\t\t\t| pastEnd lineStart |\r\t\t\t\tpastEnd := endWithoutDelimiters + 1.\r\t\t\t\t\"eliminate spaces at beginning of line\"\r\t\t\t\tlineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.\r\t\t\t\t[| lineStop lineEnd spacePosition |\r\t\t\t\tlineEnd := lineStop  := lineStart + aNumber min: pastEnd.\r\t\t\t\tspacePosition := lineStart.\r\t\t\t\t[spacePosition < lineStop] whileTrue: [\r\t\t\t\t\tspacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].\r\t\t\t\t\tspacePosition <= lineStop ifTrue: [lineEnd := spacePosition].\r\t\t\t\t].\r\t\t\t\t\"split before space or before lineStop if no space\"\r\t\t\t\tstream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).\r\t\t\t\t\"eliminate spaces at beginning of next line\"\r\t\t\t\tlineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].\r\t\t\t\tlineStart <= endWithoutDelimiters ]\r\t\t\t\t\twhileTrue: [stream cr].\r\t\t\t\tstream nextPutAll: (self copyFrom: pastEnd to: end) ] ]"},{"name":"asByteString","linesOfCode":4,"sourceCode":"asByteString\r\t\"Convert the receiver into a ByteString, if possible\"\r\t\"Do not raise an error if it's not possible, since my use case is usually one in which WideStrings may or may not have been mutated to something representable in a ByteString, and we mostly do this to save space if possible. If the percentage of such cases are small, it may be better to use isOctetString check first to avoid creating String instances\"\t\r\t^self asOctetString"},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream \r\t\"Print inside string quotes, doubling inbedded quotes.\"\r \r\tself storeOn: aStream"},{"name":"compare:with:collated:","linesOfCode":13,"sourceCode":"compare: string1 with: string2 collated: order\r\t\r\t\"'abc' = 'abc' asWideString >>> true\"\r\t\"'abc' asWideString = 'abc' >>> true\"\r\t\"(ByteArray with: 97 with: 0 with: 0 with: 0) asString ~= 'a000' asWideString >>> true\"\r\t\"('abc' sameAs: 'aBc' asWideString) >>> true\"\r\t\"('aBc' asWideString sameAs: 'abc') >>> true\"\r\t\"('a000' asWideString ~= (ByteArray with: 97 with: 0 with: 0 with: 0) asString) >>> true\"\r\t\"((ByteArray with: 97 with: 0 with: 0 with: 0) asString sameAs: 'Abcd' asWideString) >>> false\"\r\t\"('a000' asWideString sameAs: (ByteArray with: 97 with: 0 with: 0 with: 0) asString) >>> false\"\r\t\r\t(string1 isByteString and: [string2 isByteString]) ifTrue: [\r\t\t^ ByteString compare: string1 with: string2 collated: order].\r     \"Primitive does not fail properly right now\"\r\t^ String compare: string1 with: string2 collated: order"},{"name":"translateToUppercase","linesOfCode":3,"sourceCode":"translateToUppercase\r\t\"Translate all characters to lowercase, in place\"\r\r\tself translateWith: UppercasingTable"},{"name":"addToMetacelloPackages:","linesOfCode":11,"sourceCode":"addToMetacelloPackages: aMetacelloPackagesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself.\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec addMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"compare:","linesOfCode":11,"sourceCode":"compare: aString \r\t\"Answer a comparison code telling how the receiver sorts relative to aString:\r\t\t1 - before\r\t\t2 - equal\r\t\t3 - after.\r\tThe collation sequence is ascii with case differences ignored.\r\tTo get the effect of a <= b, but ignoring case, use (a compare: b) <= 2.\"\r\t\"('aa' compare: 'ab') >>> 1\"\r\t\"('aa' compare: 'aa') >>> 2\"\r\t\"('ab' compare: 'aa') >>> 3\"\r\t\r\t^self compare: aString caseSensitive: false"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\r\t^true"},{"name":"indexOfWideCharacterFrom:to:","linesOfCode":6,"sourceCode":"indexOfWideCharacterFrom: start to: end\r\t\"Return the index of the first wide character following anIndex\"\r\t\"Implementation note: inline #anySatisfy: here for efficiency reasons\"\r\t\r\tstart to: end do: [:ix | \r\t\t(self basicAt: ix) > 255 ifTrue: [ ^ix ]].\r\t^ 0"},{"name":"asFFILibrary","linesOfCode":2,"sourceCode":"asFFILibrary \r\t^ FFIUnknownLibrary name: self"},{"name":"threeWayCompareTo:","linesOfCode":8,"sourceCode":"threeWayCompareTo: aString\r\t\"Do a three-way comparison between the receiver and anotherObject, returning\r\t-1 if self < anotherObject\r\t0 if self = anotherObject\r\t1 if self > anotherObject\r\tThis assumes a total order in accordance with the mathematical law of trichotomy.\r\tSee also:  http://en.wikipedia.org/wiki/Three-way_comparison\"\r\r\t ^ (self compare: self with: aString collated: AsciiOrder) - 2"},{"name":"trimmed","linesOfCode":2,"sourceCode":"trimmed\r\t^ self trimBoth"},{"name":"setBlessingInMetacelloConfig:","linesOfCode":2,"sourceCode":"setBlessingInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setBlessingWithString: self"},{"name":"asInstanceSideBehaviorName","linesOfCode":2,"sourceCode":"asInstanceSideBehaviorName\r\r\t^ (self splitOn: Character space) first"},{"name":"withoutLeadingDigits","linesOfCode":4,"sourceCode":"withoutLeadingDigits\r\t\"Answer the portion of the receiver that follows any leading series of digits and separators.\r\tIf the receiver consists entirely of digits and separators, return an empty string\"\r\r\t^ self trimLeft: [ :char | char isDigit or: [ char isSeparator ] ]"},{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator\r\t^ generator resolveType: self"},{"name":"allRangesOfRegexMatches:","linesOfCode":2,"sourceCode":"allRangesOfRegexMatches: rxString\r\r\t^rxString asRegex matchingRangesIn: self"},{"name":"<=","linesOfCode":7,"sourceCode":"<= aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' <= 'def' >>> true\"\r\t\" 'abc' <= 'abc' >>> true\"\r\t\" 'def' <= 'abc' >>> false\"\r\t\r\t^ (self compare: self with: aString collated: AsciiOrder) <= 2"},{"name":"setIncludesInMetacelloPackage:","linesOfCode":2,"sourceCode":"setIncludesInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setIncludes: { self }."},{"name":"convertFromEncoding:","linesOfCode":2,"sourceCode":"convertFromEncoding: encodingName\r\t^self convertFromWithConverter: (TextConverter newForEncoding: encodingName)"},{"name":"wbtSolveLinkLibrariesInPackage:","linesOfCode":2,"sourceCode":"wbtSolveLinkLibrariesInPackage: targetPackage\r\t^ {targetPackage getMainTargetNamed: self ifAbsent: [ WBTImportedLibraryTarget new name: self ]}"},{"name":"llvmNameForHandle","linesOfCode":3,"sourceCode":"llvmNameForHandle\r\t(self allSatisfy: [ :each | each isDigit ]) ifTrue: [ ^ '' ].\r\t^ self"},{"name":"heightToDisplayInList:","linesOfCode":2,"sourceCode":"heightToDisplayInList: aList\r\r\t^ aList font height"},{"name":"withCRs","linesOfCode":5,"sourceCode":"withCRs\r\t\"Return a copy of the receiver in which backslash (\\) characters have been replaced with carriage returns. For example '-hello\\-hi' will be\r\t'-hello\r\t -hi'\"\r\r\t^ self collect: [ :c | c = $\\ ifTrue: [ Character cr ] ifFalse: [ c ]]."},{"name":"lineCount","linesOfCode":7,"sourceCode":"lineCount\r\t\"Answer the number of lines represented by the receiver, where every line delimiter CR, LF or CRLF pair adds one line.\"\r\r\t| lineCount |\r\tlineCount := 0.\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tlineCount := lineCount + 1].\r\t^lineCount"},{"name":"match:","linesOfCode":21,"sourceCode":"match: text\r\t\"Answer whether text matches the pattern in this string.\r\tMatching ignores upper/lower case differences.\r\tWhere this string contains #, text may contain any character.\r\tWhere this string contains *, text may contain any sequence of characters.\"\r\t\r\t\"('*' match: 'zort') >>> true\"\r\t\"('*baz' match: 'mobaz') >>> true\"\r\t\"('*baz' match: 'mobazo') >>>false\"\r\t\"('*baz*' match: 'mobazo') >>> true\"\r\t\"('*baz*' match: 'mozo') >>> false\"\r\t\"('foo*' match: 'foozo') >>> true\"\r\t\"('foo*' match: 'bozo') >>> false\"\r\t\"('foo*baz' match: 'foo23baz') >>> true\"\r\t\"('foo*baz' match: 'foobaz') >>> true\"\r\t\"('foo*baz' match: 'foo23bazo') >>> false\"\r\t\"('foo' match: 'Foo') >>> true\"\r\t\"('foo*baz*zort' match: 'foobazort') >>> false\"\r\t\"('foo*baz*zort' match: 'foobazzort') >>> true\"\r\t\"('*foo#zort' match: 'afoo3zortthenfoo3zort') >>> true\"\r\t\"('*foo*zort' match: 'afoodezortorfoo3zort') >>> true\"\r\r\t^ self startingAt: 1 match: text startingAt: 1"},{"name":"compare:caseSensitive:","linesOfCode":9,"sourceCode":"compare: aString caseSensitive: aBool\r\t\"Answer a comparison code telling how the receiver sorts relative to aString:\r\t\t1 - before\r\t\t2 - equal\r\t\t3 - after.\r\t\"\r\t| map |\r\tmap := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].\r\t^self compare: self with: aString collated: map"},{"name":"alike:","linesOfCode":16,"sourceCode":"alike: aString \r\t\"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score (but see example with 7).  Case is ignored. This method is used to help find mistyped variable names in methods.\"\r\t\"('abc' alike: 'abc') >>> 7.\"\r\t\"('action' alike: 'actions') >>> 7.\"\r\t\"('action' alike: 'caption') >>> 5.\"\r\t\"('action' alike: 'name') >>> 0.\"\t\r\r\t| i j k minSize bonus |\r\tminSize := (j := self size) min: (k := aString size).\r\tbonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].\r\ti := 1.\r\t[(i <= minSize) and: [((self at: i) asInteger bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]\r\t\twhileTrue: [ i := i + 1 ].\r\t[(j > 0) and: [(k > 0) and:\r\t\t[((self at: j) asInteger bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]\r\t\t\twhileTrue: [ j := j - 1.  k := k - 1. ].\r\t^ i - 1 + self size - j + bonus"},{"name":"gtInspectorTextIn:","linesOfCode":5,"sourceCode":"gtInspectorTextIn: composite\r\t<gtInspectorPresentationOrder: -10>\r\tcomposite text\r\t\ttitle: 'String';\r\t\tdisplay: [ self truncateWithElipsisTo: 100000 ]"},{"name":"asFileLocatorOrReference","linesOfCode":2,"sourceCode":"asFileLocatorOrReference\r\r\t^ FileLocator fromString: self ifNone: [ self asFileReference ]\r"},{"name":"isLLVMAnon","linesOfCode":2,"sourceCode":"isLLVMAnon\r\t^ self detect: [:c | c isDigit not] ifFound: [false] ifNone: [ true ]"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createObjectBytes: self asUTF8Bytes class: objectModel stringClass"},{"name":"displayOn:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium\r\t\"Display the receiver on the given DisplayMedium.\"\r\r\tself displayOn: aDisplayMedium at: 0 @ 0"},{"name":"setProject:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setProject: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setProject: aString withString: self"},{"name":"findAnySubstring:startingAt:","linesOfCode":8,"sourceCode":"findAnySubstring: aCollection startingAt: start \r\t\"Answer the index where an element of aCollection begins. If none are found, answer size + 1. aCollection is an Array of Strings or Characters.\"\r\r\t^aCollection inject: 1 + self size into: [:min :searchTerm |\r\t\t| ind |\r\t\tind := searchTerm isCharacter \r\t\t\tifTrue: [self indexOf: searchTerm startingAt: start ifAbsent: [min]]\r\t\t\tifFalse: [self indexOfSubCollection: searchTerm startingAt: start ifAbsent: [min]].\r\t\tmin min: ind]"},{"name":"withInternalLineEndings","linesOfCode":3,"sourceCode":"withInternalLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with CR. Pharo internally uses CR for carriage return.\"\r\r\t^ self withLineEndings: String cr"},{"name":"findWordStart:startingAt:","linesOfCode":9,"sourceCode":"findWordStart: key startingAt: start\r\t| ind |\r\t\"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned.\"\r\r\tind := start.\r\t[ind := self findString: key startingAt: ind caseSensitive: false.\r\tind = 0 ifTrue: [^ 0].\t\"not found\"\r\tind = 1 ifTrue: [^ 1].\t\"First char is the start of a word\"\r\t(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].\r\t^ ind\t\"is a word start\""},{"name":"translatedTo:","linesOfCode":3,"sourceCode":"translatedTo: localeID \r\t\"answer the receiver translated to the given locale id\"\r\t^ NaturalLanguageTranslator translate: self toLocale: localeID"},{"name":"truncateTo:","linesOfCode":5,"sourceCode":"truncateTo: smallSize\r\t\"return myself or a copy shortened to smallSize.\"\r\r\t^ self size <= smallSize\r\t\tifTrue: [ self ]\r\t\tifFalse: [ self copyFrom: 1 to: smallSize ]"},{"name":"lineCorrespondingToIndex:","linesOfCode":5,"sourceCode":"lineCorrespondingToIndex: anIndex\r\t\"Answer a string containing the line at the given character position.\"\r\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tanIndex <= end ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].\r\t^''"},{"name":"capitalized","linesOfCode":7,"sourceCode":"capitalized\r\t\"Return a copy with the first letter capitalized\"\r\t| cap |\r\tself isEmpty ifTrue: [ ^self copy ].\r\tcap := self copy.\r\tcap at: 1 put: (cap at: 1) asUppercase.\r\t^ cap"},{"name":"asBrick","linesOfCode":4,"sourceCode":"asBrick\r\r\t^ GLMLabelBrick new\r\t\ttext: self asString;\r\t\theight: [ :b | b approximateHeight ]"},{"name":"asClassInEnvironment:","linesOfCode":5,"sourceCode":"asClassInEnvironment: anEnvironment\r\t\"I return class named after myself from anEnvironment\"\r\t^ self \r\t\tasClassInEnvironment: anEnvironment \r\t\tifAbsent: [ NotFound signalFor: self in: anEnvironment ]"},{"name":"translateToLowercase","linesOfCode":3,"sourceCode":"translateToLowercase\r\t\"Translate all characters to lowercase, in place\"\r\r\tself translateWith: LowercasingTable"},{"name":"findString:startingAt:","linesOfCode":6,"sourceCode":"findString: substring startingAt: start \r\t\"Answer the index of the first substring within the receiver, starting at start. If the receiver does not contain substring, answer 0.\"\r\t\"('salkjsdlkgfee' findString: 'ee'startingAt: 3) >>> 12\"\r\t\"('salkjsdlkgfee' findString: 'al'startingAt: 3) >>> 0\"\r\t\"('salkjsdlkgfeeal' findString: 'al' startingAt: 1) >>> 2\"\r\t\r\t^self findString: substring startingAt: start caseSensitive: true"},{"name":"correctAgainst:continuedFrom:","linesOfCode":7,"sourceCode":"correctAgainst: wordList continuedFrom: oldCollection\r\t\"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList.\"\r\r\t^ wordList \r\t\tifNil: [ self correctAgainstEnumerator: nil\r\t\t\t\t\tcontinuedFrom: oldCollection ]\r\t\tifNotNil: [ self correctAgainstEnumerator: [ :action | wordList do: action without: nil]\r\t\t\t\t\tcontinuedFrom: oldCollection ]"},{"name":"expandMacrosWith:with:","linesOfCode":3,"sourceCode":"expandMacrosWith: anObject with: anotherObject \r\t^self \r\t\texpandMacrosWithArguments: (Array with: anObject with: anotherObject)"},{"name":"asTime","linesOfCode":3,"sourceCode":"asTime\r\t\"Many allowed forms, see Time>>readFrom:\"\r\r\t^ Time fromString: self."},{"name":"indexOf:","linesOfCode":9,"sourceCode":"indexOf: aCharacter\r\t\"Return the index starting at 1 of the argument in the receiver, zero if not present.\"\r\t\"('abcdf' indexOf: $a) >>> 1\"\r\t\"('abddf' indexOf: $k) >>> 0\"\r\t\r\taCharacter isCharacter ifFalse: [^ 0].\r\t^ self class\r\t\tindexOfAscii: aCharacter asciiValue\r\t\tinString: self\r\t\tstartingAt: 1.\r"},{"name":"lineNumberCorrespondingToIndex:","linesOfCode":8,"sourceCode":"lineNumberCorrespondingToIndex: anIndex\r\t\"Answer a lineNumber for the line at the given character position.\"\r\t|lineNumber|\r\t\r\tlineNumber := 0.\r\t\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tlineNumber := lineNumber + 1.\r\t\tanIndex <= end ifTrue: [^lineNumber]].\r\t^lineNumber"},{"name":"metacelloStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloStringLessThanSelf: aString\r\r\t^aString < self"},{"name":">","linesOfCode":7,"sourceCode":"> aString \r\t\"Answer whether the receiver sorts after aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'def' > 'abc' >>> true\"\r\t\" 'def' > 'def' >>> false\"\r\t\" 'abc' > 'def' >>> false\"\r\r\r\t^ (self compare: self with: aString collated: AsciiOrder) = 3"},{"name":"browseDirectory","linesOfCode":2,"sourceCode":"browseDirectory\r\t^ (PhideProject forDirectory: self) openBrowser"},{"name":"wbtSolveMainElementInPackage:","linesOfCode":2,"sourceCode":"wbtSolveMainElementInPackage: targetPackage\r\t^ targetPackage getMainTargetNamed: self ifAbsent: [ self error: 'Failed to solve' ]"},{"name":"copyWithRegex:matchesReplacedWith:","linesOfCode":3,"sourceCode":"copyWithRegex: rxString matchesReplacedWith: aString\r\r\t^rxString asRegex\r\t\tcopy: self replacingMatchesWith: aString"},{"name":"asSignedInteger","linesOfCode":9,"sourceCode":"asSignedInteger \r\t\"Returns the first signed integer it can find or nil.\"\r\r\t| start stream |\r\tstart := self findFirst: [:char | char isDigit].\r\tstart isZero ifTrue: [^ nil].\r\tstream := self readStream position: start - 1.\r\t((stream position ~= 0) and: [stream peekBack = $-])\r\t\tifTrue: [stream back].\r\t^ Integer readFrom: stream"},{"name":"prefixMatchesRegexIgnoringCase:","linesOfCode":6,"sourceCode":"prefixMatchesRegexIgnoringCase: regexString\r\t\"Test if the receiver's prefix matches a regex.\t\r\tMay raise RxParser class>>regexErrorSignal or child signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegexIgnoringCase matchesPrefix: self"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":7,"sourceCode":"indexOf: aCharacter startingAt: start ifAbsent: aBlock\r\t| ans |\r\taCharacter isCharacter ifFalse: [ ^ aBlock value ].\r\tans := self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start.\r\t^ ans = 0\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ ans ]"},{"name":"endOfParagraphBefore:","linesOfCode":7,"sourceCode":"endOfParagraphBefore: aNumber\r\t\"Return the index of the last Character cr before position aNumber, or zero if this is the first paragraph.\r\t'ddd' endOfParagraphBefore: 3\r\t'dd\r\td' endOfParagraphBefore: 4\r\t\"\r\t^ self lastIndexOf: Character cr startingAt: aNumber - 1 ifAbsent: [ 0 ]"},{"name":"asOctetString","linesOfCode":7,"sourceCode":"asOctetString\r\t\"Convert the receiver into an octet string, if possible\"\r\t\"(IE, I am a WideString containing only character with codePoints < 255, so all of them fit in a latin1-string).\"\r\t| string |\r\tstring := String new: self size.\r\t1 to: self size do: [:i | string at: i put: (self at: i)].\r\t^string"},{"name":"asPresenter","linesOfCode":4,"sourceCode":"asPresenter \r\r\t^ SpLabelPresenter new \r\t\tlabel: self;\r\t\tyourself"},{"name":"asFourCode","linesOfCode":15,"sourceCode":"asFourCode\r\t\"'abcd' asFourCode >>> -513645724\"\r\t\"'1111' asFourCode >>> 825307441\"\r\t\"'1234' asFourCode >>> 825373492\"\r\t| result |\r\tself size = 4 \r\t\tifFalse: [^self error: 'must be exactly four characters'].\r\t\t\r\tresult := self inject: 0 into: [:val :each | 256 * val + each asciiValue ].\r\t(result bitAnd: 16r80000000) = 0 \r\t\tifFalse: [ Error signal: 'cannot resolve fourcode' ].\r\t\t\r\t(result bitAnd: 16r40000000) = 0 \r\t\tifFalse: [ ^ result - 16r80000000 ].\r\t^ result\r"},{"name":"allRangesOfSubstring:","linesOfCode":11,"sourceCode":"allRangesOfSubstring: aSubstring\r\t\"('Ab cd ef Ab cd' allRangesOfSubstring: 'cd') >>> {(4 to: 5). (13 to: 14)}\"\r\t\"('Ab cd ef Ab cd' allRangesOfSubstring: 'zz') >>> #()\"\r\t\r\t^ Array streamContents: [:s | | start subSize |\r\t\tstart := 1.\r\t\tsubSize := aSubstring size.\r\t\t[start isZero]\r\t\t\twhileFalse: [ start := self findString: aSubstring startingAt: start.\r\t\t\t\tstart > 0 \r\t\t\t\t\tifTrue: [s nextPut: (start to: start + subSize - 1).\r\t\t\t\t\t\tstart := start + subSize]]]"},{"name":"truncateWithElipsisTo:","linesOfCode":8,"sourceCode":"truncateWithElipsisTo: maxLength\r\t\"Return myself or a copy suitably shortened but with elipsis added\"\r\r\t^ self size <= maxLength\r\t\tifTrue:\r\t\t\t[self]\r\t\tifFalse:\r\t\t\t[(self copyFrom: 1 to: (maxLength - 3)), '...']\r\r\r\t\"'truncateWithElipsisTo:' truncateWithElipsisTo: 20\""},{"name":"onlyLetters","linesOfCode":3,"sourceCode":"onlyLetters\r\t\"answer the receiver with only letters\"\r\t^ self select:[:each | each isLetter]"},{"name":"extractNumber","linesOfCode":2,"sourceCode":"extractNumber\r\t^ ('0', self select: [:ea | ea isDigit]) asNumber"},{"name":"withUnixLineEndings","linesOfCode":4,"sourceCode":"withUnixLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with LF.\"\r\t\"(('asa' , String cr , 'asa') withUnixLineEndings at: 4) >>> Character lf\"\r\r\t^ self withLineEndings: String lf"},{"name":"heightToDisplayInTree:","linesOfCode":2,"sourceCode":"heightToDisplayInTree: aTree\r\r\t^ aTree fontToUse height"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a parser that accepts the receiving string.\"\r\r\t^ PP2LiteralSequenceNode on: self"},{"name":"isAllDigits","linesOfCode":8,"sourceCode":"isAllDigits\r\t\"Return whether the receiver is composed entirely of digits and has at least one digit\"\r\t\"'2345' isAllDigits >>> true\"\r\t\"'0002345' isAllDigits >>> true\"\r\t\"'2345.88' isAllDigits >>> false\"\r\t\r\tself do: [:c | c isDigit ifFalse: [^ false]].\r\tself ifEmpty: [^false].\r\t^ true"},{"name":"asPackage","linesOfCode":2,"sourceCode":"asPackage\r\t^ self asPackageIfAbsent: [ NotFound new messageText: 'There is no package named ', self; object: self; signal ] "},{"name":"asUnsignedInteger","linesOfCode":7,"sourceCode":"asUnsignedInteger\r\t\"Returns the first integer it can find or nil.\"\r\t| start stream |\r\tstart := self findFirst: [ :char | char isDigit ].\r\tstart isZero ifTrue: [ ^ nil ].\r\tstream := self readStream position: start - 1.\r\t^ Integer readFrom: stream"},{"name":"findTokens:escapedBy:","linesOfCode":50,"sourceCode":"findTokens: delimiters escapedBy: quoteDelimiters \r\t\"Answer a collection of Strings separated by the delimiters, where  \r\tdelimiters is a Character or collection of characters. Two delimiters in a  \r\trow produce an empty string (compare this to #findTokens, which  \r\ttreats sequential delimiters as one).  \r\t \r\tThe characters in quoteDelimiters are treated as quote characters, such  \r\tthat any delimiter within a pair of matching quoteDelimiter characters  \r\tis treated literally, rather than as a delimiter.  \r\t \r\tThe quoteDelimiter characters may be escaped within a quoted string.  \r\tTwo sequential quote characters within a quoted string are treated as  \r\ta single character.  \r\t \r\tThis method is useful for parsing comma separated variable strings for  \r\tspreadsheet import and export.\"\r\t| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |\r\tdelimiterChars := (delimiters \r\t\tifNil: [ '' ]\r\t\tifNotNil: [ delimiters ]) asString.\r\tquoteChars := (quoteDelimiters \r\t\tifNil: [ '' ]\r\t\tifNotNil: [ quoteDelimiters ]) asString.\r\ttokens := OrderedCollection new.\r\trs := self readStream.\r\tactiveEscapeCharacter := nil.\r\tts := String new writeStream.\r\t[ rs atEnd ] whileFalse: \r\t\t[ char := rs next.\r\t\tactiveEscapeCharacter \r\t\t\tifNil: \r\t\t\t\t[ (quoteChars includes: char) \r\t\t\t\t\tifTrue: [ activeEscapeCharacter := char ]\r\t\t\t\t\tifFalse: \r\t\t\t\t\t\t[ (delimiterChars includes: char) \r\t\t\t\t\t\t\tifTrue: \r\t\t\t\t\t\t\t\t[ token := ts contents.\r\t\t\t\t\t\t\t\ttokens add: token.\r\t\t\t\t\t\t\t\tts := String new writeStream ]\r\t\t\t\t\t\t\tifFalse: [ ts nextPut: char ] ] ]\r\t\t\tifNotNil: \r\t\t\t\t[ char == activeEscapeCharacter \r\t\t\t\t\tifTrue: \r\t\t\t\t\t\t[ rs peek == activeEscapeCharacter \r\t\t\t\t\t\t\tifTrue: [ ts nextPut: rs next ]\r\t\t\t\t\t\t\tifFalse: [ activeEscapeCharacter := nil ] ]\r\t\t\t\t\tifFalse: [ ts nextPut: char ] ] ].\r\ttoken := ts contents.\r\t(tokens isEmpty and: [ token isEmpty ]) ifFalse: [ tokens add: token ].\r\t^ tokens"},{"name":"asResolvedBy:","linesOfCode":2,"sourceCode":"asResolvedBy: aFileSystem\r\t^ aFileSystem resolveString: self"},{"name":"stonContainSubObjects","linesOfCode":2,"sourceCode":"stonContainSubObjects \r\t^ false"},{"name":"charactersExactlyMatching:","linesOfCode":11,"sourceCode":"charactersExactlyMatching: aString\r\t\"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly.\"\r\t\"('s' charactersExactlyMatching: 'abc') >>> 0\"\r\t\"('fear is the little death that the.' charactersExactlyMatching: 'the') >>> 0\"\r\t\"('fear is the little death that the.' charactersExactlyMatching: 'fear is') >>> 7\"\r\t\r\t| count |\r\tcount := self size min: aString size.\r\t1 to: count do: [:i | \r\t\t(self at: i) = (aString at: i) ifFalse: [\r\t\t\t^ i - 1]].\r\t^ count"},{"name":"asSlotCollection","linesOfCode":6,"sourceCode":"asSlotCollection\r\t\"Parse as slots. Use space, tab and cr as separators\r\tExample: \r\t  'a b' asSlotCollection --> {a => Slot. b => Slot}\r\t\"\r\t\r\t^(self substrings: Character separators) collect: [ :substring | substring asSymbol asSlot ]"},{"name":"sameAs:","linesOfCode":4,"sourceCode":"sameAs: aString \r\t\"Answer whether the receiver sorts equal to aString. The \r\tcollation sequence is ascii with case differences ignored.\"\r\t^(self compare: aString caseSensitive: false) = 2"},{"name":"asZnUrl","linesOfCode":2,"sourceCode":"asZnUrl\r\t^ ZnUrl fromString: self"},{"name":"asColor","linesOfCode":2,"sourceCode":"asColor\r\t^ Color fromHexString: self"},{"name":"includesSubstring:caseSensitive:","linesOfCode":7,"sourceCode":"includesSubstring: aString caseSensitive: caseSensitive\r\t\"Returns whether the receiver contains the argument.\"\r\t\"('abcdefgh' includesSubstring: 'de' caseSensitive: false) >>> true\"\r\t\"('abcdefgh' includesSubstring: 'DE' caseSensitive: false) >>> true\"\r\t\"('abcDefgh' includesSubstring: 'De' caseSensitive: true) >>> true\"\r\t\"('abcDefgh' includesSubstring: 'DE' caseSensitive: true) >>> false\"\r\t\r\t^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0"},{"name":"keywords","linesOfCode":20,"sourceCode":"keywords\r\t\"Answer an array of the keywords that compose the receiver.\"\r\t| keywords |\r\tkeywords := Array streamContents:\r\t\t[:kwds | | char kwd | kwd := (String new: 16) writeStream.\r\t\t1 to: self size do:\r\t\t\t[:i |\r\t\t\tkwd nextPut: (char := self at: i).\r\t\t\tchar = $: ifTrue: \r\t\t\t\t\t[kwds nextPut: kwd contents.\r\t\t\t\t\tkwd reset]].\r\t\t(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].\r\t(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:\r\t\t[\"Has an initial keyword, as in #:if:then:else:\"\r\t\tkeywords := keywords allButFirst].\r\t(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:\r\t\t[\"Has a final keyword, as in #nextPut::andCR\"\r\t\tkeywords := keywords copyReplaceFrom: keywords size - 1\r\t\t\t\t\t\t\t\tto: keywords size with: {':' , keywords last}].\r\t^ keywords"},{"name":"setPreLoadDoItInMetacelloSpec:","linesOfCode":2,"sourceCode":"setPreLoadDoItInMetacelloSpec: aMetacelloSpec\r    self asSymbol setPreLoadDoItInMetacelloSpec: aMetacelloSpec"},{"name":"llvmPrintSpecializedMetadataValueOn:","linesOfCode":2,"sourceCode":"llvmPrintSpecializedMetadataValueOn: aStream\r\tself llvmPrintEscapedStringOn: aStream"},{"name":"isByteString","linesOfCode":3,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t^false"},{"name":"string","linesOfCode":2,"sourceCode":"string\r\t^self"},{"name":"asClassInEnvironment:ifAbsent:","linesOfCode":9,"sourceCode":"asClassInEnvironment: anEnvironment ifAbsent: absentBlock\r\t^  anEnvironment \r\t\t\tat: self asSymbol \r\t\t\tifPresent: [ :aClass| \r\t\t\t\tself \r\t\t\t\t\tassert: aClass isBehavior \r\t\t\t\t\tdescription: [ self printString, ' is not a Class but an instance of a ', aClass class name ].\r\t\t\t\taClass ]\r\t\t\tifAbsent: absentBlock\r\t"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeString: self"},{"name":"asWBTVarSubstitution","linesOfCode":2,"sourceCode":"asWBTVarSubstitution\r\t^ self"},{"name":"asWin32WideString","linesOfCode":2,"sourceCode":"asWin32WideString\r\r\t^ Win32WideString fromString: self"},{"name":"asAlien","linesOfCode":4,"sourceCode":"asAlien\r\t| bs |\r\t^(Alien newC: (bs := self byteSize) + 1)\r\t\treplaceFrom: 1 to: bs with: self startingAt: 1"},{"name":"setDescriptionInMetacelloConfig:","linesOfCode":2,"sourceCode":"setDescriptionInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setDescriptionWithString: self"},{"name":"asRegexIgnoringCase","linesOfCode":8,"sourceCode":"asRegexIgnoringCase\r\t\"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal\r\tor RxParser>>compilationErrorSignal.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^RxParser preferredMatcherClass\r\t\tfor: (RxParser new parse: self)\r\t\tignoreCase: true"},{"name":"endsWithDigit","linesOfCode":6,"sourceCode":"endsWithDigit\r\t\"Answer whether the receiver's final character represents a digit.\"\r\t\"'foo10' endsWithDigit >>> true\"\r\t\"'foo10foo' endsWithDigit >>> false\"\r\t\"'foo1' endsWithDigit >>> true\"\r\t\r\t^ self notEmpty and: [self last isDigit]"},{"name":"linesDo:","linesOfCode":4,"sourceCode":"linesDo: aBlock\r\t\"Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock\"\r\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\taBlock value: (self copyFrom: start to: endWithoutDelimiters)]"},{"name":"join:","linesOfCode":7,"sourceCode":"join: aCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"('*' join: #('WWWWW' 'W  EW' 'zzzz')) >>> 'WWWWW*W  EW*zzzz'\"\r\t\r\t^ self species new: (aCollection size * self size) streamContents: [:stream | \r\t\t\taCollection\r\t\t\t\tdo: [:each | stream nextPutAll: each asString] \r\t\t\t\tseparatedBy: [stream nextPutAll: self]]"},{"name":"isLiteralSymbol","linesOfCode":32,"sourceCode":"isLiteralSymbol\r\t\"Test whether a symbol can be stored as # followed by its characters.  \r\tSymbols created internally with asSymbol may not have this property, \r\te.g. '3' asSymbol.\"\r\r\t| i ascii type next last |\r\tself flag: 'reuse a parser for this'.\r\t\r\ti := self size.\r\ti = 0 ifTrue: [^ false].\r\r\t\"TypeTable should have been origined at 0 rather than 1 ...\"\r\tascii := (self at: 1) asciiValue.\r\ttype := self typeTable at: ascii ifAbsent: [^false].\r\ttype == #xLetter ifTrue: [\r\t\tnext := last := nil.\r\t\t[i > 1]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[ascii := (self at: i) asciiValue.\r\t\t\t\t\ttype := self typeTable at: ascii ifAbsent: [^false].\r\t\t\t\t\t(type == #xLetter or: [type == #xDigit or: [type == #xColon\r\t\t\t\t\t\t\tand: [\r\t\t\t\t\t\t\t\tnext == nil\r\t\t\t\t\t\t\t\t\tifTrue: [last := #xColon. true] \r\t\t\t\t\t\t\t\t\tifFalse: [last == #xColon and: [next ~~ #xDigit and: [next ~~ #xColon]]]]]])\r\t\t\t\t\t\tifFalse: [^ false].\r\t\t\t\t\tnext := type.\r\t\t\t\t\ti := i - 1].\r\t\t\t^ true].\t\r\ttype == #xBinary ifTrue: [^i = 1]. \"Here we could extend to\r\t\t^(2 to: i) allSatisfy: [:j |\r\t\t\tascii := (self at: j) asciiValue.\r\t\t\t(self typeTable at: ascii ifAbsent: []) == #xBinary]\"\r\ttype == #verticalBar ifTrue: [^i = 1].\r\t^false"},{"name":"isString","linesOfCode":2,"sourceCode":"isString\r\t^ true"},{"name":"utf8Encoded","linesOfCode":5,"sourceCode":"utf8Encoded\r\t\"Produce a ByteArray encoding the receiver using UTF-8,\r\tthe recommended encoding for Strings, unless you know what you are doing.\"\r\t\r\t\" 'Les élèves français' utf8Encoded \"\r\t\r\t^ self encodeWith: ZnCharacterEncoder utf8"},{"name":"indexOfSubCollection:startingAt:ifAbsent:","linesOfCode":5,"sourceCode":"indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock\r\t| index |\r\tindex := self findString: sub startingAt: start.\r\tindex = 0 ifTrue: [^ exceptionBlock value].\r\t^ index"},{"name":"padRightTo:","linesOfCode":2,"sourceCode":"padRightTo: length\r\t^ self padRightTo: length with: Character space"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t\"Convert to a ByteArray with the ascii values of the string.\"\r\t\"'a' asByteArray >>> #[97]\"\r\t\"'A' asByteArray >>> #[65]\"\r\t\"'ABA' asByteArray >>> #[65 66 65]\"\r\tself subclassResponsibility "},{"name":"findBetweenSubstrings:","linesOfCode":11,"sourceCode":"findBetweenSubstrings: delimiters\r\t\"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation.\"\r\r\t| tokens keyStart keyStop |\r\ttokens := OrderedCollection new.\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipAnySubstring: delimiters startingAt: keyStop.\r\t\tkeyStop := self findAnySubstring: delimiters startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"indexOfSubCollection:","linesOfCode":6,"sourceCode":"indexOfSubCollection: sub \r\t\"\"\r\r\t^ self\r\t\tindexOfSubCollection: sub\r\t\tstartingAt: 1\r\t\tifAbsent: [0]"},{"name":"lines","linesOfCode":4,"sourceCode":"lines\r    \"Answer an array of lines composing this receiver without the line ending delimiters\"\r    ^Array new: (self size // 60 max: 16)\r            streamContents: [:lines | self linesDo: [:aLine | lines nextPut: aLine]]"},{"name":"setImportInVersionSpec:","linesOfCode":2,"sourceCode":"setImportInVersionSpec: aMetacelloVersionSpec\r  aMetacelloVersionSpec setImport: {self}"},{"name":"packToArity:","linesOfCode":4,"sourceCode":"packToArity: arity\r\t\"WARNING: Here applies the same rules as in ByteArray>>#rollToArity:, check there!\"\r\tarity = 1 ifTrue: [ ^ self ].\r\tself error: 'Use ExternalAddress instead!'"},{"name":"asCStringForGDBInto:","linesOfCode":16,"sourceCode":"asCStringForGDBInto: out\r\t| utf8String |\r\tutf8String := self utf8Encoded.\r\tout nextPut: $\".\r\tutf8String do: [ :char |\r\t\t(\" \" 32 <= char and: [ char <= 126 ]) ifTrue: [\r\t\t\t('\"\\' includes: char asCharacter) ifTrue: [\r\t\t\t\tout nextPut: $\\; nextPut: char asCharacter\r\t\t\t] ifFalse: [ \r\t\t\t\tout nextPut: char asCharacter\r\t\t\t].\r\t\t] ifFalse: [\r\t\t\tout nextPutAll: '\\x'; nextPutAll: (char printStringBase: 16 length: 2 padded: true) asLowercase\r\t\t]\r\t].\r\tout nextPut: $\".\r"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":31,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\"\r\t| index c1 c2 |\r\tmatchTable == nil ifTrue: [\r\t\tkey size = 0 ifTrue: [^ 0].\r\t\tstart to: body size - key size + 1 do:\r\t\t\t[:startIndex |\r\t\t\tindex := 1.\r\t\t\t\t[(body at: startIndex+index-1)\r\t\t\t\t\t= (key at: index)]\r\t\t\t\t\twhileTrue:\r\t\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\t\tindex := index+1]].\r\t\t^ 0\r\t].\r\r\tkey size = 0 ifTrue: [^ 0].\r\tstart to: body size - key size + 1 do:\r\t\t[:startIndex |\r\t\tindex := 1.\r\t\t[c1 := body at: startIndex+index-1.\r\t\tc2 := key at: index.\r\t\t((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) \r\t\t\tifTrue: [ matchTable at: c1 asciiValue + 1 ]\r\t\t\tifFalse: [ c1 asciiValue + 1 ]) = \r\t\t\t((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])\r\t\t\t\tifTrue: [ matchTable at: c2 asciiValue + 1 ]\r\t\t\t\tifFalse: [c2 asciiValue + 1 ]) ]\r\t\t\twhileTrue:\r\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\tindex := index+1]].\r\t^ 0"},{"name":"displayOn:at:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium at: aPoint \r\t\"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text.\"\r\r\tself displayOn: aDisplayMedium at: aPoint textColor: Color black"},{"name":"asEmailHeaderString","linesOfCode":2,"sourceCode":"asEmailHeaderString\r\t^ self"},{"name":"gtDisplayOn:","linesOfCode":2,"sourceCode":"gtDisplayOn: aStream\r\tself printOn: aStream."},{"name":"correctAgainstEnumerator:continuedFrom:","linesOfCode":24,"sourceCode":"correctAgainstEnumerator: wordBlock continuedFrom: oldCollection\r\r\t\"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it.\"\r\r\t| choices results maxChoices scoreMin |\r\r\tscoreMin := self size // 2 min: 3.\r\tmaxChoices := 10.\r\toldCollection\r\t\tifNil: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]\r\t\tifNotNil: [ choices := oldCollection ].\r\twordBlock\r\t\tifNil: [ results := OrderedCollection new.\r\t\t\t1 to: ( maxChoices min: choices size ) do: [ :i | results add: ( choices at: i ) key ]\r\t\t\t]\r\t\tifNotNil: [ wordBlock\r\t\t\t\tvalue: [ :word | \r\t\t\t\t\t| score |\r\r\t\t\t\t\t( score := self alike: word ) >= scoreMin\r\t\t\t\t\t\tifTrue: [ choices add: ( Association key: word value: score ).\r\t\t\t\t\t\t\tchoices size >= maxChoices\r\t\t\t\t\t\t\t\tifTrue: [ scoreMin := ( choices at: maxChoices ) value ]\r\t\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\tresults := choices\r\t\t\t].\r\t^ results"},{"name":"asMIMEType","linesOfCode":2,"sourceCode":"asMIMEType\r\t^ self asZnMimeType"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t\"#hash is implemented, because #= is implemented\"\r\t\"ar 4/10/2005: I had to change this to use ByteString hash as initial \r\thash in order to avoid having to rehash everything and yet compute\r\tthe same hash for ByteString and WideString.\"\r\t^ self class stringHash: self initialHash: ByteString hash"},{"name":"decodeQuotedPrintable","linesOfCode":4,"sourceCode":"decodeQuotedPrintable\r\t\"Assume receiver is in MIME 'quoted-printable' encoding, and decode it.\"\r  \r\t^QuotedPrintableMimeConverter mimeDecode: self as: self class"},{"name":"translated","linesOfCode":3,"sourceCode":"translated\r\"answer the receiver translated to the default language\"\r\t^ NaturalLanguageTranslator translate: self\r"},{"name":"mergeIntoMetacelloRepositories:","linesOfCode":11,"sourceCode":"mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloRepositoriesSpec project repositorySpec)\r\t\t\tdescription: self;\r\t\t\tyourself.\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec mergeMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"slvmUTF16Encoded","linesOfCode":17,"sourceCode":"slvmUTF16Encoded\r\t^ Array streamContents: [ :out |\r\t\tself do: [ :each |\r\t\t\t| codePoint highBits lowBits |\r\t\t\tcodePoint := each asInteger.\r\t\t\tcodePoint <= 16rffff ifTrue: [ \r\t\t\t\tout nextPut: codePoint\r\t\t\t] ifFalse: [\r\t\t\t\t\"https://en.wikipedia.org/wiki/UTF-16\"\r\t\t\t\tcodePoint := codePoint - 16r10000.\r\t\t\t\thighBits := (codePoint >> 10) & 16r3FF.\r\t\t\t\tout nextPut: 16rD800 + highBits.\r\r\t\t\t\tlowBits := codePoint & 16r3FF.\r\t\t\t\tout nextPut: 16rDC00 + lowBits.\r\t\t\t]\r\t\t]\r\t]"},{"name":"padLeftTo:","linesOfCode":2,"sourceCode":"padLeftTo: length\r\t^ self padLeftTo: length with: Character space"},{"name":"copyWithRegex:matchesTranslatedUsing:","linesOfCode":3,"sourceCode":"copyWithRegex: rxString matchesTranslatedUsing: aBlock\r\r\t^rxString asRegex\r\t\tcopy: self translatingMatchesUsing: aBlock"},{"name":"isAllAlphaNumerics","linesOfCode":9,"sourceCode":"isAllAlphaNumerics\r\t\"Returns whether the receiver is composed entirely of alphanumerics (i.e., letters or digits).\"\r\t\"'3.123' isAllAlphaNumerics >>> false\"\r\t\"'a3123abc' isAllAlphaNumerics >>> true\"\r\t\"'3123' isAllAlphaNumerics >>> true\"\r\t\"'3,123' isAllAlphaNumerics >>> false\"\r\t\"'a''b' isAllAlphaNumerics >>> false\"\r\t\r\tself do: [:c | c isAlphaNumeric ifFalse: [^ false]].\r\t^ true"},{"name":"localizedForPresenter:","linesOfCode":3,"sourceCode":"localizedForPresenter: aPresenter\r\r\t\"This message serves for the string modification for the purpose of a given Spec presenter. It may, for example, convert it to a presenter's locale. The implementation here (in the String) serves as fallback for regular strings.\"\r\r\t^ self"},{"name":"asPluralBasedOn:","linesOfCode":6,"sourceCode":"asPluralBasedOn: aNumberOrCollection\r\t\"Append an 's' to this string based on whether aNumberOrCollection is 1 or of size 1.\"\r\r\t^ (aNumberOrCollection = 1 or:\r\t\t[aNumberOrCollection isCollection and: [aNumberOrCollection size = 1]])\r\t\t\tifTrue: [self]\r\t\t\tifFalse: [self, 's']\r"},{"name":"asMetacelloSemanticVersionNumber","linesOfCode":2,"sourceCode":"asMetacelloSemanticVersionNumber\r    ^ MetacelloSemanticVersionNumber fromString: self"},{"name":"asComment","linesOfCode":25,"sourceCode":"asComment\r\t\"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled\"\r\r\t^String streamContents:  [ :str |\r\t\t| quoteCount first |\r\r\t\tstr nextPut: $\".\r\t\r\t\tquoteCount := 0.\r\t\tfirst := true.\r\t\tself do: [ :char |\r\t\t\tchar = $\"\r\t\t\t\tifTrue: [\r\t\t\t\t\tfirst ifFalse: [\r\t\t\t\t\t\tstr nextPut: char.\r\t\t\t\t\t\tquoteCount := quoteCount + 1 ] ]\r\t\t\t\tifFalse: [\r\t\t\t\t\tquoteCount odd ifTrue: [\r\t\t\t\t\t\t\"add a quote to even the number of quotes in a row\"\r\t\t\t\t\t\tstr nextPut: $\" ].\r\t\t\t\t\tquoteCount := 0.\r\t\t\t\t\tstr nextPut: char ].\r\t\t\tfirst := false ]. \r\r\t\tquoteCount odd ifTrue: [\r\t\t\t\"check at the end\"\r\t\t\tstr nextPut: $\". ].\r\r\t\tstr nextPut: $\".\r\t]\r\t"},{"name":"asDate","linesOfCode":3,"sourceCode":"asDate\r\t\"Many allowed forms, see Date>>#readFrom:\"\r\r\t^ Date fromString: self"},{"name":"isAllSeparators","linesOfCode":6,"sourceCode":"isAllSeparators\r\t\"Returns whether the receiver is composed entirely of separators i.e., a space, tab, lf, cr, and newPage\"\r\t\"(Character space asString, Character space asString) isAllSeparators >>> true\"\r\t\"(Character space asString, 'a') isAllSeparators >>> false\"\r\tself do: [ :c | c isSeparator ifFalse: [ ^false ] ].\r\t^true"},{"name":"lastSpacePosition","linesOfCode":10,"sourceCode":"lastSpacePosition\r\t\"Answer the character position of the final space or other separator character in the receiver, and 0 if none\"\r\t\"'fred the bear' lastSpacePosition >>> 9\"\r\t\"'ziggie' lastSpacePosition >>> 0\"\r\t\"'elvis ' lastSpacePosition >>> 6\"\r\t\"'elvis  ' lastSpacePosition >>> 7\"\r\t\"'' lastSpacePosition >>> 0\"\r\r\tself size to: 1 by: -1 do:\r\t\t[:i | ((self at: i) isSeparator) ifTrue: [^ i]].\r\t^ 0\r"},{"name":"translateWith:","linesOfCode":3,"sourceCode":"translateWith: table\r\t\"translate the characters in the string by the given table, in place\"\r\t^ self translateFrom: 1 to: self size table: table"},{"name":"encompassParagraph:","linesOfCode":8,"sourceCode":"encompassParagraph: anInterval\r\t\"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.\r\tAnswer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).\r\tSee also #encompassLine:\"\r\t| left right |\r\tleft := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.\r\tright := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).\r\t^left to: right"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^false"},{"name":"setLoadsInMetacelloProject:","linesOfCode":2,"sourceCode":"setLoadsInMetacelloProject: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setLoads: { self }."},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeString: self"},{"name":"asWDCShaderCode","linesOfCode":2,"sourceCode":"asWDCShaderCode\r\t^ self utf8Encoded"},{"name":"encodeWith:","linesOfCode":5,"sourceCode":"encodeWith: encoding\r\t\"Produce a ByteArray that encodes the receiver, using a specified encoding.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\"\r\t\r\t\" 'Les élèves français' encodeWith: #utf8 \"\r\t\r\t^ encoding asZnCharacterEncoder encodeString: self"},{"name":"asWBTEscapedVarSubstitution","linesOfCode":18,"sourceCode":"asWBTEscapedVarSubstitution\r\tSmalltalk platform isWindows ifTrue: [ \r\t\t^ (self includes: Character space)\r\t\t\tifTrue: [ '\"' , self , '\"' ]\r\t\t\tifFalse: [ self ]\r\t].\r\t(self includesAnyOf: ' \"\\') ifFalse: [ ^ self ].\r\t^ ByteString streamContents: [ :out |\r\t\tout nextPut: $\".\r\t\tself do: [ :each |\r\t\t\t('\"\\' includes: each) ifTrue: [ \r\t\t\t\tout nextPut: $\\.\r\t\t\t].\r\t\t\r\t\t\tout nextPut: each\r\t\t].\r\t\tout nextPut: $\".\r\t].\r"},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstringViaPrimitive: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"String class","instanceVariables":[],"methods":[{"name":"lf","linesOfCode":3,"sourceCode":"lf\r\t\"Answer a string containing a single carriage return character.\"\r\r\t^ self with: Character lf"},{"name":"new:","linesOfCode":5,"sourceCode":"new: sizeRequested\r\t\"Return a new instance with the number of indexable variables specified by the argument.\"\r\r\t^ self == String\r\t\tifTrue: [ ByteString new: sizeRequested ]\r\t\tifFalse: [ self basicNew: sizeRequested ]"},{"name":"findFirstInString:inCharacterSet:startingAt:","linesOfCode":8,"sourceCode":"findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start \r\t\"Trivial, non-primitive version\"\r\t\r\tstart\r\t\tto: aString size\r\t\tdo: [:i | (aCharacterSet\r\t\t\t\t\tincludes: (aString at: i))\r\t\t\t\tifTrue: [^ i]].\r\t^ 0"},{"name":"cr","linesOfCode":3,"sourceCode":"cr\r\t\"Answer a string containing a single carriage return character.\"\r\r\t^ self with: Character cr\r"},{"name":"newTokenish","linesOfCode":4,"sourceCode":"newTokenish\r\t\"a table for testing tokenish (for fast numArgs)\"\r\t^ String withAll: (Character allByteCharacters \r\t\tcollect: [:c | c tokenish ifTrue: [ c ] ifFalse: [ $~ ]])"},{"name":"crlfcrlf","linesOfCode":2,"sourceCode":"crlfcrlf\r\t^self crlf , self crlf.\r"},{"name":"newUppercasingTable","linesOfCode":3,"sourceCode":"newUppercasingTable\r\t\"a table for translating to upper case\"\r\t^ String withAll: (Character allByteCharacters collect: [:c | c asUppercase])"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #stringIcon"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeStringInspector"},{"name":"settingInputWidgetForNode:","linesOfCode":2,"sourceCode":"settingInputWidgetForNode: aSettingNode\r\t^ aSettingNode inputWidgetForString"},{"name":"loremIpsum:","linesOfCode":21,"sourceCode":"loremIpsum: size\r\t\"Return a mostly random multi-paragraph filler string of the specified size.\r\tThe result is pure ASCII, uses CR for newlines and ends with a dot and newline.\"\r\t\r\t\"self loremIpsum: 2048\"\r\t\r\t| words out |\r\twords := (self loremIpsum findTokens: ' ,.') collect: [:each | each asLowercase].\r\t(out := LimitedWriteStream on: (self new: size))\r\t\tlimit: size - 2;\r\t\tlimitBlock: [\r\t\t\t^ out originalContents \r\t\t\t\tat: size - 1 put: $.; \r\t\t\t\tat: size put: Character cr; \r\t\t\t\tyourself ].\r\t[ \r\t\tout << self loremIpsum; cr; cr.\r\t\t5 atRandom timesRepeat: [\r\t\t\t15 atRandom timesRepeat: [\r\t \t\t\tout << words atRandom capitalized.\r\t\t\t\t20 atRandom timesRepeat: [ out space; << words atRandom ].\r\t\t\t\tout nextPut: $.; space ].\r\t\t\tout cr; cr ] ] repeat"},{"name":"expandMacro:argument:withExpansions:","linesOfCode":6,"sourceCode":"expandMacro: macroType argument: argument withExpansions: expansions \r\tmacroType = $s ifTrue: [^expansions at: argument].\r\tmacroType = $p ifTrue: [^(expansions at: argument) printString].\r\tmacroType = $n ifTrue: [^String cr].\r\tmacroType = $t ifTrue: [^String tab].\r\tself error: 'unknown expansion type'"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":4,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\t\r\tstart to: aString size do: [ :index |\r\t\t(aString basicAt: index) = anInteger ifTrue: [ ^index ] ].\r\t^0\r\r"},{"name":"newCaseSensitiveOrder","linesOfCode":15,"sourceCode":"newCaseSensitiveOrder\r\t\"Case-sensitive compare sorts space, digits, letters, all the rest...\"\r\t\r\t| newTab order |\r\tnewTab := ByteArray new: 256 withAll: 255.\r\torder := -1.\r\t' 0123456789' do:  \"0..10\"\r\t\t[:c | newTab at: c asciiValue + 1 put: (order := order+1)].\r\t($a to: $z) do:     \"11-64\"\r\t\t[:c | newTab  at: c asUppercase asciiValue + 1 put: (order := order+1).\r\t\tnewTab  at: c asciiValue + 1 put: (order := order+1)].\r\t1 to: newTab  size do:\r\t\t[:i | (newTab  at: i) = 255 ifTrue:\r\t\t\t[newTab  at: i put: (order := order+1)]].\r\torder = 255 ifFalse: [self error: 'order problem'].\r\t^ newTab "},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":13,"sourceCode":"findFirstInString: aString inSet: inclusionMap startingAt: start\r\t\"Trivial, non-primitive version\"\r\t\r\t| i stringSize ascii more |\r\tinclusionMap size ~= 256 ifTrue: [^ 0].\r\tstringSize := aString size.\r\tmore := true.\r\ti := start - 1.\r\t[more and: [(i := i + 1) <= stringSize]] whileTrue: [\r\t\tascii := (aString basicAt: i).\r\t\tmore := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].\r\t].\r\r\ti > stringSize ifTrue: [^ 0].\r\t^ i"},{"name":"fromString:","linesOfCode":3,"sourceCode":"fromString: aString \r\t\"Answer an instance of me that is a copy of the argument, aString.\"\r\t\r\t^ aString copyFrom: 1 to: aString size"},{"name":"newCSLineEnders","linesOfCode":3,"sourceCode":"newCSLineEnders\r\t\"CR and LF--characters that terminate a line\"\r\t^ CharacterSet crlf"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aString'"},{"name":"fromByteArray:","linesOfCode":2,"sourceCode":"fromByteArray: aByteArray\r\r\t^ aByteArray asString\r"},{"name":"newCaseInsensitiveOrder","linesOfCode":10,"sourceCode":"newCaseInsensitiveOrder\r\t\"map char and char asLower (Lowercase Latin1 stays in the Latin1 range, uppercase not.)\"\r\t| newCollection |\r\tnewCollection := AsciiOrder copy.\r    (0 to: 255) do:[ :v |\r            | char lower |\r            char := v asCharacter.\r            lower := char asLowercase.\r            newCollection at: lower asciiValue + 1 put: (newCollection at: char asciiValue + 1) ].\r\t^ newCollection "},{"name":"readFrom:","linesOfCode":18,"sourceCode":"readFrom: inStream\r\t\"Answer an instance of me that is determined by reading the stream, \r\tinStream. Embedded double quotes become the quote Character.\"\r\r\t| char done |\r\t^ self streamContents: [ :outStream | \r\t\t\"go to first quote\"\r\t\tinStream skipTo: $'.\r\t\tdone := false.\r\t\t[ done or: [ inStream atEnd ] ]\r\t\t\twhileFalse: [ \r\t\t\t\tchar := inStream next.\r\t\t\t\tchar = $'\r\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\tchar := inStream next.\r\t\t\t\t\t\tchar = $'\r\t\t\t\t\t\t\tifTrue: [ outStream nextPut: char ]\r\t\t\t\t\t\t\tifFalse: [ done := true ] ]\r\t\t\t\t\tifFalse: [ outStream nextPut: char ] ] ]"},{"name":"translate:from:to:table:","linesOfCode":7,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t\"Trivial, non-primitive version\"\r\t| char |\r\tstart to: stop do: [:i |\r\t\t(char := aString basicAt: i) < 256 ifTrue: [\r\t\t\taString at: i put: (table at: char+1)].\r\t]\r"},{"name":"newAsciiOrder","linesOfCode":2,"sourceCode":"newAsciiOrder\r\t^ (0 to: 255) as: ByteArray"},{"name":"value:","linesOfCode":2,"sourceCode":"value: anInteger\r\r\t^ self with: (Character value: anInteger)\r"},{"name":"compare:with:collated:","linesOfCode":32,"sourceCode":"compare: string1 with: string2 collated: order\r\t\"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array.\"\r\r\t| len1 len2 c1 c2 |\r\torder\r\t\tifNil: [ len1 := string1 size.\r\t\t\tlen2 := string2 size.\r\t\t\t1 to: (len1 min: len2) do: [ :i | \r\t\t\t\tc1 := string1 basicAt: i.\r\t\t\t\tc2 := string2 basicAt: i.\r\t\t\t\tc1 = c2\r\t\t\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\t\t\tifFalse: [ 3 ] ] ].\r\t\t\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t\t\t^ len1 < len2\r\t\t\t\tifTrue: [ 1 ]\r\t\t\t\tifFalse: [ 3 ] ].\r\tlen1 := string1 size.\r\tlen2 := string2 size.\r\t1 to: (len1 min: len2) do: [ :i | \r\t\tc1 := string1 basicAt: i.\r\t\tc2 := string2 basicAt: i.\r\t\tc1 < 256 ifTrue: [ c1 := order at: c1 + 1 ].\r\t\tc2 < 256 ifTrue: [ c2 := order at: c2 + 1 ].\r\t\tc1 = c2\r\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\tifFalse: [ 3 ] ] ].\r\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t^ len1 < len2\r\t\tifTrue: [ 1 ]\r\t\tifFalse: [ 3 ]"},{"name":"initialize","linesOfCode":12,"sourceCode":"initialize   \r\t\r\tself initializeTypeTable.\r\t\r\tAsciiOrder := self newAsciiOrder.\r\tCaseInsensitiveOrder := self newCaseInsensitiveOrder.\r\tCaseSensitiveOrder := self newCaseSensitiveOrder.\r\tLowercasingTable := self newLowercasingTable.\r\tUppercasingTable := self newUppercasingTable.\r\tTokenish := self newTokenish.\r\tCSLineEnders := self newCSLineEnders.\r\r \t\"separators and non-separators\"\r\tCSSeparators := CharacterSet separators.\r\tCSNonSeparators := CSSeparators complement."},{"name":"newLowercasingTable","linesOfCode":3,"sourceCode":"newLowercasingTable\r\t\"a table for translating to lower case\"\r\t^ String withAll: (Character allByteCharacters collect: [:c | c asLowercase])"},{"name":"tab","linesOfCode":3,"sourceCode":"tab\r\t\"Answer a string containing a single tab character.\"\r\r\t^ self with: Character tab\r"},{"name":"with:","linesOfCode":7,"sourceCode":"with: aCharacter\r\t| newCollection |\r\tnewCollection := aCharacter asInteger < 256\r\t\tifTrue:[ ByteString new: 1]\r\t\tifFalse:[ WideString new: 1].\r\tnewCollection at: 1 put: aCharacter.\r\t^newCollection"},{"name":"initializeTypeTable","linesOfCode":27,"sourceCode":"initializeTypeTable\r\r\t| newTable |\r\tnewTable := Array new: 256 withAll: #xBinary. \"default\"\r\tnewTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. \"tab lf ff cr space\"\r\tnewTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.\r\r\t1 to: 255\r\t\tdo: [:index |\r\t\t\t(Character value: index) isLetter\r\t\t\t\tifTrue: [newTable at: index put: #xLetter]].\r\r\tnewTable at: 30 put: #doIt.\r\tnewTable at: $\" asciiValue put: #xDoubleQuote.\r\tnewTable at: $# asciiValue put: #xLitQuote.\r\tnewTable at: $$ asciiValue put: #xDollar.\r\tnewTable at: $' asciiValue put: #xSingleQuote.\r\tnewTable at: $: asciiValue put: #xColon.\r\tnewTable at: $( asciiValue put: #leftParenthesis.\r\tnewTable at: $) asciiValue put: #rightParenthesis.\r\tnewTable at: $. asciiValue put: #period.\r\tnewTable at: $; asciiValue put: #semicolon.\r\tnewTable at: $[ asciiValue put: #leftBracket.\r\tnewTable at: $] asciiValue put: #rightBracket.\r\tnewTable at: ${ asciiValue put: #leftBrace.\r\tnewTable at: $} asciiValue put: #rightBrace.\r\tnewTable at: $^ asciiValue put: #upArrow.\r\tnewTable at: $_ asciiValue put: #xLetter. \"by default, do not accept _ as assignement\"\r\tnewTable at: $| asciiValue put: #verticalBar.\r\tTypeTable := newTable\r"},{"name":"stringHash:initialHash:","linesOfCode":11,"sourceCode":"stringHash: aString initialHash: speciesHash\r\t| stringSize hash low |\r\tstringSize := aString size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: stringSize do: [:pos |\r\t\thash := hash + (aString basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash // 16384) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash\r"},{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator \r\t^ generator resolveType: #FFIExternalString"},{"name":"space","linesOfCode":3,"sourceCode":"space\r\t\"Answer a string containing a single space character.\"\r\r\t^ self with: Character space\r"},{"name":"loremIpsum","linesOfCode":4,"sourceCode":"loremIpsum\r\t\"Return a constant string with one paragraph of text, the famous Lorem ipsum filler text.\r\tThe result is pure ASCII (Latin words) and contains no newlines.\"\r\t\r\t^ 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'"},{"name":"crlf","linesOfCode":3,"sourceCode":"crlf\r\t\"Answer a string containing a carriage return and a linefeed.\"\r\r\t^ self with: Character cr with: Character lf\r"},{"name":"typeTable","linesOfCode":3,"sourceCode":"typeTable\r\tTypeTable ifNil: [self initializeTypeTable].\r\t^ TypeTable"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\t\"A canonicalized empty String instance.\"\r\t^ ''"}],"meta":null}},{"name":"DoubleByteArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 2"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"bytesPerElement","linesOfCode":3,"sourceCode":"bytesPerElement\r\t\"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored.\"\r\t^ 2"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"DoubleByteArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"DoubleWordArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 8"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"bytesPerElement","linesOfCode":3,"sourceCode":"bytesPerElement\r\t\"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored.\"\r\t^ 8"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"DoubleWordArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FloatArray","instanceVariables":[],"methods":[{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0.0"},{"name":"primSubScalar:","linesOfCode":3,"sourceCode":"primSubScalar: scalarValue\r\r\t<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue]."},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^self"},{"name":"*","linesOfCode":2,"sourceCode":"* anObject\r\t^self copy *= anObject"},{"name":"/=","linesOfCode":4,"sourceCode":"/= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primDivScalar: anObject asFloat]\r\t\tifFalse:[self primDivArray: anObject]"},{"name":"=","linesOfCode":9,"sourceCode":"= aFloatArray \r\t| length |\r\t<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>\r\taFloatArray class = self class ifFalse: [^ false].\r\tlength := self size.\r\tlength = aFloatArray size ifFalse: [^ false].\r\t1 to: self size do: [:i | (self at: i)\r\t\t\t= (aFloatArray at: i) ifFalse: [^ false]].\r\t^ true"},{"name":"primAddScalar:","linesOfCode":3,"sourceCode":"primAddScalar: scalarValue\r\r\t<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue]."},{"name":"-","linesOfCode":2,"sourceCode":"- anObject\r\t^self shallowCopy -= anObject"},{"name":"primMulArray:","linesOfCode":3,"sourceCode":"primMulArray: floatArray\r\r\t<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)]."},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":2,"sourceCode":"/ anObject\r\t^self copy /= anObject"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t| result |\r\t<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>\r\tresult := 0.\r\t1 to: self size do:[:i| result := result + (self basicAt: i) ].\r\t^result bitAnd: 16r1FFFFFFF"},{"name":"+=","linesOfCode":2,"sourceCode":"+= anObject\r\t^ anObject addAssignToFloatArray: self"},{"name":"primDivArray:","linesOfCode":3,"sourceCode":"primDivArray: floatArray\r\r\t<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)]."},{"name":"primMulScalar:","linesOfCode":3,"sourceCode":"primMulScalar: scalarValue\r\r\t<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue]."},{"name":"primDivScalar:","linesOfCode":3,"sourceCode":"primDivScalar: scalarValue\r\r\t<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue]."},{"name":"primSubArray:","linesOfCode":3,"sourceCode":"primSubArray: floatArray\r\r\t<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)]."},{"name":"sum","linesOfCode":3,"sourceCode":"sum\r\r\t<primitive: 'primitiveSum' module: 'FloatArrayPlugin'>\r\t^ super sum"},{"name":"\\\\=","linesOfCode":10,"sourceCode":"\\\\= other\r\r\tother isNumber ifTrue: [\r\t\t1 to: self size do: [:i |\r\t\t\tself at: i put: (self at: i) \\\\ other\r\t\t].\r\t\t^ self.\r\t].\r\t1 to: (self size min: other size) do: [:i |\r\t\tself at: i put: (self at: i) \\\\ (other at: i).\r\t].\r\r"},{"name":"adaptToNumber:andSend:","linesOfCode":14,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Number. If possible,\r\tconvert it to a float and perform the (more efficient) primitive operation.\"\r\tselector == #+ ifTrue:[^self + rcvr].\r\tselector == #* ifTrue:[^self * rcvr].\r\tselector == #- ifTrue:[^self negated += rcvr].\r\tselector == #/ ifTrue:[\r\t\t\"DO NOT USE TRIVIAL CODE\r\t\t\t^self reciprocal * rcvr\r\t\tBECAUSE OF GRADUAL UNDERFLOW\r\t\tself should: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2.\"\r\t\t\t^(self class new: self size withAll: rcvr) / self\r\t\t].\r\t^super adaptToNumber: rcvr andSend: selector"},{"name":"+","linesOfCode":2,"sourceCode":"+ anObject\r\t^self copy += anObject"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"primAddArray:","linesOfCode":3,"sourceCode":"primAddArray: floatArray\r\r\t<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)]."},{"name":"addAssignToFloatArray:","linesOfCode":2,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t^ self primAddArray: aFloatArray"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\t<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>\r\t^Float fromIEEE32Bit: (self basicAt: index)"},{"name":"dot:","linesOfCode":10,"sourceCode":"dot: aFloatVector\r\t\"Primitive. Return the dot product of the receiver and the argument.\r\tFail if the argument is not of the same size as the receiver.\"\r       | result |\r\t<primitive: 'primitiveDotProduct' module: 'FloatArrayPlugin'>\r\tself size = aFloatVector size ifFalse:[^self error:'Must be equal size'].\r\tresult := 0.0.\r\t1 to: self size do:[:i|\r\t\tresult := result + ((self at: i) * (aFloatVector at: i))].\r\t^result"},{"name":"negated","linesOfCode":2,"sourceCode":"negated\r\t^self copy *= -1"},{"name":"*=","linesOfCode":4,"sourceCode":"*= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primMulScalar: anObject asFloat]\r\t\tifFalse:[self primMulArray: anObject]"},{"name":"-=","linesOfCode":4,"sourceCode":"-= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primSubScalar: anObject asFloat]\r\t\tifFalse:[self primSubArray: anObject]"},{"name":"at:put:","linesOfCode":6,"sourceCode":"at: index put: value\r\t<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>\r\tvalue isFloat \r\t\tifTrue:[self basicAt: index put: value asIEEE32BitWord]\r\t\tifFalse:[self at: index put: value asFloat].\r\t^value"}],"meta":{"name":"FloatArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IntegerArray","instanceVariables":[],"methods":[{"name":"at:","linesOfCode":9,"sourceCode":"at: index\r\t| word |\r\t<primitive: 165>\r\tword := self basicAt: index.\r\tword < 16r3FFFFFFF ifTrue:[^word]. \"Avoid LargeInteger computations\"\r\t^word >= 16r80000000\t\"Negative?!\"\r\t\tifTrue:[\"word - 16r100000000\"\r\t\t\t\t(word bitInvert32 + 1) negated]\r\t\tifFalse:[word]"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"asIntegerArray","linesOfCode":2,"sourceCode":"asIntegerArray\r\t^self"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"primFill:","linesOfCode":4,"sourceCode":"primFill: aPositiveInteger\r\t\"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays.\"\r\r\t<primitive: 145>\r\tself errorImproperStore."},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: index put: anInteger\r\t| word |\r\t<primitive: 166>\r\tanInteger < 0\r\t\tifTrue:[\"word := 16r100000000 + anInteger\"\r\t\t\t\tword := (anInteger + 1) negated bitInvert32]\r\t\tifFalse:[word := anInteger].\r\tself  basicAt: index put: word.\r\t^anInteger"},{"name":"atAllPut:","linesOfCode":7,"sourceCode":"atAllPut: anInteger\r\t| word |\r\tanInteger < 0\r\t\tifTrue:[\"word := 16r100000000 + anInteger\"\r\t\t\t\tword := (anInteger + 1) negated bitInvert32]\r\t\tifFalse:[word := anInteger].\r\tself primFill: word."}],"meta":{"name":"IntegerArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SparseLargeTable","instanceVariables":[{"name":"base"},{"name":"size"},{"name":"chunkSize"},{"name":"defaultValue"}],"methods":[{"name":"noCheckAt:","linesOfCode":7,"sourceCode":"noCheckAt: index\r\t| chunkIndex t |\r\r\tchunkIndex := index - base // chunkSize + 1.\r\t(chunkIndex > self basicSize or: [chunkIndex < 1]) ifTrue: [^ defaultValue].\r\tt := self basicAt: chunkIndex.\r\tt ifNil: [^ defaultValue].\r\t^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))\r"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\t| element |\r\taStream nextPut: $(.\r\tbase to: size do: [:index | element := self at: index. aStream print: element; space].\r\tself isEmpty ifFalse: [aStream skip: -1].\r\taStream nextPut: $)\r"},{"name":"arrayClass","linesOfCode":2,"sourceCode":"arrayClass\r\r\t^(self basicAt: 1) class\r"},{"name":"chunkSize","linesOfCode":2,"sourceCode":"chunkSize\r\r\t^chunkSize\r"},{"name":"allDefaultValueSubtableAt:","linesOfCode":8,"sourceCode":"allDefaultValueSubtableAt: index\r\r\t| t |\r\tt := self basicAt: index.\r\tt ifNil: [^ true].\r\tt do: [:e |\r\t\te ~= defaultValue ifTrue: [^ false].\r\t].\r\t^ true.\r"},{"name":"base","linesOfCode":2,"sourceCode":"base\r\r\t^ base.\r"},{"name":"noCheckAt:put:","linesOfCode":7,"sourceCode":"noCheckAt: index put: value\r\r\t| chunkIndex t |\r\tchunkIndex := index - base // chunkSize + 1.\r\tchunkIndex > self basicSize ifTrue: [^ value].\r\tt :=  self basicAt: chunkIndex.\r\tt ifNil: [^ value].\r\t^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize)) put: value\r"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\t1 to: self basicSize do: [:i | self basicAt: i put: (self basicAt: i) copy]"},{"name":"similarInstance:","linesOfCode":5,"sourceCode":"similarInstance: newSize\r\r\t^self class\r\t\tnew: newSize \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"privateSize:","linesOfCode":2,"sourceCode":"privateSize: s\r\r\tsize := s.\r"},{"name":"speciesNew","linesOfCode":5,"sourceCode":"speciesNew\r\r\t^self species\r\t\tnew: self size \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver that contains no elements.\"\r\t^self speciesNew: 0\r"},{"name":"similarSpeciesInstance","linesOfCode":2,"sourceCode":"similarSpeciesInstance\r\r\t^self similarInstance\r"},{"name":"speciesNew:","linesOfCode":5,"sourceCode":"speciesNew: newSize\r\r\t^self species\r\t\tnew: newSize \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"similarSpeciesInstance:","linesOfCode":2,"sourceCode":"similarSpeciesInstance: newSize\r\r\t^self similarInstance: newSize\r"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\r\t^size\r"},{"name":"analyzeSpaceSaving","linesOfCode":18,"sourceCode":"analyzeSpaceSaving\r\r\t| total elems tablesTotal nonNilTables |\r\ttotal := size - base + 1.\r\telems := 0.\r\tbase to: size do: [:i | (self at: i) ~= defaultValue ifTrue: [elems := elems + 1]].\r\ttablesTotal := self basicSize.\r\tnonNilTables := 0.\r\t1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [nonNilTables := nonNilTables + 1]].\r\r\t^ String streamContents: [:strm |\r\t\tstrm nextPutAll: 'total: '.\r\t\tstrm nextPutAll: total printString.\r\t\tstrm nextPutAll: ' elements: '.\r\t\tstrm nextPutAll: elems printString.\r\t\tstrm nextPutAll: ' tables: '.\r\t\tstrm nextPutAll: tablesTotal printString.\r\t\tstrm nextPutAll: ' non-nil: '.\r\t\tstrm nextPutAll: nonNilTables printString.\r\t].\r\r"},{"name":"initChunkSize:size:arrayClass:base:defaultValue:","linesOfCode":12,"sourceCode":"initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d\r\r\t| lastChunkSize |\r\tchunkSize := aChunkSize.\r\tsize := aSize.\r\tbase := b.\r\tdefaultValue := d.\r\t1 to: (self basicSize - 1) do: [ :in | self basicAt: in put: (aClass new: chunkSize withAll: defaultValue) ].\r\tlastChunkSize := size \\\\ chunkSize.\r\tlastChunkSize = 0 ifTrue: [lastChunkSize := chunkSize].\r\tsize = 0 \r\t\tifTrue: [self basicAt: 1 put: (aClass new: 0)]\r\t\tifFalse: [self basicAt: self basicSize put: (aClass new: lastChunkSize withAll: defaultValue)].\r"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\r\t(#(String) includes: self arrayClass name) \r\t\tifTrue: [^self storeOn: aStream].\r\t^super printOn: aStream\r"},{"name":"zapDefaultOnlyEntries","linesOfCode":4,"sourceCode":"zapDefaultOnlyEntries\r\r\t1 to: self basicSize do: [:i |\r\t\t(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].\r\t].\r"},{"name":"similarInstance","linesOfCode":5,"sourceCode":"similarInstance\r\r\t^self class\r\t\tnew: self size \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\r\tself pvtCheckIndex: index.\r\t^self noCheckAt: index.\r"},{"name":"storeOn:","linesOfCode":12,"sourceCode":"storeOn: aStream\r\r\t| x |\r\t(#(String) includes: self arrayClass name) ifTrue: \r\t\t[aStream nextPut: $'.\r\t\t1 to: self size do:\r\t\t\t[:i |\r\t\t\taStream nextPut: (x := self at: i).\r\t\t\tx == $' ifTrue: [aStream nextPut: x]].\r\t\taStream nextPutAll: ''' asLargeArrayChunkSize: '.\r\t\taStream nextPutAll: self chunkSize asString.\r\t\t^self].\r\t^super storeOn: aStream\r"},{"name":"pvtCheckIndex:","linesOfCode":4,"sourceCode":"pvtCheckIndex: index \r\r\tindex isInteger ifFalse: [self errorNonIntegerIndex].\r\tindex < 1 ifTrue: [self errorSubscriptBounds: index].\r\tindex > size ifTrue: [self errorSubscriptBounds: index].\r"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: index put: value\r\t\r\tself pvtCheckIndex: index.\r\t^self noCheckAt: index put: value\r"}],"meta":{"name":"SparseLargeTable class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: size\r\r\t^self new: size chunkSize: self defaultChunkSize\r"},{"name":"new:chunkSize:arrayClass:base:defaultValue:","linesOfCode":7,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass base: b defaultValue: d\r\r\t| basicSize |\r\t(basicSize := ((size - 1) // chunkSize) + 1) = 0\r\t\tifTrue: [basicSize := 1].\r\t^(self basicNew: basicSize)\r\t\tinitChunkSize: chunkSize size: size arrayClass: aClass base: b defaultValue: d;\r\t\tyourself\r"},{"name":"new:chunkSize:arrayClass:base:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass base: b\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array base: 1 defaultValue: nil.\r"},{"name":"new:chunkSize:arrayClass:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array base: 1.\r"},{"name":"new:chunkSize:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array\r"},{"name":"defaultChunkSize","linesOfCode":2,"sourceCode":"defaultChunkSize\r\r\t^100"},{"name":"defaultChunkSizeForFiles","linesOfCode":2,"sourceCode":"defaultChunkSizeForFiles\r\r\t^8000"}],"meta":null}},{"name":"WordArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 4"},{"name":"primDivScalar:and:into:","linesOfCode":7,"sourceCode":"primDivScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / other.\r\t].\r\t^ result.\r"},{"name":"primSubArray:and:into:","linesOfCode":7,"sourceCode":"primSubArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - (other at: i)\r\t].\r\t^ result.\r"},{"name":"asWordArray","linesOfCode":2,"sourceCode":"asWordArray\r\t^self"},{"name":"+","linesOfCode":14,"sourceCode":"+ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primAddScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t^ super + other"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":3,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t<primitive: 105>\r\t^super replaceFrom: start to: stop with: replacement startingAt: repStart "},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"primSubScalar:and:into:","linesOfCode":7,"sourceCode":"primSubScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - other.\r\t].\r\t^ result.\r"},{"name":"*","linesOfCode":14,"sourceCode":"* other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primMulScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t^ super * other"},{"name":"primAddArray:and:into:","linesOfCode":7,"sourceCode":"primAddArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + (other at: i)\r\t].\r\t^ result.\r"},{"name":"primAddScalar:and:into:","linesOfCode":7,"sourceCode":"primAddScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + other.\r\t].\r\t^ result.\r"},{"name":"-","linesOfCode":14,"sourceCode":"- other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primSubScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t^ super - other"},{"name":"primMulArray:and:into:","linesOfCode":7,"sourceCode":"primMulArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * (other at: i)\r\t].\r\t^ result.\r"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":14,"sourceCode":"/ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primDivScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t^ super / other"},{"name":"primDivArray:and:into:","linesOfCode":7,"sourceCode":"primDivArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / (other at: i)\r\t].\r\t^ result.\r"},{"name":"primMulScalar:and:into:","linesOfCode":7,"sourceCode":"primMulScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * other.\r\t].\r\t^ result.\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"WordArray class","instanceVariables":[],"methods":[{"name":"newFromStream:","linesOfCode":10,"sourceCode":"newFromStream: s\r\t\"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk.\"\r\t| len |\r\r\ts next = 16r80 ifTrue:\r\t\t[\"A compressed format.  Could copy what BitMap does, or use a \r\t\tspecial sound compression format.  Callers normally compress their own way.\"\r\t\t^ self error: 'not implemented'].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ s nextWordsInto: (self basicNew: len)"}],"meta":null}},{"name":"ColorArray","instanceVariables":[],"methods":[{"name":"asColorArray","linesOfCode":2,"sourceCode":"asColorArray\r\t^self"},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\t^(super at: index) asColorOfDepth: 32"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: aColor\r\t^super at: index put: (aColor pixelWordForDepth: 32)."}],"meta":{"name":"ColorArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Bitmap","instanceVariables":[],"methods":[{"name":"isColormap","linesOfCode":4,"sourceCode":"isColormap\r\t\"Bitmaps were used as color maps for BitBlt.\r\tThis method allows to recognize real color maps.\"\r\t^false"},{"name":"asByteArray","linesOfCode":21,"sourceCode":"asByteArray\r\t\"Faster way to make a byte array from me.\r\tcopyFromByteArray: makes equal Bitmap.\"\r\t| f bytes hack |\r\tf := Form \r\t\textent: 4 @ self size\r\t\tdepth: 8\r\t\tbits: self.\r\tbytes := ByteArray new: self size * 4.\r\thack := Form new hackBits: bytes.\r\tEndianDetector isLittleEndian ifTrue: [ hack swapEndianness ].\r\thack \r\t\tcopyBits: f boundingBox\r\t\tfrom: f\r\t\tat: 0 @ 0\r\t\tclippingBox: hack boundingBox\r\t\trule: Form over\r\t\tfillColor: nil\r\t\tmap: nil.\r\r\t\"f displayOn: hack.\"\r\t^ bytes"},{"name":"compressToByteArray","linesOfCode":16,"sourceCode":"compressToByteArray\r\t\"Return a run-coded compression of this bitmap into a byteArray\"\r\t\"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...\r\tN >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)\r\tN > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)\r\tN > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.\r\rThe worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3).\"\r\t\"NOTE: This code is copied in Form hibernate for reasons given there.\"\r\t| byteArray lastByte |\r\tbyteArray := ByteArray new: self size * 4 + 7 + (self size // 1984 * 3).\r\tlastByte := self \r\t\tcompress: self\r\t\ttoByteArray: byteArray.\r\t^ byteArray \r\t\tcopyFrom: 1\r\t\tto: lastByte"},{"name":"decompress:fromByteArray:at:","linesOfCode":51,"sourceCode":"decompress: bm fromByteArray: ba at: index\r\t\"Decompress the body of a byteArray encoded by compressToByteArray (qv)...\r\tThe format is simply a sequence of run-coded pairs, {N D}*.\r\t\tN is a run-length * 4 + data code.\r\t\tD, the data, depends on the data code...\r\t\t\t0\tskip N words, D is absent\r\t\t\t\t(could be used to skip from one raster line to the next)\r\t\t\t1\tN words with all 4 bytes = D (1 byte)\r\t\t\t2\tN words all = D (4 bytes)\r\t\t\t3\tN words follow in D (4N bytes)\r\t\tS and N are encoded as follows (see decodeIntFrom:)...\r\t\t\t0-223\t0-223\r\t\t\t224-254\t(0-30)*256 + next byte (0-7935)\r\t\t\t255\t\tnext 4 bytes\"\t\r\t\"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm.\"\r\t| i code n anInt data end k pastEnd |\r\t<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>\r\t<var: #bm type: 'int *'>\r\t<var: #ba type: 'unsigned char *'>\r\t<var: #anInt type: 'unsigned int'> \"Force the type, otherwise it is inferred as unsigned char because assigned from ba\"\r\t<var: #data type: 'unsigned int'>\r\ti := index.  \"byteArray read index\"\r\tend := ba size.\r\tk := 1.  \"bitmap write index\"\r\tpastEnd := bm size + 1.\r\t[i <= end] whileTrue:\r\t\t[\"Decode next run start N\"\r\t\tanInt := ba at: i.  i := i+1.\r\t\tanInt <= 223 ifFalse:\r\t\t\t[anInt <= 254\r\t\t\t\tifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]\r\t\t\t\tifFalse: [anInt := 0.\r\t\t\t\t\t\t1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].\r\t\tn := anInt >> 2.\r\t\t(k + n) > pastEnd ifTrue: [^ self primitiveFail].\r\t\tcode := anInt bitAnd: 3.\r\t\tcode = 0 ifTrue: [\"skip\"].\r\t\tcode = 1 ifTrue: [\"n consecutive words of 4 bytes = the following byte\"\r\t\t\t\t\t\tdata := ba at: i.  i := i+1.\r\t\t\t\t\t\tdata := data bitOr: (data bitShift: 8).\r\t\t\t\t\t\tdata := data bitOr: (data bitShift: 16).\r\t\t\t\t\t\t1 to: n do: [:j | bm at: k put: data.  k := k+1]].\r\t\tcode = 2 ifTrue: [\"n consecutive words = 4 following bytes\"\r\t\t\t\t\t\tdata := 0.\r\t\t\t\t\t\t1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].\r\t\t\t\t\t\t1 to: n do: [:j | bm at: k put: data.  k := k+1]].\r\t\tcode = 3 ifTrue: [\"n consecutive words from the data...\"\r\t\t\t\t\t\t1 to: n do:\r\t\t\t\t\t\t\t[:m | data := 0.\r\t\t\t\t\t\t\t1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].\r\t\t\t\t\t\t\tbm at: k put: data.  k := k+1]]]"},{"name":"encodeInt:in:at:","linesOfCode":12,"sourceCode":"encodeInt: anInt in: ba at: i\r\t\"Encode the integer anInt in byteArray ba at index i, and return the next index.\r\tThe encoding is as follows...\r\t\t0-223\t0-223\r\t\t224-254\t(0-30)*256 + next byte (0-7935)\r\t\t255\t\tnext 4 bytes\"\t\t\r\r\t<inline: true>\r\t<var: #ba declareC: 'unsigned char *ba'>\r\t\r\tanInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].\r\tanInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\\\256.  ^ i+2].\r\tba at: i put: 255.\r\t^ self encodeBytesOf: anInt in: ba at: i+1"},{"name":"encodeInt:","linesOfCode":11,"sourceCode":"encodeInt: int \r\t\"Encode the integer int as per encodeInt:in:at:, and return it as a ByteArray\"\r\t| byteArray next |\r\tbyteArray := ByteArray new: 5.\r\tnext := self \r\t\tencodeInt: int\r\t\tin: byteArray\r\t\tat: 1.\r\t^ byteArray \r\t\tcopyFrom: 1\r\t\tto: next - 1"},{"name":"fromByteStream:","linesOfCode":4,"sourceCode":"fromByteStream: aStream \r\t\"Initialize the array of bits by reading integers from the argument, \r\taStream.\"\r\taStream nextWordsInto: self"},{"name":"encodeBytesOf:in:at:","linesOfCode":7,"sourceCode":"encodeBytesOf: anInt in: ba at: i\r\t\"Copy the integer anInt into byteArray ba at index i, and return the next index\"\r\r\t<inline: true>\r\t<var: #ba declareC: 'unsigned char *ba'>\r\t\r\t0 to: 3 do:\r\t\t[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].\r\t^ i+4"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"integerAt:","linesOfCode":12,"sourceCode":"integerAt: index \r\t\"Return the integer at the given index\"\r\t| word |\r\t<primitive: 165>\r\tword := self basicAt: index.\r\tword < 1073741823 ifTrue: [ ^ word ].\t\"Avoid LargeInteger computations\"\r\t^ word >= 2147483648 \r\t\tifTrue: \r\t\t\t[ \"Negative?!\"\r\t\t\t\"word - 16r100000000\"\r\t\t\t(word bitInvert32 + 1) negated ]\r\t\tifFalse: [ word ]"},{"name":"readCompressedFrom:","linesOfCode":32,"sourceCode":"readCompressedFrom: strm \r\t\"Decompress an old-style run-coded stream into this bitmap:\r\t\t[0 means end of runs]\r\t\t[n = 1..127] [(n+3) copies of next byte]\r\t\t[n = 128..191] [(n-127) next bytes as is]\r\t\t[n = 192..255] [(n-190) copies of next 4 bytes]\"\r\t| n byte out outBuff bytes |\r\tout := (outBuff := ByteArray new: self size * 4) writeStream.\r\t[ (n := strm next) > 0 ] whileTrue: \r\t\t[ (n \r\t\t\tbetween: 1\r\t\t\tand: 127) ifTrue: \r\t\t\t[ byte := strm next.\r\t\t\t1 \r\t\t\t\tto: n + 3\r\t\t\t\tdo: [ :i | out nextPut: byte ] ].\r\t\t(n \r\t\t\tbetween: 128\r\t\t\tand: 191) ifTrue: \r\t\t\t[ 1 \r\t\t\t\tto: n - 127\r\t\t\t\tdo: [ :i | out nextPut: strm next ] ].\r\t\t(n \r\t\t\tbetween: 192\r\t\t\tand: 255) ifTrue: \r\t\t\t[ bytes := (1 to: 4) collect: [ :i | strm next ].\r\t\t\t1 \r\t\t\t\tto: n - 190\r\t\t\t\tdo: [ :i | bytes do: [ :b | out nextPut: b ] ] ] ].\r\tout position = outBuff size ifFalse: [ self error: 'Decompression size error' ].\r\t\"Copy the final byteArray into self\"\r\tself copyFromByteArray: outBuff"},{"name":"copyFromByteArray:","linesOfCode":7,"sourceCode":"copyFromByteArray: byteArray \r\t\"This method should work with either byte orderings\"\r\r\t| myHack byteHack |\r\tmyHack := Form new hackBits: self.\r\tbyteHack := Form new hackBits: byteArray.\r\tEndianDetector isLittleEndian ifTrue: [byteHack swapEndianness].\r\tbyteHack displayOn: myHack"},{"name":"compress:toByteArray:","linesOfCode":90,"sourceCode":"compress: bm toByteArray: ba\r\t\"Store a run-coded compression of the receiver into the byteArray ba,\r\tand return the last index stored into. ba is assumed to be large enough.\r\tThe encoding is as follows...\r\t\tS {N D}*.\r\t\tS is the size of the original bitmap, followed by run-coded pairs.\r\t\tN is a run-length * 4 + data code.\r\t\tD, the data, depends on the data code...\r\t\t\t0\tskip N words, D is absent\r\t\t\t1\tN words with all 4 bytes = D (1 byte)\r\t\t\t2\tN words all = D (4 bytes)\r\t\t\t3\tN words follow in D (4N bytes)\r\t\tS and N are encoded as follows...\r\t\t\t0-223\t0-223\r\t\t\t224-254\t(0-30)*256 + next byte (0-7935)\r\t\t\t255\t\tnext 4 bytes\"\r\t| size k word j lowByte eqBytes i |\r\t<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>\r\t\r\t<var: #bm declareC: 'int *bm'>\r\t<var: #ba declareC: 'unsigned char *ba'>\r\t\r\tsize := bm size.\r\ti := self \r\t\tencodeInt: size\r\t\tin: ba\r\t\tat: 1.\r\tk := 1.\r\t[ k <= size ] whileTrue: \r\t\t[ word := bm at: k.\r\t\tlowByte := word bitAnd: 255.\r\t\teqBytes := (word >> 8 bitAnd: 255) = lowByte and: \r\t\t\t[ (word >> 16 bitAnd: 255) = lowByte and: [ (word >> 24 bitAnd: 255) = lowByte ] ].\r\t\tj := k.\r\t\t[ j < size and: [ word = (bm at: j + 1) ]\t\"scan for = words...\" ] whileTrue: [ j := j + 1 ].\r\t\tj > k \r\t\t\tifTrue: \r\t\t\t\t[ \"We have two or more = words, ending at j\"\r\t\t\t\teqBytes \r\t\t\t\t\tifTrue: \r\t\t\t\t\t\t[ \"Actually words of = bytes\"\r\t\t\t\t\t\ti := self \r\t\t\t\t\t\t\tencodeInt: (j - k + 1) * 4 + 1\r\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\tat: i.\r\t\t\t\t\t\tba \r\t\t\t\t\t\t\tat: i\r\t\t\t\t\t\t\tput: lowByte.\r\t\t\t\t\t\ti := i + 1 ]\r\t\t\t\t\tifFalse: \r\t\t\t\t\t\t[ i := self \r\t\t\t\t\t\t\tencodeInt: (j - k + 1) * 4 + 2\r\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\tat: i.\r\t\t\t\t\t\ti := self \r\t\t\t\t\t\t\tencodeBytesOf: word\r\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\tat: i ].\r\t\t\t\tk := j + 1 ]\r\t\t\tifFalse: \r\t\t\t\t[ \"Check for word of 4 = bytes\"\r\t\t\t\teqBytes \r\t\t\t\t\tifTrue: \r\t\t\t\t\t\t[ \"Note 1 word of 4 = bytes\"\r\t\t\t\t\t\ti := self \r\t\t\t\t\t\t\tencodeInt: 1 * 4 + 1\r\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\tat: i.\r\t\t\t\t\t\tba \r\t\t\t\t\t\t\tat: i\r\t\t\t\t\t\t\tput: lowByte.\r\t\t\t\t\t\ti := i + 1.\r\t\t\t\t\t\tk := k + 1 ]\r\t\t\t\t\tifFalse: \r\t\t\t\t\t\t[ \"Finally, check for junk\"\r\t\t\t\t\t\t[ j < size and: [ (bm at: j) ~= (bm at: j + 1) ]\t\"scan for ~= words...\" ] whileTrue: [ j := j + 1 ].\r\t\t\t\t\t\tj = size ifTrue: [ j := j + 1 ].\r\t\t\t\t\t\t\"We have one or more unmatching words, ending at j-1\"\r\t\t\t\t\t\ti := self \r\t\t\t\t\t\t\tencodeInt: (j - k) * 4 + 3\r\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\tat: i.\r\t\t\t\t\t\tk \r\t\t\t\t\t\t\tto: j - 1\r\t\t\t\t\t\t\tdo: \r\t\t\t\t\t\t\t\t[ :m | \r\t\t\t\t\t\t\t\ti := self \r\t\t\t\t\t\t\t\t\tencodeBytesOf: (bm at: m)\r\t\t\t\t\t\t\t\t\tin: ba\r\t\t\t\t\t\t\t\t\tat: i ].\r\t\t\t\t\t\tk := j ] ] ].\r\t^ i - 1\t\"number of bytes actually stored\""},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self"},{"name":"integerAt:put:","linesOfCode":13,"sourceCode":"integerAt: index put: anInteger \r\t\"Store the integer at the given index\"\r\t| word |\r\t<primitive: 166>\r\tanInteger < 0 \r\t\tifTrue: \r\t\t\t[ \"word := 16r100000000 + anInteger\"\r\t\t\tword := (anInteger + 1) negated bitInvert32 ]\r\t\tifFalse: [ word := anInteger ].\r\tself \r\t\tbasicAt: index\r\t\tput: word.\r\t^ anInteger"},{"name":"restoreEndianness","linesOfCode":2,"sourceCode":"restoreEndianness\r\t\"nothing to do here?\""},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays.\"\r\t<primitive: 145>\r\tsuper atAllPut: value."},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 4"},{"name":"byteAt:","linesOfCode":5,"sourceCode":"byteAt: byteAddress \r\t\"Extract a byte from a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:.  See Form>>#pixelAt:\"\r\t| lowBits |\r\tlowBits := byteAddress - 1 bitAnd: 3.\r\t^ ((self at: (byteAddress - 1 - lowBits) // 4 + 1) bitShift: (lowBits - 3) * 8) bitAnd: 255"},{"name":"pixelValueForDepth:","linesOfCode":3,"sourceCode":"pixelValueForDepth: depth\r\t\"Self is being used to represent a single color.  Answer bits that appear in ONE pixel of this color in a Bitmap of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32.  Returns an integer.  First pixel only.  \"\r\r\t^ (self at: 1) bitAnd: (1 bitShift: depth) - 1"},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream\r\tself printNameOn: aStream.\r\taStream nextPutAll: ' of length '; print: self size"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"bitPatternForDepth:","linesOfCode":3,"sourceCode":"bitPatternForDepth: depth\r\t\"The raw call on BitBlt needs a Bitmap to represent this color.  I already am Bitmap like. I am already adjusted for a specific depth.  Interpret me as an array of (32/depth) Color pixelValues. BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.\"\r\r\t^ self"},{"name":"storeBits:to:on:","linesOfCode":18,"sourceCode":"storeBits: startBit to: stopBit on: aStream \r\t\"Store my bits as a hex string, breaking the lines every 100 bytes or \r\tso to comply with the maximum line length limits of Postscript (255 \r\tbytes). \"\r\t| lineWidth |\r\tlineWidth := 0.\r\tself\r\t\tdo: [:word | \r\t\t\tstartBit\r\t\t\t\tto: stopBit\r\t\t\t\tby: -4\r\t\t\t\tdo: [:shift | \r\t\t\t\t\taStream nextPut: (word >> shift bitAnd: 15) asHexDigit.\r\t\t\t\t\tlineWidth := lineWidth + 1].\r\t\t\t(lineWidth > 100)\r\t\t\t\tifTrue: [aStream cr.\r\t\t\t\t\tlineWidth := 0]].\r\tlineWidth > 0 ifTrue: [ aStream cr ]."},{"name":"writeOn:","linesOfCode":8,"sourceCode":"writeOn: aStream \r\t\"Store the array of bits onto the argument, aStream. A leading byte of 16r80 identifies this as compressed by compressToByteArray (qv).\"\r\t| b |\r\taStream nextPut: 128.\r\tb := self compressToByteArray.\r\taStream\r\t\tnextPutAll: (self encodeInt: b size);\r\t\tnextPutAll: b"},{"name":"writeUncompressedOn:","linesOfCode":5,"sourceCode":"writeUncompressedOn: aStream \r\t\"Store the array of bits onto the argument, aStream.\r\t(leading byte ~= 16r80) identifies this as raw bits (uncompressed).\"\r\r\taStream nextInt32Put: self size.\r\taStream nextPutAll: self\r"},{"name":"gtInspectorItemsIn:","linesOfCode":2,"sourceCode":"gtInspectorItemsIn: composite\r\t\"No items presentation for a Bitmap\""},{"name":"primFill:","linesOfCode":4,"sourceCode":"primFill: aPositiveInteger\r\t\"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays.\"\r\r\t<primitive: 145>\r\tself errorImproperStore."},{"name":"byteAt:put:","linesOfCode":12,"sourceCode":"byteAt: byteAddress put: byte \r\t\"Insert a byte into a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:put:.  See Form>>#pixelAt:put:\"\r\t| longWord shift lowBits longAddr |\r\t(byte < 0 or: [ byte > 255 ]) ifTrue: [ ^ self errorImproperStore ].\r\tlowBits := byteAddress - 1 bitAnd: 3.\r\tlongWord := self at: (longAddr := (byteAddress - 1 - lowBits) // 4 + 1).\r\tshift := (3 - lowBits) * 8.\r\tlongWord := longWord - (longWord bitAnd: (255 bitShift: shift)) + (byte bitShift: shift).\r\tself \r\t\tat: longAddr\r\t\tput: longWord.\r\t^ byte"}],"meta":{"name":"Bitmap class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tSmalltalk specialObjectsArray \r\t\tat: 5\r\t\tput: self"},{"name":"decodeIntFrom:","linesOfCode":14,"sourceCode":"decodeIntFrom: s \r\t\"Decode an integer in stream s as follows...\r\t\t0-223\t0-223\r\t\t224-254\t(0-30)*256 + next byte (0-7935)\r\t\t255\t\tnext 4 bytes\t\"\r\t| int |\r\tint := s next.\r\tint <= 223 ifTrue: [ ^ int ].\r\tint <= 254 ifTrue: [ ^ (int - 224) * 256 + s next ].\r\tint := s next.\r\t1 \r\t\tto: 3\r\t\tdo: [ :j | int := (int bitShift: 8) + s next ].\r\t^ int"},{"name":"swapBytesIn:from:to:","linesOfCode":37,"sourceCode":"swapBytesIn: aNonPointerThing from: start to: stop \r\t\"Perform a bigEndian/littleEndian byte reversal of my words.\r\tWe only intend this for non-pointer arrays.  Do nothing if I contain pointers.\"\r\t\"The implementation is a hack, but fast for large ranges\"\r\t| hack blt |\r\thack := Form new hackBits: aNonPointerThing.\r\tblt := (BitBlt toForm: hack) sourceForm: hack.\r\tblt combinationRule: Form reverse.\t\"XOR\"\r\tblt\r\t\tsourceY: start - 1;\r\t\tdestY: start - 1;\r\t\theight: stop - start + 1;\r\t\twidth: 1.\r\tblt\r\t\tsourceX: 0;\r\t\tdestX: 3;\r\t\tcopyBits.\t\"Exchange bytes 0 and 3\"\r\tblt\r\t\tsourceX: 3;\r\t\tdestX: 0;\r\t\tcopyBits.\r\tblt\r\t\tsourceX: 0;\r\t\tdestX: 3;\r\t\tcopyBits.\r\tblt\r\t\tsourceX: 1;\r\t\tdestX: 2;\r\t\tcopyBits.\t\"Exchange bytes 1 and 2\"\r\tblt\r\t\tsourceX: 2;\r\t\tdestX: 1;\r\t\tcopyBits.\r\tblt\r\t\tsourceX: 1;\r\t\tdestX: 2;\r\t\tcopyBits"},{"name":"decompressFromByteArray:","linesOfCode":10,"sourceCode":"decompressFromByteArray: byteArray \r\t| s bitmap size |\r\ts := byteArray readStream.\r\tsize := self decodeIntFrom: s.\r\tbitmap := self new: size.\r\tbitmap \r\t\tdecompress: bitmap\r\t\tfromByteArray: byteArray\r\t\tat: s position + 1.\r\t^ bitmap"},{"name":"newFromStream:","linesOfCode":11,"sourceCode":"newFromStream: s\r\t| len |\r\ts next = 128\r\t\tifTrue: [ \"New compressed format\"\r\t\t\tlen := self decodeIntFrom: s.\r\t\t\t^ Bitmap decompressFromByteArray: (s nextInto: (ByteArray new: len)) ].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ len <= 0\r\t\tifTrue: [ \"Old compressed format\" (self new: len negated) readCompressedFrom: s ]\r\t\tifFalse: [ \"Old raw data format\" s nextWordsInto: (self new: len) ]"}],"meta":null}},{"name":"FFIExternalArray","instanceVariables":[{"name":"handle"},{"name":"type"},{"name":"size"}],"methods":[{"name":"pointer","linesOfCode":10,"sourceCode":"pointer\r\t\"Answers a pointer to this array. \r\t This is useful when translating an array pointer to a function (FFI requires to be passed as a\r\t pointer, otherwise will be interpreted as a direct array and it will not work fine)\r\t\r\t For an example, see FFICallback class>>#exampleCqsort\r\t\r\t WARNING: Only valid for external address (you cannot have a pointer to an image side object)\"\r\t\t\r\tself getHandle isExternalAddress ifFalse: [ \r\t\tself error: 'Arrays need to be moved to external memory space before passing them as pointers.' ].\r\t^ self getHandle pointer\t"},{"name":"pointerAutoRelease","linesOfCode":3,"sourceCode":"pointerAutoRelease\r\t\"Same as #pointer (see its comment for detals), but contents are garbage collected automatically\"\r\t^ self pointer autoRelease"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ size"},{"name":"free","linesOfCode":5,"sourceCode":"free\r\thandle ifNil: [ ^ self ]. \r\thandle isExternalAddress \r\t\tifTrue: [ handle free ]\r\t\tifFalse: [ handle := nil ]"},{"name":"initializeType:size:handleProducer:","linesOfCode":8,"sourceCode":"initializeType: aType size: aNumber handleProducer: aBlock \r\ttype := aType.\r\tsize := aNumber.\r\thandle := aBlock value: (size \r\t\tifNotNil: [ size * type typeSize ]\r\t\tifNil: [ 0 ]).\r\thandle isNull ifTrue: [ self error: 'External allocation failed' ].\r\tself initialize"},{"name":"typeSize","linesOfCode":2,"sourceCode":"typeSize \r\t^ self type typeSize"},{"name":"getHandle","linesOfCode":4,"sourceCode":"getHandle\r\tself flag: #pharoTodo. \"I do not like the name 'getHandle' but I'm looking to unify the \r\tAPI with FFI\" \r\t^ handle"},{"name":"asArray","linesOfCode":5,"sourceCode":"asArray \r\t| array |\r\t\r\tarray := Array new: self size.\r\t1 to: self size do: [ :index | array at: index put: (self at: index) ].\r\t\r\t^ array "},{"name":"initializeHandle:type:size:","linesOfCode":5,"sourceCode":"initializeHandle: aHandle type: aType size: aNumber\r\tself \r\t\tinitializeType: aType \r\t\tsize: aNumber \r\t\thandleProducer: [ :totalSize | aHandle ]"},{"name":"at:","linesOfCode":4,"sourceCode":"at: index \r\t^ type \r\t\thandle: handle\r\t\tat: ((index - 1) * type typeSize) + 1"},{"name":"typeAlignment","linesOfCode":2,"sourceCode":"typeAlignment \r\t^ self type typeAlignment"},{"name":"initializeType:size:","linesOfCode":5,"sourceCode":"initializeType: aType size: aNumber\r\tself \r\t\tinitializeType: aType \r\t\tsize: aNumber \r\t\thandleProducer: [ :totalSize | ByteArray new: totalSize ]\r"},{"name":"gcpointer","linesOfCode":10,"sourceCode":"gcpointer\r\t\"Answers a pointer to the this array. \r\t This is useful when translating an array pointer to a function (FFI requires to be passed as a\r\t pointer, otherwise will be interpreted as a direct array and it will not work fine)\r\t\r\t For an example, see FFICallback class>>#exampleCqsort\r\t\r\t WARNING: Only valid for external address (you cannot have a pointer to an image side object)\"\r\tself deprecated: 'Use \"pointer autoRelease\" instead.' on: '2016-01-22' in: #Pharo5.  \t\t\r\tself getHandle isExternalAddress ifFalse: [ \r\t\tself error: 'Arrays need to be moved to external memory space before passing them as pointers.' ].\r\t^ self getHandle gcpointer\t"},{"name":"autoRelease","linesOfCode":3,"sourceCode":"autoRelease\r\t(handle isNil or: [ handle isExternalAddress not ]) ifFalse: [ ^ self ].\r\thandle autoRelease"},{"name":"initializeExternalType:size:","linesOfCode":5,"sourceCode":"initializeExternalType: aType size: aNumber\r\tself \r\t\tinitializeType: aType \r\t\tsize: aNumber \r\t\thandleProducer: [ :totalSize | ExternalAddress allocate: (type typeSize * size) ]"},{"name":"at:put:","linesOfCode":5,"sourceCode":"at: index put: anObject \r\t^ type \r\t\thandle: handle\r\t\tat: ((index - 1) * type typeSize) + 1\r\t\tput: anObject"},{"name":"type","linesOfCode":2,"sourceCode":"type\r\t^ type"}],"meta":{"name":"FFIExternalArray class","instanceVariables":[],"methods":[{"name":"resolveType:","linesOfCode":4,"sourceCode":"resolveType: aType\r\t ^ FFICallout new \r\t\trequestor: self;\r\t\tresolveType: aType."},{"name":"fromHandle:type:","linesOfCode":6,"sourceCode":"fromHandle: aHandle type: aType\r\t\"Instantiating a handle as an array.\r\t USE THIS WITH EXTREMELY CAUTION: You could have an overflow very easily, because you are \r\t not expliciting the size. \r\t I would prefer if you use #fromHandle:type:size: instead. \"\r\t^ self fromHandle: aHandle type: aType size: nil"},{"name":"fromHandle:type:size:","linesOfCode":10,"sourceCode":"fromHandle: aHandle type: aType size: aNumber\r\t\"aHandle is the address to an array already existing. \r\t For example, C: \r\t \t\r\t\tbyte[]\t aHandle;\r\t\t\t\r\t which means is a direct reference and array starts in same address as aHandle\"\r\t^ self basicNew \r\t\tinitializeHandle: aHandle type: (self resolveType: aType) size: aNumber;\r\t\tyourself"},{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator \r\t^ FFIExternalArrayType objectClass: self"},{"name":"externalNewType:size:","linesOfCode":6,"sourceCode":"externalNewType: aType size: aNumber\r\t\"Create a new array in the C heap. \r\t This array needs to be disposed (using #free method)\"\r\t^ self basicNew \r\t\tinitializeExternalType: (self resolveType: aType) size: aNumber;\r\t\tyourself"},{"name":"new","linesOfCode":2,"sourceCode":"new \r\tself error: 'should not create external arrays like this'"},{"name":"newType:size:","linesOfCode":5,"sourceCode":"newType: aType size: aNumber\r\t\"Create a new array using internal memory.\"\r\t^ self basicNew \r\t\tinitializeType: (self resolveType: aType) size: aNumber;\r\t\tyourself"},{"name":"fromPointer:type:size:","linesOfCode":10,"sourceCode":"fromPointer: aHandle type: aType size: aNumber\r\t\"Creates an array of type aType and size aNumber.\r\t aHandle is A REFERENCE an array already existing. \r\t For example, C: \r\t \t\r\t\tbyte[]\t array;\r\t\tvoid * aHandle = &array;\r\t\t\t\r\t Which means first element of array will be found at ==aHandle pointerAt: 1==\"\r\t^ self fromHandle: (aHandle pointerAt: 1) type: aType size: aNumber"},{"name":"fromPointer:type:","linesOfCode":5,"sourceCode":"fromPointer: aHandle type: aType \r\t\"Instantiating a pointer as an array is usefull, but then you do not have the size. \r\t USE THIS WITH EXTREMELY CAUTION: You could have an overflow very easily. \r\t I would prefer if you use #fromPointer:type:size: instead. \"\r\t^ self fromPointer: aHandle type: aType size: nil"}],"meta":null}},{"name":"ShortIntegerArray","instanceVariables":[],"methods":[{"name":"write:on:","linesOfCode":4,"sourceCode":"write: shortInteger on: aStream\r\t^ EndianDetector isLittleEndian\r\t\tifFalse: [ self write: shortInteger bigEndianOn: aStream ]\r\t\tifTrue: [ self write: shortInteger littleEndianOn: aStream ]"},{"name":"write:bigEndianOn:","linesOfCode":2,"sourceCode":"write: shortInteger bigEndianOn: aStream\r\t^ aStream nextNumber: 4 put: shortInteger"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^super size * 2"},{"name":"write:littleEndianOn:","linesOfCode":2,"sourceCode":"write: shortInteger littleEndianOn: aStream\r\r\t#(2 1 4 3) do: [:digitIndex| aStream nextPut: (shortInteger byteAt: digitIndex) ]"},{"name":"defaultElement","linesOfCode":2,"sourceCode":"defaultElement\r\t^0"},{"name":"writeOn:","linesOfCode":4,"sourceCode":"writeOn: aStream\r\taStream nextInt32Put: self basicSize.\r\t1 to: self basicSize do: [ :i | \r\t\tself write: (self basicAt: i) on: aStream ]"},{"name":"pvtAt:","linesOfCode":5,"sourceCode":"pvtAt: index\r\t\"Private -- for swapping only\"\r\t<primitive: 143>\r\tindex isInteger ifTrue: [self errorSubscriptBounds: index].\r\tself errorNonIntegerIndex.\r"},{"name":"swapBytePairsHacky","linesOfCode":17,"sourceCode":"swapBytePairsHacky\r\r\t\"The implementation is a hack, but fast for large ranges\"\r\t\t\t\"XOR\"\r\t\t\t\"Exchange bytes 0 and 1\"\r\t\t\t\"Exchange bytes 2 and 3\"\r\t| hack blt |\r\thack := Form new hackBits: self.\t\"The implementation is a hack, but fast for large ranges\"\r\tblt := (BitBlt toForm: hack) sourceForm: hack.\r\tblt combinationRule: Form reverse.\t\"XOR\"\r\t\t\r\tblt\r\t\tsourceY: 0;\r\t\tdestY: 0;\r\t\theight: hack height;\r\t\twidth: 1.\r\t#((0 1) (1 0) (0 1) (2 3)(3 2)(2 3))\r\t\tdo: [:array | [:a :b| blt sourceX: a; destX: b; copyBits ] valueWithArguments: array ].\r"},{"name":"at:","linesOfCode":5,"sourceCode":"at: index\r\t\"Return the 16-bit integer value at the given index of the receiver.\"\r\r\t<primitive: 143>\r\tindex isInteger ifTrue: [self errorSubscriptBounds: index].\r\tself errorNonIntegerIndex.\r"},{"name":"restoreEndianness","linesOfCode":5,"sourceCode":"restoreEndianness\r\t\"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.\r\tWhy is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap.\"\r\r\tEndianDetector isLittleEndian\r\t\tifTrue: [ self swapBytePairsHacky ]"},{"name":"swapShortObjects","linesOfCode":8,"sourceCode":"swapShortObjects\r\t\"Private -- swap all the short quantities in the receiver\"\r\t| tmp |\r\t1 to: self basicSize do:[:i|\r\t\ttmp := (self pvtAt: i * 2).\r\t\tself pvtAt: i * 2 put: (self pvtAt: i * 2 - 1).\r\t\tself pvtAt: i * 2 - 1 put: tmp.\r\t]"},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: index put: value\r\t\"Store the given 16-bit integer at the given index in the receiver.\"\r\r\t<primitive: 144>\r\tindex isInteger\r\t\tifTrue: [ \r\t\t\t(index between: 1 and: self size)\r\t\t\t\tifTrue: [ self errorImproperStore ]\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index ] ].\r\tself errorNonIntegerIndex"},{"name":"pvtAt:put:","linesOfCode":9,"sourceCode":"pvtAt: index put: value\r\t\"Private -- for swapping only\"\r\r\t<primitive: 144>\r\tindex isInteger\r\t\tifTrue: [ \r\t\t\t(index between: 1 and: self size)\r\t\t\t\tifTrue: [ self errorImproperStore ]\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index ] ].\r\tself errorNonIntegerIndex"}],"meta":{"name":"ShortIntegerArray class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\tLastSaveOrder := self new: 2.\r\tLastSaveOrder at: 1 put: 42.\r\tLastSaveOrder at: 2 put: 13.\r\t\r\tSessionManager default\r\t\tregisterSystemClassNamed: self name"},{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^super new: n + 1 // 2"},{"name":"startUp","linesOfCode":7,"sourceCode":"startUp\r\t\"Check if the word order has changed from the last save\"\r\t((LastSaveOrder at: 1) = 42 and:[(LastSaveOrder at: 2) = 13]) \r\t\tifTrue:[^self]. \"Okay\"\r\t((LastSaveOrder at: 2) = 42 and:[(LastSaveOrder at: 1) = 13]) \r\t\tifTrue:[^self swapShortObjects]. \"Reverse guys\"\r\t^self error:'This must never happen'"},{"name":"swapShortObjects","linesOfCode":2,"sourceCode":"swapShortObjects\r\tself allSubInstancesDo:[:inst| inst swapShortObjects]"}],"meta":null}},{"name":"Text","instanceVariables":[{"name":"string"},{"name":"runs"}],"methods":[{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: character\r\r\t^string at: index put: character"},{"name":"embeddedMorphs","linesOfCode":9,"sourceCode":"embeddedMorphs\r\t\"return the list of morphs embedded in me\"\r\r\t| morphs |\r\tmorphs := IdentitySet new.\r\truns withStartStopAndValueDo: \r\t\t\t[:start :stop :attribs | \r\t\t\tattribs \r\t\t\t\tdo: [:attrib | attrib anchoredMorph ifNotNil: [morphs add: attrib anchoredMorph]]].\r\t^morphs select: [:m | m isMorph]"},{"name":"withAccentuatedCharacter:","linesOfCode":10,"sourceCode":"withAccentuatedCharacter: aCharacter\r\r\t| text index | \r\ttext := self copy.\r\taCharacter ifNil: [ ^ text ].\r\tindex := self asString asLowercase indexOf: aCharacter asLowercase.\r\tindex isZero\r\t\tifTrue: [ ^ text ].\r\r\t^ text\r\t\taddAttribute: TextEmphasis underlined from: index to: index;\r\t\tyourself"},{"name":"copyReplaceFrom:to:with:","linesOfCode":6,"sourceCode":"copyReplaceFrom: start to: stop with: aTextOrString\r\r\t| txt |\r\ttxt := aTextOrString asText.\t\"might be a string\"\r\t^self class \r             string: (string copyReplaceFrom: start to: stop with: txt string)\r             runs: (runs copyReplaceFrom: start to: stop with: txt runs)\r"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonReader parseNamedInstVarsFor: self"},{"name":"listRenderOn:atRow:bounds:color:backgroundColor:from:","linesOfCode":28,"sourceCode":"listRenderOn: aCanvas atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\t\"Method extracted from LazyListMorph\"\r\t| attrs useDefaultFont f itemBounds |\r\t\r\tattrs := self attributesAt: 1.\r\tuseDefaultFont := true.\r\tattrs\r\t\tdo: [:att | att\r\t\t\t\tforFontInStyle: aMorph font textStyle\r\t\t\t\tdo: [:fon | useDefaultFont := false]].\r\tf := useDefaultFont\r\t\t\t\tifTrue: [ aMorph font]\r\t\t\t\tifFalse: [ self fontAt: 1 withStyle: aMorph font textStyle ].\r\titemBounds := bounds withHeight: f height.\r\titemBounds := itemBounds align: itemBounds leftCenter with: bounds leftCenter.\r\t\"center the item if the font height is different to that of our font\"\r\taCanvas\r\t\tdrawString: self\r\t\tin: itemBounds\r\t\tfont: (f emphasized: (self emphasisAt: 1))\r\t\tcolor: color\r\t\tunderline: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 4)\r\t\t\t\t> 0\r\t\tunderlineColor: color\r\t\tstrikethrough: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 16)\r\t\t\t\t> 0\r\t\tstrikethroughColor: color"},{"name":"listBuildSceneGraphWith:atRow:bounds:color:backgroundColor:from:","linesOfCode":28,"sourceCode":"listBuildSceneGraphWith: builder atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\t\"Method extracted from LazyListMorph\"\r\t| attrs useDefaultFont f itemBounds |\r\t\r\tattrs := self attributesAt: 1.\r\tuseDefaultFont := true.\r\tattrs\r\t\tdo: [:att | att\r\t\t\t\tforFontInStyle: aMorph font textStyle\r\t\t\t\tdo: [:fon | useDefaultFont := false]].\r\tf := useDefaultFont\r\t\t\t\tifTrue: [ aMorph font]\r\t\t\t\tifFalse: [ self fontAt: 1 withStyle: aMorph font textStyle ].\r\titemBounds := bounds withHeight: f height.\r\titemBounds := itemBounds align: itemBounds leftCenter with: bounds leftCenter.\r\t\"center the item if the font height is different to that of our font\"\r\t^ builder\r\t\tstring: self asString\r\t\tin: itemBounds\r\t\tfont: (f emphasized: (self emphasisAt: 1))\r\t\tcolor: color\r\t\tunderline: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 4)\r\t\t\t\t> 0\r\t\tunderlineColor: color\r\t\tstrikethrough: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 16)\r\t\t\t\t> 0\r\t\tstrikethroughColor: color"},{"name":"embeddedMorphsFrom:to:","linesOfCode":12,"sourceCode":"embeddedMorphsFrom: start to: stop \r\t\"return the list of morphs embedded in me\"\r\r\t| morphs |\r\tmorphs := IdentitySet new.\r\truns \r\t\trunsFrom: start\r\t\tto: stop\r\t\tdo: \r\t\t\t[:attribs | \r\t\t\tattribs \r\t\t\t\tdo: [:attr | attr anchoredMorph ifNotNil: [morphs add: attr anchoredMorph]]].\r\t^morphs select: [:m | m isMorph]"},{"name":"attributesAt:forStyle:","linesOfCode":7,"sourceCode":"attributesAt: characterIndex forStyle: aTextStyle\r\t\"Answer the code for characters in the run beginning at characterIndex.\"\r\t| attributes |\r\tself size = 0\r\t\tifTrue: [^ Array with: (TextFontChange new fontNumber: aTextStyle defaultFontIndex)].  \"null text tolerates access\"\r\tattributes := runs at: characterIndex.\r\t^ attributes"},{"name":"emphasisAt:","linesOfCode":7,"sourceCode":"emphasisAt: characterIndex\r\t\"Answer the fontfor characters in the run beginning at characterIndex.\"\r\t| attributes |\r\tself size = 0 ifTrue: [^ 0].\t\"null text tolerates access\"\r\tattributes := runs at: characterIndex.\r\t^attributes inject: 0 into:\r\t\t[:emph :att | emph bitOr: att emphasisCode]."},{"name":"heightToDisplayInTree:","linesOfCode":2,"sourceCode":"heightToDisplayInTree: aTree\r\r\t^ aTree fontToUse height"},{"name":"treeRenderOn:bounds:color:font:from:","linesOfCode":28,"sourceCode":"treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\t\"Method extracted from LazyListMorph\"\r\t| attrs useDefaultFont f itemBounds |\r\t\r\tattrs := self attributesAt: 1.\r\tuseDefaultFont := true.\r\tattrs\r\t\tdo: [:att | att\r\t\t\t\tforFontInStyle: TextStyle default\r\t\t\t\tdo: [:fon | useDefaultFont := false]].\r\tf := useDefaultFont\r\t\t\t\tifTrue: [ aMorph font ]\r\t\t\t\tifFalse: [ self fontAt: 1 withStyle: TextStyle default ].\r\titemBounds := drawBounds  withHeight: f height.\r\titemBounds := itemBounds align: itemBounds leftCenter with: drawBounds  leftCenter.\r\t\"center the item if the font height is different to that of our font\"\r\taCanvas\r\t\tdrawString: self\r\t\tin: itemBounds\r\t\tfont: (f emphasized: (self emphasisAt: 1))\r\t\tcolor: drawColor \r\t\tunderline: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 4)\r\t\t\t\t> 0\r\t\tunderlineColor: drawColor \r\t\tstrikethrough: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 16)\r\t\t\t\t> 0\r\t\tstrikethroughColor: drawColor "},{"name":"=","linesOfCode":7,"sourceCode":"= other\r\t\"Am I equal to the other Text or String?  \r\t***** Warning ***** Two Texts are considered equal if they have the same characters in them.  They might have completely different emphasis, fonts, sizes, text actions, or embedded morphs.  If you need to find out if one is a true copy of the other, you must do (text1 = text2 and: [text1 runs = text2 runs]).\"\r\r\tother isText ifTrue:\t[\"This is designed to run fast even for megabytes\"\r\t\t\t\t^ string == other string or: [string = other string]].\r\tother isString ifTrue: [^ string == other or: [string = other]].\r\t^ false"},{"name":"asText","linesOfCode":3,"sourceCode":"asText\t\r\t\"Answer the receiver itself.\"\r\r\t^self"},{"name":"makeAllColor:","linesOfCode":4,"sourceCode":"makeAllColor: color\r\t| attribute |\r\tattribute := TextColor color: color.\r\r\t^ self addAttribute: attribute from: 1 to: self size"},{"name":"makeColor:from:to:","linesOfCode":4,"sourceCode":"makeColor: color from: start to: stop\r\t| attribute |\r\tattribute := TextColor color: color.\r\r\t^ self addAttribute: attribute from: start to: stop"},{"name":"widthToDisplayInList:","linesOfCode":2,"sourceCode":"widthToDisplayInList: aList\r\r\t^ aList font widthOfStringOrText: self contents"},{"name":"asTextMorph","linesOfCode":2,"sourceCode":"asTextMorph\r\t^ TextMorph new contentsAsIs: self"},{"name":"widthToDisplayInTree:","linesOfCode":2,"sourceCode":"widthToDisplayInTree: aTree\r\r\t^ aTree fontToUse widthOfStringOrText: self contents"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonWriter writeObject: self"},{"name":"alignmentAt:ifAbsent:","linesOfCode":7,"sourceCode":"alignmentAt: characterIndex ifAbsent: aBlock\r\t| attributes emph |\r\tself size = 0 ifTrue: [^aBlock value].\r\temph := nil.\r\tattributes := runs at: characterIndex.\r\tattributes do:[:att | (att isKindOf: TextAlignment) ifTrue: [emph := att]].\r\t^ emph ifNil: aBlock ifNotNil: [emph alignment]"},{"name":"asOctetStringText","linesOfCode":5,"sourceCode":"asOctetStringText\r\r\tstring class == WideString ifTrue: [\r\t\t^ self class string: string asOctetString runs: self runs copy.\r\t].\r\t^self.\r"},{"name":"find:","linesOfCode":12,"sourceCode":"find: attribute\r\t\"Return the first interval over which this attribute applies\"\r\t| begin end |\r\tbegin := 0.\r\truns withStartStopAndValueDo:\r\t\t[:start :stop :attributes |\r\t\t(attributes includes: attribute)\r\t\t\tifTrue: [begin = 0 ifTrue: [begin := start].\r\t\t\t\t\tend := stop]\r\t\t\tifFalse: [begin > 0 ifTrue: [^ begin to: end]]].\r\tbegin > 0 ifTrue: [^ begin to: end].\r\t^ nil"},{"name":"reversed","linesOfCode":4,"sourceCode":"reversed\r \r \t\"Answer a copy of the receiver with element order reversed.\"\r \r \t^ self class string: string reversed runs: runs reversed.\r \r   \"  It is assumed that  self size = runs size  holds. \""},{"name":"attributesAt:do:","linesOfCode":5,"sourceCode":"attributesAt: characterIndex do: aBlock\r\t\"Answer the code for characters in the run beginning at characterIndex.\"\r\t\"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this\"\r\tself size = 0 ifTrue:[^self].\r\t(runs at: characterIndex) do: aBlock"},{"name":"removeAttribute:","linesOfCode":2,"sourceCode":"removeAttribute: att \r\t^ self removeAttribute: att from: 1 to: self size"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\r\t^string size"},{"name":"includesSubstring:caseSensitive:","linesOfCode":2,"sourceCode":"includesSubstring: aString caseSensitive: caseSensitive\r\t\r\t^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0"},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream\r\tself printNameOn: aStream.\r\taStream nextPutAll: ' for '; print: string"},{"name":"threeWayCompareTo:","linesOfCode":2,"sourceCode":"threeWayCompareTo: anotherText\r\t\r\t^ self asString threeWayCompareTo: anotherText asString"},{"name":"attributesAt:","linesOfCode":9,"sourceCode":"attributesAt: characterIndex \r\t\"Answer the code for characters in the run beginning at characterIndex.\"\r\t\"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this\"\r\t| attributes |\r\"\tself size = 0\r\t\tifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].\"\r\tself size = 0 ifTrue: [ ^#()].\r\tattributes := runs at: characterIndex.\r\t^ attributes"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":7,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r \t\"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. Do it to both the string and the runs.\"\r \r \t| rep newRepRuns |\r \trep := replacement asText.\t\"might be a string\"\r \tstring replaceFrom: start to: stop with: rep string startingAt: repStart.\r \tnewRepRuns := rep runs copyFrom: repStart to: repStart + stop - start.\r\truns := runs copyReplaceFrom: start to: stop with: newRepRuns"},{"name":"setString:setRuns:","linesOfCode":3,"sourceCode":"setString: aString setRuns: anArray\r\r\tstring := aString.\r\truns := anArray"},{"name":"string","linesOfCode":3,"sourceCode":"string\r\t\"Answer the string representation of the receiver.\"\r\r\t^string"},{"name":"initialStyle","linesOfCode":2,"sourceCode":"initialStyle\r\t^TextStyle default"},{"name":"asPetitStream","linesOfCode":2,"sourceCode":"asPetitStream\r\t^ string asPetitStream"},{"name":"copyReplaceTokens:with:","linesOfCode":5,"sourceCode":"copyReplaceTokens: oldSubstring with: newSubstring \r\t\"Replace all occurrences of oldSubstring that are surrounded\r\tby non-alphanumeric characters\"\r\t^ (self string copyReplaceAll: oldSubstring with: newSubstring asTokens: true) asText\r\t\"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'\""},{"name":"fontAt:","linesOfCode":2,"sourceCode":"fontAt: characterIndex\r\t^self fontAt: characterIndex withStyle: TextStyle default"},{"name":"removeAttributesThat:replaceAttributesThat:by:","linesOfCode":27,"sourceCode":"removeAttributesThat: removalBlock replaceAttributesThat: replaceBlock by: convertBlock\r\t\"Enumerate all attributes in the receiver. Remove those passing removalBlock and replace those passing replaceBlock after converting it through convertBlock\"\r\t| added removed |\r\t\"Deliberately optimized for the no-op default.\"\r\tadded := removed := nil.\r\truns withStartStopAndValueDo: [ :start :stop :attribs | \r\t\tattribs do: [ :attrib | | new |\r\t\t\t(removalBlock value: attrib) ifTrue:[\r\t\t\t\tremoved ifNil:[removed := Array new writeStream].\r\t\t\t\tremoved nextPut: {start. stop. attrib}.\r\t\t\t] ifFalse:[\r\t\t\t\t(replaceBlock value: attrib) ifTrue:[\r\t\t\t\t\tremoved ifNil:[removed := Array new writeStream].\r\t\t\t\t\tremoved nextPut: {start. stop. attrib}.\r\t\t\t\t\tnew := convertBlock value: attrib.\r\t\t\t\t\tadded ifNil:[added := Array new writeStream].\r\t\t\t\t\tadded nextPut: {start. stop. new}.\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t].\r\t(added isNil and:[removed isNil]) ifTrue:[^self].\r\t\"otherwise do the real work\"\r\tremoved ifNotNil:[removed contents do:[:spec|\r\t\tself removeAttribute: spec last from: spec first to: spec second]].\r\tadded ifNotNil:[added contents do:[:spec|\r\t\tself addAttribute: spec last from: spec first to: spec second]]."},{"name":"asStringOrText","linesOfCode":3,"sourceCode":"asStringOrText\t\r\t\"Answer the receiver itself.\"\r\r\t^self"},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\r\t^string at: index"},{"name":"runs","linesOfCode":2,"sourceCode":"runs\r\r\t^runs"},{"name":"gtInspectorItemsIn:","linesOfCode":2,"sourceCode":"gtInspectorItemsIn: composite\r\t\"No items presentation for a Text\""},{"name":"inspectionText","linesOfCode":8,"sourceCode":"inspectionText\r\t<inspectorPresentationOrder: 0 title: 'Text'>\r\r\t^ SpMorphPresenter new \r\t\tmorph: (RubScrolledTextMorph new \r\t\t\tsetText: self;\r\t\t\tin: [ :this | this textArea readOnly: true ];\r\t\t\tyourself);\r\t\tyourself"},{"name":"asMorph","linesOfCode":2,"sourceCode":"asMorph\r\t^ self asTextMorph"},{"name":"includesSubstring:","linesOfCode":2,"sourceCode":"includesSubstring: substring\r\t^ substring isEmpty or: [ (self findString: substring startingAt: 1) > 0 ]"},{"name":"heightToDisplayInList:","linesOfCode":2,"sourceCode":"heightToDisplayInList: aList\r\r\t^ aList font height"},{"name":"lineCount","linesOfCode":2,"sourceCode":"lineCount\r\r\t^ string lineCount"},{"name":"withSqueakLineEndings","linesOfCode":8,"sourceCode":"withSqueakLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with CR.\"\r\t\r\tself\r\t\tdeprecated: 'Should use withInternalLineEndings instead'\r\t\ton: '30 October 2020'\r\t\tin: #Pharo9\r\t\ttransformWith: '`@rec withSqueakLineEndings' -> '`@rec withInternalLineEndings'.\r\t\r\t^ self withInternalLineEndings"},{"name":"hasWideCharacterFrom:to:","linesOfCode":2,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t^string hasWideCharacterFrom: start to: stop"},{"name":"deepCopy","linesOfCode":2,"sourceCode":"deepCopy\r\r\t^ self copy \"Both string and runs are assumed to be read-only\""},{"name":"setString:setRunsChecking:","linesOfCode":9,"sourceCode":"setString: aString setRunsChecking: aRunArray\r\t\"Check runs and do the best you can to make them fit...\"\r\r\tstring := aString.\r\t\"check the runs\"\r\taRunArray ifNil: [^ aString asText].\r\t(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].\r\taRunArray runs size = aRunArray values size ifFalse: [^ aString asText].\r\taRunArray size = aString size ifFalse: [^ aString asText].\r\t\r\truns := aRunArray."},{"name":"allBold","linesOfCode":4,"sourceCode":"allBold \r\t\"Force this whole text to be bold.\"\r\tstring size = 0 ifTrue: [^self].\r\tself makeBoldFrom: 1 to: string size"},{"name":"unembellished","linesOfCode":10,"sourceCode":"unembellished \r\t\"Return true if the only emphases are the default font and bold\"\r\t| font1 bold |\r\tfont1 := TextFontChange defaultFontChange.\r\tbold := TextEmphasis bold.\r\truns withStartStopAndValueDo:\r\t\t[:start :stop :emphArray |\r\t\temphArray do:\r\t\t\t[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].\r\t^ true"},{"name":"gtInspectorTextIn:","linesOfCode":5,"sourceCode":"gtInspectorTextIn: composite\r\t<gtInspectorPresentationOrder: -10>  \r\t composite text\r\t\ttitle: 'Text';\r\t\tformat: self"},{"name":"beginsWith:fromList:","linesOfCode":2,"sourceCode":"beginsWith: aString fromList: aMorph\r\r\t^ self asString beginsWith: aString fromList: aMorph"},{"name":"prepend:","linesOfCode":2,"sourceCode":"prepend: stringOrText\r\r\tself replaceFrom: 1 to: 0 with: stringOrText"},{"name":"runs:","linesOfCode":5,"sourceCode":"runs: anArray\r\tanArray size = string size\r\t\tifFalse:\r\t\t\t[^self error: 'Some code is setting text attributes length not matching the string size'].\r\truns := anArray"},{"name":"findString:startingAt:caseSensitive:","linesOfCode":4,"sourceCode":"findString: aString startingAt: start caseSensitive: caseSensitive\r\t\"Answer the index of substring within the receiver, starting at index \r\tstart. If the receiver does not contain substring, answer 0.\"\r\r\t^string findString: aString asString startingAt: start caseSensitive: caseSensitive"},{"name":"asNumber","linesOfCode":4,"sourceCode":"asNumber\r\t\"Answer the number created by interpreting the receiver as the textual \r\trepresentation of a number.\"\r\r\t^string asNumber"},{"name":"fontAt:withStyle:","linesOfCode":9,"sourceCode":"fontAt: characterIndex withStyle: aTextStyle\r\t\"Answer the fontfor characters in the run beginning at characterIndex.\"\r\t| attributes font |\r\tself size = 0 ifTrue: [^ aTextStyle defaultFont].\t\"null text tolerates access\"\r\tattributes := runs at: characterIndex.\r\tfont := aTextStyle defaultFont.  \"default\"\r\tattributes do: \r\t\t[:att | att forFontInStyle: aTextStyle do: [:f | font := f]].\r\t^ font"},{"name":"postCopy","linesOfCode":4,"sourceCode":"postCopy\r\tsuper postCopy.\r\tstring := string copy.\r\truns := runs copy"},{"name":"gtDisplayOn:","linesOfCode":2,"sourceCode":"gtDisplayOn: aStream\r\tself printOn: aStream"},{"name":"howManyMatch:","linesOfCode":2,"sourceCode":"howManyMatch: aString\r\r\t^ self string howManyMatch: aString"},{"name":"encompassLine:","linesOfCode":2,"sourceCode":"encompassLine: anInterval\r\t^string encompassLine: anInterval"},{"name":"hash","linesOfCode":3,"sourceCode":"hash\r\t\"#hash is implemented, because #= is implemented.  We are now equal to a string with the same characters.  Hash must reflect that.\"\r\r\t^ string hash"},{"name":"withInternalLineEndings","linesOfCode":7,"sourceCode":"withInternalLineEndings\r\t\"Answer a copy of myself in which all sequences of <CR><LF> or <LF> have been changed to <CR>\"\r\t| newText |\r\t(string includes: Character lf) ifFalse: [ ^self copy ].\r\tnewText := self copyReplaceAll: String crlf with: String cr.\r\t(newText asString includes: Character lf) ifFalse: [ ^newText ].\r\t^newText copyReplaceAll: String lf with: String cr."},{"name":"asPetit2Stream","linesOfCode":2,"sourceCode":"asPetit2Stream\r\t^ string asPetit2Stream"},{"name":"addAttribute:from:to:","linesOfCode":6,"sourceCode":"addAttribute: att from: start to: stop \r\t\"Set the attribute for characters in the interval start to stop.\"\r\tself runs: (runs copyReplaceFrom: start to: stop\r\t\t\twith: ((runs copyFrom: start to: stop)\r\t\t\t\tmapValues:\r\t\t\t\t[:attributes | Text addAttribute: att toArray: attributes]))\r"},{"name":"makeBoldFrom:to:","linesOfCode":2,"sourceCode":"makeBoldFrom: start to: stop\r\r\t^ self addAttribute: TextEmphasis bold from: start to: stop"},{"name":"rangeOf:startingAt:","linesOfCode":5,"sourceCode":"rangeOf: attribute startingAt: index\r\"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index.  \"\r   ^string size = 0\r      ifTrue: [index to: index - 1]\r\t ifFalse: [runs rangeOf: attribute startingAt: index]"},{"name":"replaceFrom:to:with:","linesOfCode":5,"sourceCode":"replaceFrom: start to: stop with: aText\r\r\t| txt |\r\ttxt := aText asText.\t\"might be a string\"\r\tstring := string copyReplaceFrom: start to: stop with: txt string.\r\truns := runs copyReplaceFrom: start to: stop with: txt runs"},{"name":"append:","linesOfCode":3,"sourceCode":"append: stringOrText\r\r\tself replaceFrom: string size + 1\r\t\t\t\tto: string size with: stringOrText"},{"name":"asBrick","linesOfCode":2,"sourceCode":"asBrick\r\r\t^ self asString asBrick"},{"name":"addAttribute:","linesOfCode":2,"sourceCode":"addAttribute: att \r\t^ self addAttribute: att from: 1 to: self size"},{"name":"localizedForPresenter:","linesOfCode":2,"sourceCode":"localizedForPresenter: aPresenter\r\r\t^ self asString"},{"name":"findString:startingAt:","linesOfCode":4,"sourceCode":"findString: aString startingAt: start \r\t\"Answer the index of substring within the receiver, starting at index \r\tstart. If the receiver does not contain substring, answer 0.\"\r\r\t^string findString: aString asString startingAt: start"},{"name":"spotterPreviewIn:","linesOfCode":6,"sourceCode":"spotterPreviewIn: aComposite\r\t<spotterPreview: 10>\r\t^ aComposite text\r\t\ttitle: 'Contents';\r\t\tdisplay: [ :item | item asString contractTo: 100 ];\r\t\tentity: self"},{"name":"asStringMorph","linesOfCode":5,"sourceCode":"asStringMorph\r\t^ StringMorph\r\t\tcontents: self string\r\t\tfont: (self fontAt: 1 withStyle: TextStyle default)\r\t\temphasis: (self emphasisAt: 1)"},{"name":"asString","linesOfCode":3,"sourceCode":"asString\r\t\"Answer a String representation of the textual receiver.\"\r\r\t^string"},{"name":"copyFrom:to:","linesOfCode":12,"sourceCode":"copyFrom: start to: stop \r\t\"Answer a copied subrange of the receiver.\"\r\r\t| realStart realStop |\r\tstop > self size\r\t\tifTrue: [realStop := self size]\t\t\"handle selection at end of string\"\r\t\tifFalse: [realStop := stop].\r\tstart < 1\r\t\tifTrue: [realStart := 1]\t\t\t\"handle selection before start of string\"\r\t\tifFalse: [realStart := start].\r\t^self class \r\t\tstring: (string copyFrom: realStart to: realStop)\r\t\truns: (runs copyFrom: realStart to: realStop)"},{"name":"removeAttribute:from:to:","linesOfCode":6,"sourceCode":"removeAttribute: att from: start to: stop \r\t\"Remove the attribute over the interval start to stop.\"\r\tself runs: (runs copyReplaceFrom: start to: stop\r\t\t\twith: ((runs copyFrom: start to: stop)\r\t\t\t\tmapValues:\r\t\t\t\t[:attributes | attributes copyWithout: att]))\r"},{"name":"runLengthFor:","linesOfCode":4,"sourceCode":"runLengthFor: characterIndex \r\t\"Answer the count of characters remaining in run beginning with \r\tcharacterIndex.\"\r\r\t^runs runLengthAt: characterIndex"},{"name":"encompassParagraph:","linesOfCode":2,"sourceCode":"encompassParagraph: anInterval\r\r\t^string encompassParagraph: anInterval"},{"name":"storeOn:","linesOfCode":6,"sourceCode":"storeOn: aStream\r\r\taStream nextPutAll: '(Text string: ';\r\t\tstore: string;\r\t\tnextPutAll: ' runs: ';\r\t\tstore: runs;\r\t\tnextPut: $)"},{"name":"treeRenderSceneNodeWith:bounds:color:font:from:","linesOfCode":28,"sourceCode":"treeRenderSceneNodeWith: builder bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\t\"Method extracted from LazyListMorph\"\r\t| attrs useDefaultFont f itemBounds |\r\t\r\tattrs := self attributesAt: 1.\r\tuseDefaultFont := true.\r\tattrs\r\t\tdo: [:att | att\r\t\t\t\tforFontInStyle: TextStyle default\r\t\t\t\tdo: [:fon | useDefaultFont := false]].\r\tf := useDefaultFont\r\t\t\t\tifTrue: [ aMorph font ]\r\t\t\t\tifFalse: [ self fontAt: 1 withStyle: TextStyle default ].\r\titemBounds := drawBounds  withHeight: f height.\r\titemBounds := itemBounds align: itemBounds leftCenter with: drawBounds  leftCenter.\r\t\"center the item if the font height is different to that of our font\"\r\t^ builder\r\t\tstring: self\r\t\tin: itemBounds\r\t\tfont: (f emphasized: (self emphasisAt: 1))\r\t\tcolor: drawColor \r\t\tunderline: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 4)\r\t\t\t\t> 0\r\t\tunderlineColor: drawColor \r\t\tstrikethrough: ((self emphasisAt: 1)\r\t\t\t\tbitAnd: 16)\r\t\t\t\t> 0\r\t\tstrikethroughColor: drawColor"},{"name":"fontNumberAt:","linesOfCode":8,"sourceCode":"fontNumberAt: characterIndex \r\t\"Answer the fontNumber for characters in the run beginning at characterIndex.\"\r\t| attributes fontNumber |\r\tself size = 0 ifTrue: [^1].\t\"null text tolerates access\"\r\tattributes := runs at: characterIndex.\r\tfontNumber := 1.\r\tattributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber := att fontNumber]].\r\t^ fontNumber\r\t"},{"name":"isText","linesOfCode":2,"sourceCode":"isText\r\t^ true"},{"name":"copyWithoutExternalReferences","linesOfCode":4,"sourceCode":"copyWithoutExternalReferences\r\r\t^ self copy  \r\t\tremoveAttributesThat: [:attr | attr mayHaveExternalReferences ] replaceAttributesThat: [:attr | false ] by: [:attr | ];\r\t\tyourself."}],"meta":{"name":"Text class","instanceVariables":[],"methods":[{"name":"string:attribute:","linesOfCode":4,"sourceCode":"string: aString attribute: att\r\t\"Answer an instance of me whose characters are aString.\r\tatt is a TextAttribute.\"\r\r\t^self string: aString attributes: (Array with: att)"},{"name":"new:","linesOfCode":2,"sourceCode":"new: stringSize\r\r\t^self fromString: (String new: stringSize)"},{"name":"addAttribute:toArray:","linesOfCode":9,"sourceCode":"addAttribute: att toArray: others \r\t\"Add a new text attribute to an existing set\"\r\t\"NOTE: The use of reset and set in this code is a specific\r\thack for merging TextKerns.\"\r\tatt reset.\r\t^ Array streamContents:\r\t\t[:strm | others do:\r\t\t\t[:other | (att dominates: other) ifFalse: [strm nextPut: other]].\r\t\tatt set ifTrue: [strm nextPut: att]]"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\t^ self new\r\t\tfromSton: stonReader;\r\t\tyourself"},{"name":"fromUser","linesOfCode":5,"sourceCode":"fromUser\r\t\"Answer an instance of me obtained by requesting the user to type a string.\"\r\t\"Text fromUser\"\r\r\t^ self fromString:\r\t\t(UIManager default request: 'Enter text followed by carriage return')\r"},{"name":"string:runs:","linesOfCode":2,"sourceCode":"string: aString runs: anArray\r \r\t^self basicNew setString: aString setRuns: anArray"},{"name":"fromString:","linesOfCode":5,"sourceCode":"fromString: aString \r  \"Answer an instance of me whose characters are those of the argument, aString.\"\r\r  ^ self\r    string: aString\r    attributes:{ \"No default attributes\" }\r"},{"name":"initialFont:stringOrText:","linesOfCode":3,"sourceCode":"initialFont: aStrikeFont stringOrText: aStringOrText\r\t\"Answer an instance of me whose characters are aString.\"\r\t\r\t^Text string: aStringOrText asString attribute: (TextFontReference toFont: aStrikeFont)"},{"name":"streamContents:","linesOfCode":5,"sourceCode":"streamContents: blockWithArg \r\t| stream |\r\tstream := TextStream on: (self new: 400).\r\tblockWithArg value: stream.\r\t^ stream contents"},{"name":"string:attributes:","linesOfCode":4,"sourceCode":"string: aString attributes: atts\r\t\"Answer an instance of me whose characters are those of aString.\r\tatts is an array of TextAttributes.\"\r\r\t^self string: aString runs: (RunArray new: aString size withAll: atts)"}],"meta":null}},{"name":"ExampleForTestWithSharedPool","instanceVariables":[],"methods":[],"meta":{"name":"ExampleForTestWithSharedPool class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Semaphore","instanceVariables":[{"name":"excessSignals"}],"methods":[{"name":"critical:ifCurtailed:","linesOfCode":5,"sourceCode":"critical: mutuallyExcludedBlock ifCurtailed: terminationBlock\r\t\"Evaluate mutuallyExcludedBlock only if the receiver is not currently in \r\tthe process of running the critical: message. If the receiver is, evaluate \r\tmutuallyExcludedBlock after the other critical: message is finished.\"\r\t^self critical:[mutuallyExcludedBlock ifCurtailed: terminationBlock]\r"},{"name":"critical:","linesOfCode":26,"sourceCode":"critical: mutuallyExcludedBlock\t\t\t\r\t\"Evaluate mutuallyExcludedBlock only if the receiver is not currently in\r\tthe process of running the critical: message. If the receiver is, evaluate\r\tmutuallyExcludedBlock after the other critical: message is finished.\"\r\t\r\t\"We need to catch eventual interruptions very carefully.\r\tThe naive approach of just doing, e.g.,:\r\t\t\tself wait.\r\t\t\taBlock ensure: [self signal].\r\twill fail if the active process gets terminated while in the wait.\r\tHowever, the equally naive:\r\t\t\t[self wait.\r\t\t\taBlock value] ensure: [self signal].\r\twill fail too, since the active process may get interrupted while\r\tentering the ensured block and leave the semaphore signaled twice.\r\tTo avoid both problems we make use of the fact that interrupts only\r\toccur on sends (or backward jumps) and use an assignment (bytecode)\r\tright before we go into the wait primitive (which is not a real send and\r\ttherefore not interruptable either).\"\r\t\r\t| blockValue caught |\r\tcaught := false.\r\t[\r\t\tcaught := true.\r\t\tself wait.\r\t\tblockValue := mutuallyExcludedBlock value\r\t] ensure: [caught ifTrue: [self signal]].\r\t^blockValue\r"},{"name":"handleProcessTerminationOfWaitingContext:","linesOfCode":4,"sourceCode":"handleProcessTerminationOfWaitingContext: suspendedContext\r\r\t^suspendedContext compiledCode method == (Semaphore compiledMethodAt: #critical:) \r\t\tifTrue: [ suspendedContext home]\r\t\tifFalse: [ suspendedContext]"},{"name":"initSignals","linesOfCode":3,"sourceCode":"initSignals\r\t\"Consume any excess signals the receiver may have accumulated.\"\r\r\texcessSignals := 0."},{"name":"consumeAllSignals","linesOfCode":3,"sourceCode":"consumeAllSignals\r\t\"Consume any excess signals the receiver may have accumulated.\"\r\r\texcessSignals := 0."},{"name":"critical:ifLocked:","linesOfCode":13,"sourceCode":"critical: mutuallyExcludedBlock ifLocked: alternativeBlock\r\t\"Evaluate mutuallyExcludedBlock only if the receiver is not currently in \r\tthe process of running the critical: message. If the receiver is, evaluate \r\tmutuallyExcludedBlock after the other critical: message is finished.\"\r\t\r\t\"Note: The following is tricky and depends on the fact that the VM will not switch between \rprocesses while executing byte codes (process switches happen only in real sends). The following \rtest is written carefully so that it will result in bytecodes only.\"\r\r\texcessSignals == 0 \r\t\tifTrue: \r\t\t\t[ \"If we come here, then the semaphore was locked when the test executed. \r\t\t\tEvaluate the alternative block and answer its result.\"\r\t\t\t^alternativeBlock value ].\r\t^self critical: mutuallyExcludedBlock"},{"name":"criticalReleasingOnError:","linesOfCode":14,"sourceCode":"criticalReleasingOnError: mutuallyExcludedBlock\r\t\"This is like #critical: but releasing the lock if there is an exception in the block\"\t\r\t| blockValue caught |\r\tcaught := false.\r\t[\r\t\tcaught := true.\r\t\tself wait.\r\t\tblockValue := mutuallyExcludedBlock \r\t\t\ton: Exception \r\t\t\tdo: [ :e | caught ifTrue: [self signal]. \r\t\t\t\tcaught := false.\r\t\t\t\te pass.].\r\r\t] ensure: [caught ifTrue: [self signal]].\r\r\t^blockValue"},{"name":"wait","linesOfCode":10,"sourceCode":"wait\r\t\"Primitive. The active Process must receive a signal through the receiver \r\tbefore proceeding. If no signal has been sent, the active Process will be \r\tsuspended until one is sent. Essential. See Object documentation \r\twhatIsAPrimitive.\"\r\r\t<primitive: 86>\r\tself primitiveFailed\r\r\t\"excessSignals>0  \r\t\tifTrue: [excessSignals := excessSignals-1]  \r\t\tifFalse: [self addLastLink: Processor activeProcess suspend]\"\r"},{"name":"=","linesOfCode":2,"sourceCode":"= anObject\r\t^ self == anObject"},{"name":"wait:","linesOfCode":6,"sourceCode":"wait: aDuration\r\t\"Wait on this semaphore for up to the given time duration, then timeout. \r\tReturn true if the deadline expired, false otherwise.\"\r\t| d |\r\td := DelayWaitTimeout new setDelay: aDuration asMilliSeconds forSemaphore: self.\r\t^d wait"},{"name":"critical:ifError:","linesOfCode":14,"sourceCode":"critical: mutuallyExcludedBlock ifError: errorBlock\r\t\"Evaluate mutuallyExcludedBlock only if the receiver is not currently in \r\tthe process of running the critical: message. If the receiver is, evaluate \r\tmutuallyExcludedBlock after the other critical: message is finished.\"\r\t| blockValue hasError errObj |\r\thasError := false.\r\tself critical:[\r\t\tblockValue := mutuallyExcludedBlock onErrorDo: [ :err |\r\t\t\thasError := true.\r\t\t\terrObj := err.\r\t\t].\r\t].\r\thasError ifTrue: [ ^errorBlock cull: errObj ].\r\t^blockValue"},{"name":"resumeProcess:","linesOfCode":5,"sourceCode":"resumeProcess: aProcess\r\t\"Remove the given process from the list of waiting processes (if it's there) and resume it.  This is used when a process asked for its wait to be timed out.\"\r\r\t| process |\r\tprocess := self remove: aProcess ifAbsent: [nil].\r\tprocess ifNotNil: [process resume]."},{"name":"terminateProcess","linesOfCode":3,"sourceCode":"terminateProcess\r\t\"Terminate the process waiting on this semaphore, if any.\"\r\r\tself isEmpty ifFalse: [ self removeFirst terminate ]."},{"name":"signalAll","linesOfCode":3,"sourceCode":"signalAll\r \r\t[ self isEmpty ] \r\twhileFalse: [ self signal ]"},{"name":"isSignaled","linesOfCode":3,"sourceCode":"isSignaled\r\t\"Return true if this semaphore is currently signaled\"\r\t^excessSignals > 0"},{"name":"waitTimeoutSeconds:onCompletion:onTimeout:","linesOfCode":7,"sourceCode":"waitTimeoutSeconds: anInteger onCompletion: completionBlock onTimeout: timeoutBlock\r\t\"Wait on this semaphore for up to the given number of seconds, then timeout.\r\tIf the deadline expired execute timeoutBlock, otherwise execute completionBlock.\r\tReturn the value returned by the executed block.\"\r\t| d |\r\td := DelayWaitTimeout new setDelay: (anInteger * 1000 max: 0) forSemaphore: self.\r\t^d waitOnCompletion: completionBlock onTimeout: timeoutBlock"},{"name":"signal","linesOfCode":10,"sourceCode":"signal\r\t\"Primitive. Send a signal through the receiver. If one or more processes \r\thave been suspended trying to receive a signal, allow the first one to \r\tproceed. If no process is waiting, remember the excess signal. Essential. \r\tSee Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 85>\r\tself primitiveFailed\r\r\t\"self isEmpty    \r\t\tifTrue: [excessSignals := excessSignals+1]    \r\t\tifFalse: [Processor resume: self removeFirstLink]\"\r\r"},{"name":"waitTimeoutSeconds:","linesOfCode":4,"sourceCode":"waitTimeoutSeconds: anInteger\r\t\"Wait on this semaphore for up to the given number of seconds, then timeout.\r\tReturn true if the deadline expired, false otherwise.\"\r\t^self waitTimeoutMSecs: anInteger * 1000.\r"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^ self identityHash"},{"name":"waitTimeoutMSecs:","linesOfCode":6,"sourceCode":"waitTimeoutMSecs: anInteger\r\t\"Wait on this semaphore for up to the given number of milliseconds, then timeout. \r\tReturn true if the deadline expired, false otherwise.\"\r\t| d |\r\td := DelayWaitTimeout new setDelay: (anInteger max: 0) forSemaphore: self.\r\t^d wait"},{"name":"wait:onCompletion:onTimeout:","linesOfCode":7,"sourceCode":"wait: aDuration onCompletion: completionBlock onTimeout: timeoutBlock\r\t\"Wait on this semaphore for up to the given time duration, then timeout.\r\tIf the deadline expired execute timeoutBlock, otherwise execute completionBlock.\r\tReturn the value returned by the executed block.\"\r\t| d |\r\td := DelayWaitTimeout new setDelay: aDuration asMilliSeconds forSemaphore: self.\r\t^d waitOnCompletion: completionBlock onTimeout: timeoutBlock"}],"meta":{"name":"Semaphore class","instanceVariables":[],"methods":[{"name":"forMutualExclusion","linesOfCode":5,"sourceCode":"forMutualExclusion\r\t\"Answer an instance of me that contains a single signal. This new \r\tinstance can now be used for mutual exclusion (see the critical: message \r\tto Semaphore).\"\r\r\t^self new signal"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Answer a new instance of Semaphore that contains no signals.\"\r\r\t^self basicNew initSignals"}],"meta":null}},{"name":"Stack","instanceVariables":[],"methods":[{"name":"top","linesOfCode":3,"sourceCode":"top\r\t\"Answer the first element of the stack without removing it.\"\r\t\r\t^ self first"},{"name":"push:","linesOfCode":4,"sourceCode":"push: anObject \r\t\"Adds a new object of any kind on top of the stack.\"\r\t\r\tself addFirst: anObject.\r\t^ anObject"},{"name":"pop","linesOfCode":3,"sourceCode":"pop\r\t\"Returns the first element and remove it from the stack.\"\r\r\t^self removeFirst "}],"meta":{"name":"Stack class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FreeTypeCacheLinkedList","instanceVariables":[],"methods":[{"name":"add:after:","linesOfCode":9,"sourceCode":"add: link after: otherLink\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| savedLink |\r\tsavedLink := otherLink nextLink.\r\totherLink nextLink: link.\r\tlink nextLink: savedLink.\r\tsavedLink ifNotNil: [ savedLink previousLink: link ].\r\tlink previousLink: otherLink.\r\t^link\r\t\r\t"},{"name":"moveDown:","linesOfCode":13,"sourceCode":"moveDown: aLink\r\t|  e1 e2 e3 e4  |\r\t\r\t(e3 := aLink nextLink) ifNil:[^self].\r\te2 := aLink.\r\te4 := e3 nextLink.\r\te1 := e2 previousLink.\r\t\"swap e2 & e3\"\r\te1 ifNotNil:[e1 nextLink: e2].\r\te2 nextLink: e3.\r\te3 nextLink: e4.\r\te4 ifNotNil:[e4 previousLink: e3].\r\te3 previousLink: e2.\r\te2 previousLink: e1\r\r\t"},{"name":"addLast:","linesOfCode":9,"sourceCode":"addLast: aLink \r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\r\tself isEmpty \r\t\tifTrue: [ ^firstLink := lastLink := aLink ].\r\taLink previousLink: lastLink.\r\taLink nextLink: nil.\r\tlastLink ifNotNil: [ lastLink nextLink: aLink ].\r\tlastLink := aLink.\r\t^aLink"},{"name":"addFirst:","linesOfCode":9,"sourceCode":"addFirst: aLink \r\t\"Add aLink to the beginning of the receiver's list. Answer aLink.\"\r\r\tself isEmpty \r\t\tifTrue: [ ^lastLink :=firstLink := aLink ].\r\taLink nextLink: firstLink.\r\taLink previousLink: nil.\r\tfirstLink ifNotNil: [ firstLink previousLink: aLink ].\r\tfirstLink := aLink.\r\t^aLink"},{"name":"removeLast","linesOfCode":18,"sourceCode":"removeLast\r\t\"Remove the first element and answer it. If the receiver is empty, create \r\tan error notification.\"\r\r\t| oldLink |\r\tself emptyCheck.\r\toldLink := lastLink.\r\toldLink nextLink: nil.\r\tlastLink == firstLink \r\t\tifTrue:[\r\t\t\tlastLink := firstLink := nil.\r\t\t\toldLink previousLink: nil.\r\t\t\t^oldLink].\r\tlastLink := oldLink previousLink.\r\tlastLink \r\t\tifNil: [firstLink := lastLink := nil]\r\t\tifNotNil:[lastLink nextLink: nil].\r\toldLink previousLink: nil.\r\t^oldLink"},{"name":"remove:ifAbsent:","linesOfCode":11,"sourceCode":"remove: aLink ifAbsent: aBlock  \r\t| prev next  |\r\r\tprev := aLink previousLink.\r\tnext := aLink nextLink.\r\tprev ifNotNil: [prev nextLink: next].\r\tnext ifNotNil: [next previousLink: prev].\r\taLink == firstLink ifTrue:[firstLink := next].\r\taLink == lastLink ifTrue:[lastLink := prev].\r\taLink nextLink: nil.\r\taLink previousLink: nil.\t\t\r\t^aLink"},{"name":"add:before:","linesOfCode":11,"sourceCode":"add: link before: otherLink\r\r\t| savedLink |\r\tfirstLink == otherLink ifTrue: [ ^self addFirst: link ].\r\totherLink \r\t\tifNotNil:[\r\t\t\tsavedLink := otherLink previousLink.\r\t\t\tlink nextLink: otherLink.\r\t\t\tlink previousLink: savedLink.\r\t\t\totherLink previousLink: link.\r\t\t\tsavedLink ifNotNil: [ savedLink nextLink: link ]].\r\t^ self errorNotFound: otherLink"},{"name":"removeFirst","linesOfCode":18,"sourceCode":"removeFirst\r\t\"Remove the first element and answer it. If the receiver is empty, create \r\tan error notification.\"\r\r\t| oldLink |\r\tself emptyCheck.\r\toldLink := firstLink.\r\toldLink previousLink: nil.\r\tlastLink == firstLink \r\t\tifTrue:[\r\t\t\tlastLink := firstLink := nil.\r\t\t\toldLink nextLink: nil.\r\t\t\t^oldLink].\r\tfirstLink := oldLink nextLink.\r\tfirstLink \r\t\tifNil: [firstLink := lastLink := nil]\r\t\tifNotNil: [firstLink previousLink: nil].\r\toldLink nextLink: nil.\r\t^oldLink"}],"meta":{"name":"FreeTypeCacheLinkedList class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ObjectFinalizerCollection","instanceVariables":[],"methods":[{"name":"finalize","linesOfCode":3,"sourceCode":"finalize\r\t\"Finalize all elements in this collection. The elements are expected to be ObjectFinalizers, but can be any object which understands #finalize.\"\r\r\tself do: #finalize"},{"name":"hasMultipleExecutors","linesOfCode":2,"sourceCode":"hasMultipleExecutors\r\t^ true"}],"meta":{"name":"ObjectFinalizerCollection class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SortedCollection","instanceVariables":[{"name":"sortBlock"}],"methods":[{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\t^ super insert: newObject before: (self indexForInserting: newObject)"},{"name":"intersection:","linesOfCode":4,"sourceCode":"intersection: aCollection\r\t^ (self class sortBlock: sortBlock)\r\t\taddAll: (self asSet intersection: aCollection);\r\t\tyourself."},{"name":",","linesOfCode":5,"sourceCode":", otherCollection\r\t| newSortedCollection |\r\tnewSortedCollection := super , otherCollection.\r\tnewSortedCollection sortBlock: self sortBlock .\r\t^newSortedCollection "},{"name":"addFirst:","linesOfCode":2,"sourceCode":"addFirst: newObject\r\tself shouldNotImplement"},{"name":"indexForInserting:","linesOfCode":16,"sourceCode":"indexForInserting: newObject\r\r\t| index low high |\r\tlow := firstIndex.\r\thigh := lastIndex.\r\tsortBlock \r\t\tifNil: [[index := high + low // 2.  low > high]\r\t\t\twhileFalse: \r\t\t\t\t[((array at: index) <= newObject)\r\t\t\t\t\tifTrue: [low := index + 1]\r\t\t\t\t\tifFalse: [high := index - 1]]]\r\t\tifNotNil: [[index := high + low // 2.  low > high]\r\t\t\twhileFalse: \r\t\t\t\t[(sortBlock value: (array at: index) value: newObject)\r\t\t\t\t\tifTrue: [low := index + 1]\r\t\t\t\t\tifFalse: [high := index - 1]]].\r\t^low"},{"name":"defaultSort:to:","linesOfCode":45,"sourceCode":"defaultSort: i to: j \r\t\"Sort elements i through j of self to be nondescending according to\r\tsortBlock.\"\t\"Assume the default sort block ([:x :y | x <= y]).\"\r\r\t| di dij dj tt ij k l n |\r\t\"The prefix d means the data at that index.\"\r\t(n := j + 1  - i) <= 1 ifTrue: [^self].\t\"Nothing to sort.\" \r\t \"Sort di,dj.\"\r\tdi := array at: i.\r\tdj := array at: j.\r\t(di <= dj) \"i.e., should di precede dj?\"\r\t\tifFalse: \r\t\t\t[array swap: i with: j.\r\t\t\t tt := di.\r\t\t\t di := dj.\r\t\t\t dj := tt].\r\tn > 2\r\t\tifTrue:  \"More than two elements.\"\r\t\t\t[ij := (i + j) // 2.  \"ij is the midpoint of i and j.\"\r\t\t\t dij := array at: ij.  \"Sort di,dij,dj.  Make dij be their median.\"\r\t\t\t (di <= dij) \"i.e. should di precede dij?\"\r\t\t\t   ifTrue: \r\t\t\t\t[(dij <= dj) \"i.e., should dij precede dj?\"\r\t\t\t\t  ifFalse: \r\t\t\t\t\t[array swap: j with: ij.\r\t\t\t\t\t dij := dj]]\r\t\t\t   ifFalse:  \"i.e. di should come after dij\"\r\t\t\t\t[array swap: i with: ij.\r\t\t\t\t dij := di].\r\t\t\tn > 3\r\t\t\t  ifTrue:  \"More than three elements.\"\r\t\t\t\t[\"Find k>i and l<j such that dk,dij,dl are in reverse order.\r\t\t\t\tSwap k and l.  Repeat this procedure until k and l pass each other.\"\r\t\t\t\t k := i.\r\t\t\t\t l := j.\r\t\t\t\t [[l := l - 1.  k <= l and: [dij <= (array at: l)]]\r\t\t\t\t   whileTrue.  \"i.e. while dl succeeds dij\"\r\t\t\t\t  [k := k + 1.  k < j and: [(array at: k) <= dij]]\r\t\t\t\t   whileTrue.  \"i.e. while dij succeeds dk\"\r\t\t\t\t  k <= l]\r\t\t\t\t   whileTrue:\r\t\t\t\t\t[array swap: k with: l]. \r\t\"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\r\tthrough dj.  Sort those two segments.\"\r\t\t\t\tself defaultSort: i to: l.\r\t\t\t\tself defaultSort: k to: j]]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my elements as the argument. Collect the \r\tresulting values into an OrderedCollection. Answer the new collection.\r\tWe cannot assume that the result is sorted, because aBlock can transform the \r\telements in arbitrary ways.  Thus, we must override the superclass in order\r\tto produce an OrderedCollection instead of a SortedCollection.\"\r\r\t| newCollection | \r\tnewCollection := OrderedCollection new: self size.\r\tself do: [:each | newCollection addLast: (aBlock value: each)].\r\t^ newCollection"},{"name":"flatCollect:","linesOfCode":5,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t^ self flatCollect: aBlock as: OrderedCollection"},{"name":"=","linesOfCode":7,"sourceCode":"= aSortedCollection\r\t\"Answer true if my and aSortedCollection's species are the same,\r\tand if our blocks are the same, and if our elements are the same.\"\r\r\tself species = aSortedCollection species ifFalse: [ ^ false ].\r\t^ sortBlock = aSortedCollection sortBlock\r\t\tifTrue: [ super = aSortedCollection ]\r\t\tifFalse: [ false ]"},{"name":"median","linesOfCode":9,"sourceCode":"median\r\t\"Return the middle element, or as close as we can get.\"\r\t\"{1 . 2 . 3 . 4 . 5} asSortedCollection  median >>> 3\"\r\t\r\t| size middle |\r \tsize := self size.\r \tmiddle := (size + 1) // 2.\r \t^ size even\r\t\t\tifTrue: [ ((self at: middle) + (self at: middle + 1)) / 2 ]\r\t\t\tifFalse: [ self at: middle ]"},{"name":"sort:","linesOfCode":5,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r \r \tsuper sort: aSortBlock.\r \tsortBlock := aSortBlock"},{"name":"addAll:","linesOfCode":7,"sourceCode":"addAll: aCollection\r\taCollection size > (self size // 3)\r\t\tifTrue:\r\t\t\t[aCollection do: [:each | self addLast: each].\r\t\t\tself reSort]\r\t\tifFalse: [aCollection do: [:each | self add: each]].\r\t^ aCollection"},{"name":"groupedBy:","linesOfCode":10,"sourceCode":"groupedBy: aBlock\r\t\"Answer a dictionary whose keys are the result of evaluating aBlock for all my elements, and the value for each key is the selection of my elements that evaluated to that key. Uses species.\"\r\t| groups |\r\tgroups := OrderedDictionary new.\r\tself do: [ :each |\r\t\t(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].\r\tgroups associationsDo: [ :association |\r\t\t\t\"need to make sure to create the collection with the same sortblock\"\r\t\t\tassociation value: (self copyEmpty addAll: association value ; yourself) ].\r\t^ groups"},{"name":"reSort","linesOfCode":2,"sourceCode":"reSort\r\tself sort: firstIndex to: lastIndex"},{"name":"sort:to:","linesOfCode":46,"sourceCode":"sort: i to: j \r\t\"Sort elements i through j of self to be nondescending according to\r\tsortBlock.\"\r\r\t| di dij dj tt ij k l n |\r\tsortBlock ifNil: [^self defaultSort: i to: j].\r\t\"The prefix d means the data at that index.\"\r\t(n := j + 1  - i) <= 1 ifTrue: [^self].\t\"Nothing to sort.\" \r\t \"Sort di,dj.\"\r\tdi := array at: i.\r\tdj := array at: j.\r\t(sortBlock value: di value: dj) \"i.e., should di precede dj?\"\r\t\tifFalse: \r\t\t\t[array swap: i with: j.\r\t\t\t tt := di.\r\t\t\t di := dj.\r\t\t\t dj := tt].\r\tn > 2\r\t\tifTrue:  \"More than two elements.\"\r\t\t\t[ij := (i + j) // 2.  \"ij is the midpoint of i and j.\"\r\t\t\t dij := array at: ij.  \"Sort di,dij,dj.  Make dij be their median.\"\r\t\t\t (sortBlock value: di value: dij) \"i.e. should di precede dij?\"\r\t\t\t   ifTrue: \r\t\t\t\t[(sortBlock value: dij value: dj) \"i.e., should dij precede dj?\"\r\t\t\t\t  ifFalse: \r\t\t\t\t\t[array swap: j with: ij.\r\t\t\t\t\t dij := dj]]\r\t\t\t   ifFalse:  \"i.e. di should come after dij\"\r\t\t\t\t[array swap: i with: ij.\r\t\t\t\t dij := di].\r\t\t\tn > 3\r\t\t\t  ifTrue:  \"More than three elements.\"\r\t\t\t\t[\"Find k>i and l<j such that dk,dij,dl are in reverse order.\r\t\t\t\tSwap k and l.  Repeat this procedure until k and l pass each other.\"\r\t\t\t\t k := i.\r\t\t\t\t l := j.\r\t\t\t\t [[l := l - 1.  k <= l and: [sortBlock value: dij value: (array at: l)]]\r\t\t\t\t   whileTrue.  \"i.e. while dl succeeds dij\"\r\t\t\t\t  [k := k + 1.  k < j and: [sortBlock value: (array at: k) value: dij]]\r\t\t\t\t   whileTrue.  \"i.e. while dij succeeds dk\"\r\t\t\t\t  k <= l]\r\t\t\t\t   whileTrue:\r\t\t\t\t\t[array swap: k with: l]. \r\t\"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\r\tthrough dj.  Sort those two segments.\"\r\t\t\t\tself sort: i to: l.\r\t\t\t\tself sort: k to: j]]"},{"name":"insert:before:","linesOfCode":2,"sourceCode":"insert: anObject before: spot\r\tself shouldNotImplement"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver without any of the receiver's elements.\"\r\r\t^self species sortBlock: sortBlock"},{"name":"sortBlock","linesOfCode":4,"sourceCode":"sortBlock\r\t\"Answer the blockContext which is the criterion for sorting elements of \r\tthe receiver.\"\r\r\t^sortBlock"},{"name":"join:","linesOfCode":4,"sourceCode":"join: aCollection \r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"Curiously addAllLast: does not trigger a reSort, so we must do it here.\"\r\t^ (super join: aCollection) reSort; yourself\r"},{"name":"sortBlock:","linesOfCode":6,"sourceCode":"sortBlock: aBlock \r\t\"Make the argument, aBlock, be the criterion for ordering elements of the \r\treceiver.\"\r\r\tsortBlock := aBlock.\r\t\"sortBlocks with side effects may not work right\"\r\tself size > 0 ifTrue: [self reSort]"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: anInteger put: anObject\r\tself shouldNotImplement"}],"meta":{"name":"SortedCollection class","instanceVariables":[],"methods":[{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock \r\t\"Answer an instance of me such that its elements are sorted according to the criterion specified in aBlock.\"\r\r\t^ self sortUsing: aBlock"},{"name":"sortUsing:","linesOfCode":3,"sourceCode":"sortUsing: aBlockOrSortFunction\r\t\"Answer an instance of me such that its elements are sorted according to the criterion specified by the block or sort function.\"\r\r\t^ self new sortBlock: aBlockOrSortFunction"}],"meta":null}},{"name":"WeakOrderedCollection","instanceVariables":[],"methods":[],"meta":{"name":"WeakOrderedCollection class","instanceVariables":[],"methods":[{"name":"arrayType","linesOfCode":2,"sourceCode":"arrayType\r\t^ WeakArray"}],"meta":null}},{"name":"OCLiteralList","instanceVariables":[{"name":"equalitySet"}],"methods":[{"name":"literalIndexOf:ifAbsent:","linesOfCode":7,"sourceCode":"literalIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer the result of evaluating the argument, \r\texceptionBlock.\"\r\t1 to: self size do:\r\t\t[:i | ((self at: i) literalEqual: anElement) ifTrue: [^ i]].\r\t^ exceptionBlock value"},{"name":"addLast:","linesOfCode":6,"sourceCode":"addLast: object\r\t\"Only add if not already in list\"\r\r\t(equalitySet includes: object) ifTrue: [^ object].\r\tequalitySet add: object.\r\tsuper addLast: object.\r\t^ object\r"},{"name":"setCollection:","linesOfCode":3,"sourceCode":"setCollection: anArray\r\r\tsuper setCollection: anArray.\r\tequalitySet := OCLiteralSet new: anArray size.\r"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":4,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\r\tstart to: self size do:\r\t\t[:index | ((self at: index) literalEqual: anElement) ifTrue: [^ index]].\r\t^ exceptionBlock value"}],"meta":{"name":"OCLiteralList class","instanceVariables":[],"methods":[],"meta":null}},{"name":"GLMMultiValue","instanceVariables":[],"methods":[{"name":"asGlamorousMultiValue","linesOfCode":2,"sourceCode":"asGlamorousMultiValue\r\t^ self"},{"name":"asGlamorousArray","linesOfCode":3,"sourceCode":"asGlamorousArray \r\t \r\t^self asArray"}],"meta":{"name":"GLMMultiValue class","instanceVariables":[],"methods":[],"meta":null}},{"name":"RSGroup","instanceVariables":[{"name":"shapeFromModelCache"}],"methods":[{"name":"shapeFromModelCache","linesOfCode":4,"sourceCode":"shapeFromModelCache\r\t\"Define a cache for the element lookup from models\"\r\tshapeFromModelCache ifNil: [ shapeFromModelCache := Dictionary new ].\r\t^ shapeFromModelCache"},{"name":"when:send:to:","linesOfCode":2,"sourceCode":"when: anAnnouncementClass send: aSelector to: anObject\r\tself do: [ :shape | shape when: anAnnouncementClass send: aSelector to: anObject]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: shape\r\tself resetShapeFromModelCache.\r\t^ super add: shape"},{"name":"when:do:","linesOfCode":2,"sourceCode":"when: event do: block\r\tself do: [ :shape | shape when: event do: block ]"},{"name":"shapesFromModel:","linesOfCode":21,"sourceCode":"shapesFromModel: anObject\r\t\"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil.\r\rFor example:\r-=-=-=-=-=-=-=-=-=\rg := RSGroup new.\rg add: (RSBox new model: 'hello').\rg add: (RSEllipse new model: 'world').\rg shapesFromModel: 'hello' \r-=-=-=-=-=-=-=-=-=\r=> a RSGroup(a RSBox(hello))\r\t\"\t\r\r\t| t key |\r\tself shapeFromModelCache at: anObject ifPresent: [ :v | v isCollection ifTrue: [ ^ v ] ].\r\r\t\"We have this line because of a bug of the implementation of CompiledMethod>>#=\"\r\tt := (anObject class == CompiledMethod) \r\t\t\t\tifTrue: [ self select: [ :el | el model == anObject ] ]\r\t\t\t\tifFalse: [ self select: [ :el | el model = anObject ] ].\r\r\t\"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key\"\r\tkey := anObject isNil ifTrue: [ 'KeyForNilObjects' ] ifFalse: [ anObject ].\r\tself shapeFromModelCache at: key put: t.\r\t^ t"},{"name":"asShapeFor:","linesOfCode":22,"sourceCode":"asShapeFor: model\r\t\"Convert a RSGroup into a shape, and tis shape has a model. Pretty convenient to create a group of shapes as a composite.\rConsider the following example:\r\r-=-=-=-=-=-=-=-=-=-=-=-=\rc := RSCanvas new.\r\rclasses := Collection withAllSubclasses.\relements := classes collect: [ :cls |\r\tg := RSGroup new\r\t\tadd: (RSLabel new text: cls name);\r\t\tadd: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );\r\t\tyourself.\r\tRSVerticalLineLayout new center; on: g.\r\tg asShapeFor: cls ] as: RSGroup.\r\rc addAll: elements.\relements @ RSHighlightable defaultRed.\rRSGridLayout on: elements.\rc @ RSCanvasController\r-=-=-=-=-=-=-=-=-=-=-=-=\r\"\r\t^ RSComposite new \r\t\tmodel: model;\r\t\tshapes: self\r\t\tyourself"},{"name":"asShape","linesOfCode":19,"sourceCode":"asShape\r\t\"Convert a RSGroup into a shape. Pretty convenient to create a group of shapes as a composite.\rConsider the following example:\r\r-=-=-=-=-=-=-=-=-=-=-=-=\rc := RSCanvas new.\r\rclasses := Collection withAllSubclasses.\relements := classes collect: [ :cls |\r\tg := RSGroup new\r\t\tadd: (RSLabel new text: cls name);\r\t\tadd: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );\r\t\tyourself.\r\tRSVerticalLineLayout new center; on: g.\r\tg asShape ] as: RSGroup.\r\rc addAll: elements.\relements @ RSHighlightable defaultRed.\rRSGridLayout on: elements.\rc @ RSCanvasController\r-=-=-=-=-=-=-=-=-=-=-=-=\r\r\"\r\t^ self asShapeFor: nil"},{"name":"gtInspectorViewIn:","linesOfCode":12,"sourceCode":"gtInspectorViewIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\t\r\tcomposite roassal3\r\t\ttitle: ['Canvas'];\r\t\tinitializeCanvas: [ | canvas |\r\t\t\tcanvas := RSCanvas new\r\t\t\t\taddShape: (RSComposite new\r\t\t\t\t\tshapes: self;\r\t\t\t\t\tyourself).\r\t\t\tcanvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].\r\t\t\tcanvas ]\r\t\t"},{"name":"addAll:","linesOfCode":3,"sourceCode":"addAll: shapes\r\tself resetShapeFromModelCache.\r\t^ super addAll: shapes"},{"name":"pushBack","linesOfCode":3,"sourceCode":"pushBack \r\t\"Push back all the shapes contained in the group\"\r\tself do: [ :each | each pushBack ]"},{"name":"encompassingRectangle","linesOfCode":4,"sourceCode":"encompassingRectangle\r\t^ self\r\t\tifEmpty: [ (0 @ 0) corner: (0 @ 0) ]\r\t\tifNotEmpty: [ Rectangle merging: (self collect: #encompassingRectangle) ]"},{"name":"position","linesOfCode":2,"sourceCode":"position\r\t^ self encompassingRectangle center"},{"name":"shapesFromModels:","linesOfCode":9,"sourceCode":"shapesFromModels: objects\r\t\"Return elements that corresponds to the objects provided as parameter. If none is found, then return an empty collection\"\r\t| answer t |\r\tself assert: [ objects isCollection ] description: 'Provide a set of shapes instead of one single shape'. \r\tanswer := RSGroup new.\r\tobjects do: [ :o |\r\t\tt := self shapesFromModel: o.\r\t\tt notNil ifTrue: [ answer addAll: t ] ].\r\t^ answer"},{"name":"asGroup","linesOfCode":2,"sourceCode":"asGroup\r\t^ self"},{"name":"models:","linesOfCode":5,"sourceCode":"models: someModels\r\t\"Set the model of each shapes contained in the collection. The size of the group must be the same than the someModels collection\"\r\tself assert: [ someModels isCollection ] description: 'Must provide a collection'.\r\tself assert: [ self size = someModels size ] description: 'The argument must of the same size then the group'.\r\tself with: someModels do: [ :s :m | s model: m ]"},{"name":"translateTo:","linesOfCode":4,"sourceCode":"translateTo: aPosition\r\t| center |\r\tcenter := self encompassingRectangle floatCenter.\r\tself translateBy: aPosition - center"},{"name":"translateBy:","linesOfCode":2,"sourceCode":"translateBy: delta\r\tself do: [ :e | e translateBy: delta ]"},{"name":"translucent","linesOfCode":3,"sourceCode":"translucent\r\t\"Make all shapes in the group as translucent\"\r\tself do: [ :s | s color: s color translucent ]"},{"name":"width","linesOfCode":2,"sourceCode":"width \r\t^ self extent x"},{"name":"accept:","linesOfCode":2,"sourceCode":"accept: aVisitor\r\taVisitor visitGroup: self"},{"name":"extent","linesOfCode":2,"sourceCode":"extent\r\t^ self encompassingRectangle extent"},{"name":"shapeFromModel:","linesOfCode":21,"sourceCode":"shapeFromModel: anObject\r\t\"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil\r\t\r```Smalltalk\rg := RSGroup new.\rg add: (RSBox new model: 'hello').\rg add: (RSEllipse new model: 'world').\rg shapeFromModel: 'hello'\r```\r=> a RSBox(hello))\r\r\t\"\r\t| t |\r\tself shapeFromModelCache \r\t\tat: anObject \r\t\tifPresent: [ :v |\r\t\t\tv isCollection ifFalse: [ ^ v ] ].\r\r\t\"We have this line because of a bug of the implementation of CompiledMethod>>#=\"\r\tt := (anObject class == CompiledMethod) \r\t\tifTrue: [ self detect: [ :el | el model == anObject ] ifNone: [ nil ] ]\r\t\tifFalse: [ self detect: [ :el | el model = anObject ] ifNone: [ nil ] ].\r\t\r\tself shapeFromModelCache at: anObject put: t.\r\t^ t"},{"name":"@","linesOfCode":13,"sourceCode":"@ interaction\r\t\"Apply an interaction on each shape contained in the group.\r\t\rFor example:\r```Smalltalk\rg := RSGroup new.\rg add: (RSBox new size: 10; model: 'hello').\rg add: (RSBox new size: 10; model: 'World').\rRSHorizontalLineLayout on: g.\rg @ RSPopup.\rc := RSCanvas new.\rc addAll: g.\rc\r```\r\"\r\tself do: [ :e | e @ interaction ]."},{"name":"resetShapeFromModelCache","linesOfCode":3,"sourceCode":"resetShapeFromModelCache\r\t\"Reset the cache\"\r\tshapeFromModelCache := nil"},{"name":"height","linesOfCode":2,"sourceCode":"height \r\t^ self extent y"},{"name":"pushFront","linesOfCode":2,"sourceCode":"pushFront\r\tself do: #pushFront"}],"meta":{"name":"RSGroup class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LayeredProtocol","instanceVariables":[{"name":"properties"}],"methods":[{"name":"isConnected","linesOfCode":2,"sourceCode":"isConnected\r\r\t^self endpoint isConnected"},{"name":"pop","linesOfCode":3,"sourceCode":"pop\r\t\"Remove the head of the stack.\"\r\r\t^self removeFirst"},{"name":"propertyAt:put:","linesOfCode":2,"sourceCode":"propertyAt: aKey put: aValue\r\r\t^properties at: aKey put: aValue"},{"name":"head","linesOfCode":3,"sourceCode":"head\r\t\"Answer the head of the stack.\"\r\r\t^self first"},{"name":"note:with:","linesOfCode":3,"sourceCode":"note: aSymbol with: anObject\r\t\"Inform my members that something has happened.\"\r\r\tself do: [:proto | proto note: aSymbol with: anObject]"},{"name":"push:","linesOfCode":3,"sourceCode":"push: aProtocol\r\t\"Push a new protocol onto the head of the stack.\"\r\r\tself addFirst: aProtocol"},{"name":"run","linesOfCode":2,"sourceCode":"run\r\r\tself do: [:proto | proto run]"},{"name":"install","linesOfCode":8,"sourceCode":"install\r\r\t| prev |\r\tprev := nil.\r\tself do: [:this |\r\t\tthis session: self.\r\t\tprev isNil ifFalse: [this up: prev.  prev down: this].\r\t\tthis install.\r\t\tprev := this]"},{"name":"tail","linesOfCode":3,"sourceCode":"tail\r\t\"Answer the tail of the stack.\"\r\r\t^self last"},{"name":"endpoint","linesOfCode":2,"sourceCode":"endpoint\r\r\t^self last"},{"name":"propertyAt:ifAbsent:","linesOfCode":2,"sourceCode":"propertyAt: aKey ifAbsent: aBlock\r\r\t^properties at: aKey ifAbsent: aBlock"},{"name":"propertyAt:","linesOfCode":2,"sourceCode":"propertyAt: aKey\r\r\t^properties at: aKey ifAbsent: []"},{"name":"initializeProperties","linesOfCode":2,"sourceCode":"initializeProperties\r\r\tproperties := IdentityDictionary new"},{"name":"addDown:","linesOfCode":2,"sourceCode":"addDown: proto\r\r\t^self addLast: proto"}],"meta":{"name":"LayeredProtocol class","instanceVariables":[],"methods":[{"name":"on:","linesOfCode":2,"sourceCode":"on: proto\r\r\t^self new push: proto"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\r\t\"I am a collection so I do not call #initialize automatically\"\r\r\t^ super new \tinitializeProperties"},{"name":"example","linesOfCode":12,"sourceCode":"example\r\t\"Send 42 down a stack and then reflect it back up.\"\r\t<example>\r\t<ignoreForCoverage>\r\r\t(ProtocolAdaptor new reflect asProtocolStack\r\t\tpush: ProtocolAdaptor new trace;\r\t\tpush: ProtocolAdaptor new trace;\r\t\tpush: (ProtocolAdaptor new trace\r\t\t\tupBlock: [:arg | Transcript cr; show: 'ping '; show: arg printString]);\r\t\tinstall;\r\t\trun;\r\t\tfirst) downcall: 42"}],"meta":null}},{"name":"RWElementList","instanceVariables":[{"name":"elementFromModelCache"}],"methods":[{"name":"elementFromModelCache","linesOfCode":4,"sourceCode":"elementFromModelCache\r\t\"Define a cache for the element lookup from models\"\r\telementFromModelCache ifNil: [ elementFromModelCache := Dictionary new ].\r\t^ elementFromModelCache"},{"name":"addInteraction:","linesOfCode":2,"sourceCode":"addInteraction: anInteraction\r\t^ self do: [ :el | el @ anInteraction  ]"},{"name":"elementFromModel:","linesOfCode":17,"sourceCode":"elementFromModel: anObject\r\t\"Return an element that corresponds to the object provided as parameter. If none is found, then return nil\"\r\t\r\t| t key|\r\tself elementFromModelCache \r\t\tat: anObject \r\t\tifPresent: [ :v | v isCollection ifFalse: [ ^ v ] ].\r\r\t\"We have this line because of a bug of the implementation of CompiledMethod>>#=\"\r\tt := (anObject class == CompiledMethod) \r\t\tifTrue: [ [ :el | el model == anObject ] ]\r\t\tifFalse: [ [ :el | el model = anObject ] ].\r\tt :=  self detect: t ifNone: [ nil ].\r\t\r\t\"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key\"\r\tkey := anObject isNil \r\t\tifTrue: [ #KeyForNilObjects ]\r\t\tifFalse: [ anObject ].\r\tself elementFromModelCache at: key put: t.\r\t^ t"},{"name":"elementFromModelCache:","linesOfCode":2,"sourceCode":"elementFromModelCache: anObject\r\telementFromModelCache := anObject"},{"name":"@","linesOfCode":2,"sourceCode":"@ anInteraction\r\t^ self addInteraction: anInteraction"},{"name":"asRWElementList","linesOfCode":2,"sourceCode":"asRWElementList\r\t^ self"}],"meta":{"name":"RWElementList class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WDCOctTree","instanceVariables":[],"methods":[{"name":"nodeClass","linesOfCode":2,"sourceCode":"nodeClass\r\t^ WDCOctTreeNode"}],"meta":{"name":"WDCOctTree class","instanceVariables":[],"methods":[],"meta":null}},{"name":"AnnouncementSetWithExclusions","instanceVariables":[{"name":"exclusions"}],"methods":[{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\r\tsuper initialize.\r\texclusions := OrderedCollection new"},{"name":"handlesAnnouncement:","linesOfCode":6,"sourceCode":"handlesAnnouncement: anAnnouncement\r\t\"Return true when I will handle anAnnouncement.\r\tI extend my superclass behavior by explicitly \r\tnot handling the exclusions.\"\r\r\t^ (super handlesAnnouncement: anAnnouncement) \r\t\t\tand: [ exclusions noneSatisfy: [ :each | each handlesAnnouncement: anAnnouncement ] ]"},{"name":"addExclusion:","linesOfCode":4,"sourceCode":"addExclusion: anAnnouncement\r\t\"Add anAnnouncement as an exclusion to me.\r\tI will explicitly not handle my exclusion announcements.\"\r\t\r\t^ exclusions add: anAnnouncement "},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: aNumber\r\r\tsuper initialize: aNumber.\r\texclusions := OrderedCollection new"}],"meta":{"name":"AnnouncementSetWithExclusions class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakIdentitySet","instanceVariables":[],"methods":[{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject identityHash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element enclosedElement == anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"scanForEmptySlotFor:","linesOfCode":9,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"WeakIdentitySet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SystemDictionary","instanceVariables":[{"name":"cachedClassNames"},{"name":"cachedNonClassNames"},{"name":"cachedBehaviors"},{"name":"reservedVariables"}],"methods":[{"name":"at:put:","linesOfCode":8,"sourceCode":"at: aKey put: anObject \r\t\"Override from Dictionary to check Undeclared and fix up\r\treferences to undeclared variables.\"\r\t\r\t(self includesKey: aKey) ifFalse: \r\t\t[self declare: aKey from: Undeclared.\r\t\tself flushClassNameCache].\r\tsuper at: aKey put: anObject.\r\t^ anObject"},{"name":"bindingOf:","linesOfCode":3,"sourceCode":"bindingOf: varName\r\t\"SystemDictionaries includes symbols only\"\r\t\r\t^ super bindingOf: varName asSymbol"},{"name":"classNamed:","linesOfCode":2,"sourceCode":"classNamed: className \r\t^self classOrTraitNamed: className."},{"name":"allClasses","linesOfCode":3,"sourceCode":"allClasses  \r\t\"Return all the class defines in the Smalltalk SystemDictionary\"\r\r\t^ self classNames collect: [:name | self at: name]"},{"name":"allClassesAndTraits","linesOfCode":3,"sourceCode":"allClassesAndTraits\r\t\"Return all the classes and traits defined in the Smalltalk SystemDictionary\"\r\r\t^ self classAndTraitNames collect: [:each | self at: each]"},{"name":"poolUsers","linesOfCode":24,"sourceCode":"poolUsers\r\t\"Answer a dictionary of pool name -> classes that refer to it.\r\tAlso includes any globally know dictionaries (such as\r\tSmalltalk, Undeclared etc) which although not strictly\r\taccurate is potentially useful information\"\r\r\t\"Smalltalk globals poolUsers\"\r\r\t| poolUsers |\r\tpoolUsers := Dictionary new.\r\tself\r\t\tkeysDo: [ :k | \r\t\t\t| pool refs |\r\t\t\t\"yes, using isKindOf: is tacky but for reflective code like\r\t\t\tthis it is very useful. If you really object you can:-\r\t\t\ta) go boil your head.\r\t\t\tb) provide a better answer.\r\t\t\tyour choice.\"\r\t\t\t(((pool := self at: k) isKindOf: Dictionary) or: [ pool isKindOf: SharedPool class ])\r\t\t\t\tifTrue: [ \r\t\t\t\t\trefs := self systemNavigation allClasses\r\t\t\t\t\t\tselect: [ :c | c sharedPools identityIncludes: pool ]\r\t\t\t\t\t\tthenCollect: [ :c | c name ].\r\t\t\t\t\trefs add: (self systemNavigation allReferencesTo: (self associationAt: k)).\r\t\t\t\t\tpoolUsers at: k put: refs ] ].\r\t^ poolUsers"},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\t\"Do nothing\""},{"name":"printElementsOn:","linesOfCode":2,"sourceCode":"printElementsOn: aStream\r\taStream nextPutAll:'(lots of globals)'"},{"name":"allBehaviors","linesOfCode":3,"sourceCode":"allBehaviors\r\t\"Return all the classes and traits defined in the Smalltalk SystemDictionary\"\r\t^cachedBehaviors ifNil: [cachedBehaviors := self allClassesAndTraits flatCollect: [:each | {each . each classSide} ]]"},{"name":"declare:from:","linesOfCode":12,"sourceCode":"declare: key from: aDictionary \r\t\"Add key to the receiver. If key already exists, do nothing. If aDictionary \r\tincludes key, then remove it from aDictionary and use its association as \r\tthe element of the receiver.\"\r\t\"overridden here to add a Global, not just an association\"\r\r\t(self includesKey: key) ifTrue: [^ self].\r\t(aDictionary includesKey: key)\r\t\tifTrue: \r\t\t\t[self add: ((aDictionary associationAt: key) primitiveChangeClassTo: GlobalVariable new).\r\t\t\taDictionary removeKey: key]\r\t\tifFalse: \r\t\t\t[self add: (GlobalVariable key: key)]"},{"name":"hasBindingThatBeginsWith:","linesOfCode":19,"sourceCode":"hasBindingThatBeginsWith: aString\r\r\t\"Use the cached class and non-class names for better performance.\"\r\r\t| name searchBlock |\r\t(self reservedVariables hasBindingThatBeginsWith: aString) ifTrue: [ ^true ].\r\tsearchBlock := [ :element |\r\t\t(element beginsWith: aString)\r\t\t\tifTrue: [ 0 ]\r\t\t\tifFalse: [\r\t\t\t\taString < element\r\t\t\t\t\tifTrue: [ -1 ]\r\t\t\t\t\tifFalse: [ 1 ] ] ].\r\tname := self classNames \r\t\tfindBinary: searchBlock\r\t\tifNone: [nil].\r\tname ifNotNil: [ ^true ].\r\tname := self nonClassNames \r\t\tfindBinary: searchBlock\r\t\tifNone: [nil].\r\t^name notNil"},{"name":"organization:","linesOfCode":4,"sourceCode":"organization: anOrganization\r\t\"Return the organizer for the receiver\"\r\t\r\tanOrganization environment: self.\r\t^self at: #SystemOrganization put: anOrganization"},{"name":"renameClass:from:to:","linesOfCode":15,"sourceCode":"renameClass: aClass from: oldName to: newName\r\t\"Rename the class, aClass, to have the title newName.\"\r\r\t| oldref category |\r\tcategory := self organization categoryOfElement: oldName.\r\tself organization classify: newName under: category.\r\tself organization removeElement: oldName.\r\toldref := self associationAt: oldName.\r\tself removeKey: oldName.\r\toldref key: newName.\r\tself add: oldref.  \"Old association preserves old refs\"\r\tSessionManager default renamedClass: aClass from: oldName to: newName.\r\tself flushClassNameCache.\r\tSystemAnnouncer uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category.\r\taClass subclassesDo:[:subclass |\r\t\tSystemAnnouncer uniqueInstance classParentOf: subclass renamedFrom: oldName to: newName]."},{"name":"organization","linesOfCode":3,"sourceCode":"organization\r\t\"Return the organizer for the receiver\"\r\t\r\t^ self at: #SystemOrganization ifAbsent: nil"},{"name":"lookupVar:","linesOfCode":3,"sourceCode":"lookupVar: name\r\t\"Return a var with this name.  Return nil if none found\"\r\t^self reservedVariables at: name ifAbsent: [self bindingOf: name]"},{"name":"defineClass:withController:","linesOfCode":6,"sourceCode":"defineClass: aDefinition withController: aController\r\r\t^ self class compiler\r\t\tsource: aDefinition;\r\t\trequestor: aController;\r\t\tlogged: true;\r\t\tevaluate"},{"name":"allBehaviorsDo:","linesOfCode":3,"sourceCode":"allBehaviorsDo: aBlock\r\t\"Execute a block on each class, metaclass, trait and trait class\"\r\r\tself allBehaviors do: aBlock"},{"name":"allMethods","linesOfCode":2,"sourceCode":"allMethods\r\t^ self allBehaviors flatCollect: [ :behavior | behavior methods ]"},{"name":"hasClassOrTraitNamed:","linesOfCode":6,"sourceCode":"hasClassOrTraitNamed: aString\r\t\"Answer whether there is a class of the given name, but don't intern aString if it's not alrady interned.\"\r\r\tSymbol \r\t\thasInterned: aString \r\t\tifTrue:  [:aSymbol | ^ (self at: aSymbol ifAbsent: [nil]) isClassOrTrait].\r\t^ false"},{"name":"maxIdentityHash","linesOfCode":4,"sourceCode":"maxIdentityHash\r\t\"Answer the maximum identityHash value supported by the VM.\"\r\t<primitive: 176>\r\t^self primitiveFailed"},{"name":"renameClassNamed:as:","linesOfCode":8,"sourceCode":"renameClassNamed: oldName as: newName\r\t\"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  \"\r\r\t| oldClass |\r\t(oldClass := self at: oldName asSymbol ifAbsent: [ nil ]) \r\t\tifNil: [ \r\t\t\tSystemNotification signal: 'Class-rename for ' , oldName , ' ignored because ' , oldName , ' does not exist.'.\r\t\t\t^ self ].\r\toldClass rename: newName"},{"name":"removeKey:ifAbsent:","linesOfCode":3,"sourceCode":"removeKey: key ifAbsent: aBlock\r\tself removeFromCaches: key.\r\t^ super removeKey: key ifAbsent: aBlock"},{"name":"fillCaches","linesOfCode":22,"sourceCode":"fillCaches\r\t\"Fill cachedClassNames and cachedNonClassNames. Return an array with the calculated values.\"\r\r\t| classNames nonClassNames |\r\tclassNames := OrderedCollection new: self size.\r\tnonClassNames := OrderedCollection new.\r\tself keysAndValuesDo: [ :key :value |\r\t\t\"The key == value name test below addresses two separate issues:\r\t\t\t1) Obsolete classes, where key = #Foo and value name = 'AnObsoleteFoo'\r\t\t\t2) Aliases, i.e., Smalltalk at: #OtherName put: aClass\"\r\t\t((value isKindOf: (self class environment at: #Class)) and: [ key == value name ])\r\t\t\tifTrue: [ classNames add: key ]\r\t\t\tifFalse: [ nonClassNames add: key ] ].\r\t\t\"The expression (self class environment at: #Class) deserves some explanation.\r\t\tFor bootstrapping we need to have a different Class when executing value isKindOf: Class :\r\t\tIn such expression Class represents a kind of fixed point: the class of the class of the system. \r\t\tWhen bootstrapping we want the class Class of the current kernel defined in the current namespace.\r\t\tSince the current namespace should contains the class that describes itself as well as a new Class class.\r\t\twe are done :).\"\r\t\r\t\r\t\"The cached names are sorted to allow for a very efficient hasBindingThatBeginsWith: check\"\t\r\tcachedClassNames := classNames sort.\r\tcachedNonClassNames := nonClassNames sort.\r\t^{ classNames. nonClassNames }"},{"name":"removeClassNamed:","linesOfCode":3,"sourceCode":"removeClassNamed: aName\r\t\"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it\"\r\r\tself at: aName asSymbol ifPresent: [:oldClass | oldClass removeFromSystem]"},{"name":"nonClassNames","linesOfCode":3,"sourceCode":"nonClassNames\r\t\"Answer a sorted collection of all non-class names. Use the return value of #fillCaches to avoid concurrency issues.\"\r\t\r\t^cachedNonClassNames ifNil: [ self fillCaches at: 2 ]"},{"name":"traitNames","linesOfCode":7,"sourceCode":"traitNames\r\t\"Answer a SortedCollection of all traits (not including class-traits) names.\"\r\t\r\t^self classNames select: [ :name |\r\t\t\tself\r\t\t\t\tat: name\r\t\t\t\tifPresent: [ :global | (global isTrait) and: [global isObsolete not]]\r\t\t\t\tifAbsent: [ false ] ]"},{"name":"allClassesAndTraitsDo:","linesOfCode":3,"sourceCode":"allClassesAndTraitsDo: aBlock\r\t\"Evaluate the argument, aBlock, for each class and trait in the system.\"\r\t\r\t^self classAndTraitNames do: [:each | aBlock value: (self at: each)]\r\t\r\t\r"},{"name":"classNames","linesOfCode":3,"sourceCode":"classNames\r\t\"Answer a sorted collection of all class names. Use the return value of #fillCaches to avoid concurrency issues.\"\r\t\r\t^cachedClassNames ifNil: [ self fillCaches at: 1 ]"},{"name":"forgetClass:logged:","linesOfCode":6,"sourceCode":"forgetClass: aClass logged: aBool\r\t\"Delete the class, aClass, from the system.\r\tNote that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem.\"\r\r\tself organization removeElement: aClass name.\r\tSessionManager default unregisterClassNamed: aClass name.\r\tself removeKey: aClass name ifAbsent: [  ]"},{"name":"hasClassNamed:","linesOfCode":6,"sourceCode":"hasClassNamed: aString\r\t\"Answer whether there is a class of the given name, but don't intern aString if it's not alrady interned.\"\r\r\tSymbol \r\t\thasInterned: aString \r\t\tifTrue:  [:aSymbol | ^ (self at: aSymbol ifAbsent: [nil]) isClass].\r\t^ false"},{"name":"removeFromCaches:","linesOfCode":5,"sourceCode":"removeFromCaches: aKey\r\t\"In case we remove a key from the system dictionary, we do not need to flush all the caches. We can just remove it from the class name and non class name caches.\"\r\r\tcachedClassNames ifNotNil: [ :cache | cache remove: aKey ifAbsent: [  ] ].\r\tcachedNonClassNames ifNotNil: [ :cache | cache remove: aKey ifAbsent: [  ] ].\r\tcachedBehaviors := nil"},{"name":"allTraits","linesOfCode":3,"sourceCode":"allTraits\r\t\"Return all traits defined in the Smalltalk SystemDictionary\"\r\r\t^ self traitNames collect: [:each | self at: each]"},{"name":"allClassesDo:","linesOfCode":3,"sourceCode":"allClassesDo: aBlock\r\t\"Evaluate the argument, aBlock, for each class in the system.\"\r\r\t^self classNames do: [:name | aBlock value: (self at: name)]"},{"name":"classAndTraitNames","linesOfCode":5,"sourceCode":"classAndTraitNames\r\t\"Answer a sorted collection of all class and trait (not including class-traits) names. \r\tNow traits are normal classes. So they are in same class list.\r\tDo not bother to sort\"\r\r\t\r\t^self classNames\r\t"},{"name":"environment","linesOfCode":3,"sourceCode":"environment\r\t\"for conversion from SmalltalkImage to SystemDictionary\"\r\t\r\t^ self "},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\t\"serialize all instances except for <Smalltalk globals>\"\r\t^ self == Smalltalk globals \r\t\tifFalse: [ super fuelAccept: aGeneralMapper ]\r\t\tifTrue: [ aGeneralMapper visitHookPrimitive: self ]"},{"name":"renameClass:from:","linesOfCode":3,"sourceCode":"renameClass: aClass from: oldName \r\t\"Rename the class, aClass, to have the title newName.\"\r\r\t^self renameClass: aClass from: oldName to: aClass name"},{"name":"allTraitsDo:","linesOfCode":3,"sourceCode":"allTraitsDo: aBlock\r\t\"Evaluate the argument, aBlock, for each trait in the system.\"\r\r\t^self traitNames do: [:name | aBlock value: (self at: name)]"},{"name":"renameClass:as:","linesOfCode":3,"sourceCode":"renameClass: aClass as: newName \r\t\"Rename the class, aClass, to have the title newName.\"\r\r\t^self renameClass: aClass from: aClass name to: newName"},{"name":"reservedVariables","linesOfCode":2,"sourceCode":"reservedVariables\r\t^reservedVariables ifNil: [ reservedVariables := ReservedVariable lookupDictionary]"},{"name":"flushClassNameCache","linesOfCode":4,"sourceCode":"flushClassNameCache\r\t\"Force recomputation of the cached list of class names and non-class names.\"\r\r\t<script: 'Smalltalk flushClassNameCache'>\r\tcachedClassNames := cachedNonClassNames := cachedBehaviors := nil"},{"name":"classOrTraitNamed:","linesOfCode":22,"sourceCode":"classOrTraitNamed: aString\r\t\"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively.\r\tAnswer the class or metaclass it names.\"\r\r\t| meta baseName |\r\t(aString endsWith: ' class')\r\t\tifTrue: [ \r\t\t\tmeta := true.\r\t\t\tbaseName := aString copyFrom: 1 to: aString size - 6 ]\r\t\tifFalse: [ \r\t\t\t(aString endsWith: ' classTrait')\r\t\t\t\tifTrue: [ \r\t\t\t\t\tmeta := true.\r\t\t\t\t\tbaseName := aString copyFrom: 1 to: aString size - 11 ]\r\t\t\t\tifFalse: [ \r\t\t\t\t\tmeta := false.\r\t\t\t\t\tbaseName := aString ] ].\r\t^self at: baseName asSymbol ifPresent:\r            [ :global |\r               (global isBehavior or: [global isTrait])ifTrue:\r                       [ meta\r                               ifFalse: [ global ]\r                               ifTrue: [ global classSide ]]]"},{"name":"veryDeepCopyWith:","linesOfCode":2,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Return self.  I can't be copied.  Do not record me.\""}],"meta":{"name":"SystemDictionary class","instanceVariables":[],"methods":[{"name":"withOrganizer:","linesOfCode":5,"sourceCode":"withOrganizer: anOrganizer\r\t| dictionary |\r\tdictionary := self new.\r\tdictionary organization: anOrganizer. \"update too the back pointer\"\r\t^dictionary.\r\t"},{"name":"materializeFrom:","linesOfCode":3,"sourceCode":"materializeFrom: aDecoder\r\t\"Answer my well-known instance\"\r\r\t^ Smalltalk globals"}],"meta":null}},{"name":"ProtocolState","instanceVariables":[{"name":"name"},{"name":"default"}],"methods":[{"name":"transitionAt:put:","linesOfCode":2,"sourceCode":"transitionAt: key put: edge\r\r\t^super at: key put: edge"},{"name":"atAll:put:","linesOfCode":4,"sourceCode":"atAll: collection put: transition\r\t| edge |\r\tedge := self transitionFor: transition.\r\tcollection do: [:elt | self transitionAt: elt put: edge]"},{"name":"transitionAt:","linesOfCode":2,"sourceCode":"transitionAt: key\r\r\t^super at: key ifAbsent: [default]"},{"name":"add:","linesOfCode":2,"sourceCode":"add: anAssociation\r\r\t^self transitionAt: anAssociation key put: (self transitionFor: anAssociation value)"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\r\taStream nextPutAll: '(name: ' , name printString.\r\taStream nextPutAll: ' default: ' , default printString.\r\taStream nextPutAll: ' transitions:'.\r\tself associationsDo: [:transition | aStream space.  transition printOn: aStream.].\r\taStream nextPut: $)."},{"name":"transitionFor:","linesOfCode":2,"sourceCode":"transitionFor: transition\r\r\t^ProtocolStateTransition action: transition key state: transition value"},{"name":"addInteger:","linesOfCode":2,"sourceCode":"addInteger: anAssociation\r\r\t^self transitionAt: anAssociation key asInteger put: (self transitionFor: anAssociation value)"},{"name":"atAllInteger:put:","linesOfCode":4,"sourceCode":"atAllInteger: collection put: transition\r\t| edge |\r\tedge := self transitionFor: transition.\r\tcollection do: [:elt | self transitionAt: elt asInteger put: edge]"},{"name":"defaultTransition:","linesOfCode":2,"sourceCode":"defaultTransition: aTransition\r\r\tdefault := aTransition"},{"name":"name","linesOfCode":2,"sourceCode":"name\r\r\t^name"},{"name":"addAll:","linesOfCode":2,"sourceCode":"addAll: anAssociation\r\r\t^self atAll: anAssociation key put: anAssociation value"},{"name":"addAllInteger:","linesOfCode":2,"sourceCode":"addAllInteger: anAssociation\r\r\t^self atAllInteger: anAssociation key put: anAssociation value"},{"name":"default","linesOfCode":2,"sourceCode":"default\r\r\t^default"},{"name":"at:to:put:","linesOfCode":4,"sourceCode":"at: anObject to: limit put: transition\r\r\t| edge |\r\tedge := self transitionFor: transition.\r\tanObject to: limit do: [:target | self transitionAt: target put: edge]"},{"name":"name:","linesOfCode":2,"sourceCode":"name: aSymbol\r\r\tname := aSymbol"},{"name":"default:","linesOfCode":2,"sourceCode":"default: transition\r\r\tself defaultTransition: (self transitionFor: transition)"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: key put: transition\r\r\t^self transitionAt: key put: (self transitionFor: transition)"}],"meta":{"name":"ProtocolState class","instanceVariables":[],"methods":[{"name":"example","linesOfCode":5,"sourceCode":"example\r\t\"ProtocolState example\"\r\r\t^(self name: #initial default: #echo: -> #initial)\r\t\tat: 42 put: #echo42: -> #initial;\r\t\tyourself"},{"name":"name:default:","linesOfCode":4,"sourceCode":"name: myName default: aTransition\r\t^self new\r\t\tname: myName;\r\t\tdefault: aTransition"}],"meta":null}},{"name":"StatefulProtocolDescription","instanceVariables":[{"name":"initialState"}],"methods":[{"name":"printElementsOn:","linesOfCode":4,"sourceCode":"printElementsOn: aStream\r\r\taStream nextPutAll: '(initial: ' , initialState printString , ' states:'.\r\tself keysDo: [:key | aStream space.  key printOn: aStream].\r\taStream nextPut: $)"},{"name":"initialState:","linesOfCode":2,"sourceCode":"initialState: stateName\r\r\tinitialState := stateName"},{"name":"compile","linesOfCode":9,"sourceCode":"compile\r\t\"Compile my symbolic representation into a cyclic DAG and answer the root node\"\r\r\t| edge |\r\tself valuesDo: [:state |\r\t\tstate defaultTransition: (self resolve: state default).\r\t\tstate keysDo: [:key |\r\t\t\tedge := state at: key.\r\t\t\tstate transitionAt: key put: (self resolve: edge)]].\r\t\r\t^self at: initialState"},{"name":"resolve:","linesOfCode":10,"sourceCode":"resolve: edge\r\r\t| target action |\r\ttarget := edge state.\r\taction := edge action.\r\ttarget := (self includesKey: target)\r\t\tifTrue: [self at: target]\r\t\tifFalse: [target isNil\r\t\t\t\t\tifTrue: [nil]\r\t\t\t\t\tifFalse: [self error: 'unknown target state ' , edge printString]].\r\t^ProtocolStateTransition action: action state: target"},{"name":"newState:","linesOfCode":2,"sourceCode":"newState: rule\r\r\t^self newState: rule key default: rule value"},{"name":"newState:default:","linesOfCode":2,"sourceCode":"newState: stateName default: transition\r\r\t^self at: stateName put: (ProtocolState name: stateName default: transition)"}],"meta":{"name":"StatefulProtocolDescription class","instanceVariables":[],"methods":[{"name":"example2","linesOfCode":3,"sourceCode":"example2\r\t\"StatefulProtocolDescription example2 explore\"\r\r\t^self example compile"},{"name":"example","linesOfCode":12,"sourceCode":"example\r\t\"A state machine that recognises occurrences of 'x' 'xy' and 'xy[digits...]z' in a stream of characters.  Note: this is used by StateMachineTester, so don't modify it.  See StateMachineTester class>>test for an example of use.\"\r\t\"StatefulProtocolDescription example\"\r\r\t| desc |\r\tdesc := self new.\r\t(desc newState: #initial -> (#echo: -> #initial)) add: $x -> (nil -> #statex).\r\t(desc newState: #statex -> (#echox: -> #initial)) add: $y -> (#initPrefix: -> #statexy).\r\t(desc newState: #statexy -> (#echoxy: -> #initial))\r\t\tadd: $z -> (#echoxyz: -> #initial);\r\t\taddAll: '0123456789' -> (#addPrefix: -> nil).\r\tdesc initialState: #initial.\r\t^desc"},{"name":"example3","linesOfCode":9,"sourceCode":"example3\t\t\"Note: this example should pop up an error notifier during compilation\"\r\r\t\"StatefulProtocolDescription example3 compile\"\r\r\t| desc |\r\tdesc := self new.\r\t(desc newState: #initial -> (#echo: -> #initial)) add: $x -> (nil -> #statex).\r\t(desc newState: #statex -> (#echox: -> #initial)) add: $y -> (nil -> #statexy).\r\t(desc newState: #statexy -> (#echoxy: -> #initial)) add: $z -> (#echoxy: -> #statexyz).\r\tdesc initialState: #initial.\r\t^desc"},{"name":"initialState:","linesOfCode":2,"sourceCode":"initialState: stateName\r\r\t^self new initialState: stateName"}],"meta":null}},{"name":"WeakIdentityKeyDictionary","instanceVariables":[],"methods":[{"name":"compare:to:","linesOfCode":2,"sourceCode":"compare: object1 to: object2\r\t^ object1 == object2"},{"name":"startIndexFor:","linesOfCode":3,"sourceCode":"startIndexFor: anObject\r\t\"Return the index at which the scan for anObject should start.\"\r\t\r\t^(anObject identityHash \\\\ array size) + 1"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"valuesDo:","linesOfCode":14,"sourceCode":"valuesDo: aBlock \r\t\"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's\r\tnot collected during the evaluation of aBlock\"\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do:\r\t\t[ :eachIndex | \r\t\t\t| eachAssociation eachKey |\r\t\t\teachAssociation := array at: eachIndex.\r\t\t\tnil == eachAssociation ifFalse:\r\t\t\t\t[\r\t\t\t\t\teachKey := eachAssociation key.\r\t\t\t\t\tnil == eachKey ifFalse: [ aBlock value: eachAssociation value ]\r\t\t\t\t]\r\t\t]"}],"meta":{"name":"WeakIdentityKeyDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakIdentityValueDictionary","instanceVariables":[],"methods":[{"name":"keyAtValue:ifAbsent:","linesOfCode":6,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^ association key]].\r\t^ exceptionBlock value"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| finish start element |\r\tfinish := array size.\r\tstart := (anObject identityHash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"WeakIdentityValueDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakArray","instanceVariables":[],"methods":[],"meta":{"name":"WeakArray class","instanceVariables":[],"methods":[{"name":"doOldFinalization","linesOfCode":7,"sourceCode":"doOldFinalization\r\t\"Process the weak registries, in the old finalization style.  Hopefully this will\r\t eventually go away when all clients have adopted the new finalization scheme.\"\r\tFinalizationLock critical: [\r\t\t\tFinalizationDependents do: \t[:weakDependent |\r\t\t\t\tweakDependent ifNotNil: [\r\t\t\t\t\t[ weakDependent finalizeValues ] on: Exception fork: [:ex | ex pass ] ]]]."},{"name":"finalizationProcess","linesOfCode":19,"sourceCode":"finalizationProcess\r\t\"The finalization process arranges to send mourn to each element of the VM's finalization queue,\r\t which is accessed via primitiveFetchMourner.  The VM signals FinalizationSemaphore whenever\r\t the queue is non-empty.  This process loops, waiting on the semaphore, fetches the first element\r\t of the queue and then spawns a process at a higher priority to acually send the mourn messages.\r\t If an error occurs in the higher priority mourn loop process then this process will simply spawn\r\t another process, hence ensuring that errors in finalization methods don't break finalization.\r\r\t In addition this process also runs the old finalization scheme, supporting clients of the older,\r\t WeakRegistry based scheme.  Hopefully this will go away when all cleints have moved over.\"\r\t| throttle firstMourner |\r\tthrottle := Semaphore new.\r\t[true] whileTrue: [FinalizationSemaphore wait; initSignals.\r\t \"Support the old scheme until things have changed over...\"\r\t self doOldFinalization.\r\t [firstMourner := self primitiveFetchMourner.\r\t  firstMourner notNil] whileTrue:\r\t\t[[throttle signal.\r\t\t  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1.\r\t\t throttle wait]]"},{"name":"restartFinalizationProcess","linesOfCode":11,"sourceCode":"restartFinalizationProcess\r\t\"kill any old process, just in case\"\r\tFinalizationProcess\r\t\tifNotNil: [FinalizationProcess terminate.\r\t\t\tFinalizationProcess := nil].\r\r\tFinalizationSemaphore := Smalltalk specialObjectsArray at: 42.\r\tFinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].\r\tFinalizationLock := Semaphore forMutualExclusion.\r\t\r\tFinalizationProcess := [self finalizationProcess]\r\t\tforkAt: Processor userInterruptPriority.\r\tFinalizationProcess name: 'WeakArray Finalization Process'."},{"name":"addWeakDependent:","linesOfCode":18,"sourceCode":"addWeakDependent: anObject\r\t\r\tFinalizationLock critical:[ | index finished weakDependent |\r\t\tfinished := false.\r\t\tindex := 0.\r\t\t[index := index + 1.\r\t\tfinished not and:[index <= FinalizationDependents size]] whileTrue:[\r\t\t\tweakDependent := FinalizationDependents at: index.\r\t\t\tweakDependent ifNil: [\r\t\t\t\tFinalizationDependents at: index put: anObject.\r\t\t\t\tfinished := true.\r\t\t\t].\r\t\t].\r\t\tfinished ifFalse:[\r\t\t\t\"Grow linearly\"\r\t\t\tFinalizationDependents := FinalizationDependents, (WeakArray new: 10).\r\t\t\tFinalizationDependents at: index put: anObject.\r\t\t].\r\t] ifError: [:err | err signal]."},{"name":"hasWeakDependent:","linesOfCode":2,"sourceCode":"hasWeakDependent: anObject\r\t^FinalizationDependents includes: anObject"},{"name":"initialize","linesOfCode":9,"sourceCode":"initialize\r\t\"Do we need to initialize specialObjectsArray?\"\r\tSmalltalk specialObjectsArray size < 42 \r\t\tifTrue: [Smalltalk recreateSpecialObjectsArray].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: self name.\r\r\tFinalizationSemaphore := Smalltalk specialObjectsArray at: 42.\r\tFinalizationLock := Semaphore forMutualExclusion.\r\tFinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10]."},{"name":"pvtCreateTemporaryObjectIn:","linesOfCode":3,"sourceCode":"pvtCreateTemporaryObjectIn: tempObject\r\t\"We have to create the temporary object in a separate stack frame\"\r\ttempObject at: 1 put: Object new"},{"name":"runningFinalizationProcess","linesOfCode":3,"sourceCode":"runningFinalizationProcess\r\t\"Answer the FinalizationProcess I am running, if any\"\r\t^FinalizationProcess"},{"name":"startUp:","linesOfCode":3,"sourceCode":"startUp: resuming\r\tresuming ifFalse: [ ^self ].\r\tself restartFinalizationProcess."},{"name":"removeWeakDependent:","linesOfCode":8,"sourceCode":"removeWeakDependent: anObject\r\tFinalizationLock critical:[\r\t\t1 to: FinalizationDependents size do:[:i|\r\t\t\t((FinalizationDependents at: i) == anObject) ifTrue:[\r\t\t\t\tFinalizationDependents at: i put: nil.\r\t\t\t].\r\t\t].\r\t] ifError: [:err | err signal]."},{"name":"mournLoopWith:","linesOfCode":10,"sourceCode":"mournLoopWith: firstMourner\r\t\"Send mourn to all the objects available in the mourn queue, starting\r\t with firstMourner which the sender has already extraced for us.  If\r\t an error occurs here, it will break this loop but the sender will spawn\r\t another mournLoopWith: so that finalization is not broken by errors in\r\t individual cases.\"\r\t| mourner |\r\tmourner := firstMourner.\r\t[mourner mourn.\r\t (mourner := self primitiveFetchMourner) notNil] whileTrue"},{"name":"primitiveFetchMourner","linesOfCode":9,"sourceCode":"primitiveFetchMourner\r\t\"Answer the next mourner in the VM's queue of objects to be finalized.\r\t The queue contains weak arrays and ephemerons.  If the primitive is\r\t not implemented, raise an error telling people to upgrade the VM.  If\r\t implemented, the primitive fails if the queue is empty, with the error\r\t code #'not found'. Primitive.  Essential.\"\r\r\t<primitive: 172 error: ec>\r\tec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\\Please upgrade your virtual machine to one that has the primitive.' withCRs].\r\t^nil"}],"meta":null}},{"name":"MetacelloMethodSectionPath","instanceVariables":[],"methods":[{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ self"},{"name":"asAttributeOrPath","linesOfCode":9,"sourceCode":"asAttributeOrPath\r    self size = 1\r        ifTrue: [ \r            | attribute |\r            attribute := self at: 1.\r            ^ attribute size = 1\r                ifTrue: [ attribute at: 1 ]\r                ifFalse: [ attribute ] ].\r    ^ self"}],"meta":{"name":"MetacelloMethodSectionPath class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakActionSequence","instanceVariables":[],"methods":[{"name":"asMinimalRepresentation","linesOfCode":8,"sourceCode":"asMinimalRepresentation\r\r\t| valid |\r\tvalid := self select: [:e | e isValid ].\r\tvalid size = 0\r\t\tifTrue: [^nil].\r\tvalid size = 1\r\t\tifTrue: [^valid first].\r\t^valid"},{"name":"value","linesOfCode":7,"sourceCode":"value\r    \"Answer the result of evaluating the elements of the receiver.\r\tActually, return just the last result.\"\r\r    | answer |\r    self do:\r        [:each | each isValid ifTrue: [answer := each value]].\r    ^answer"},{"name":"printOn:","linesOfCode":7,"sourceCode":"printOn: aStream\r\r\tself size < 2 ifTrue: [^super printOn: aStream].\r\taStream nextPutAll: '#('.\r\tself\r\t\tdo: [:each | each printOn: aStream]\r\t\tseparatedBy: [aStream cr].\r\taStream nextPut: $)"},{"name":"valueWithArguments:","linesOfCode":7,"sourceCode":"valueWithArguments: anArray\r\r\t\"Return the last result\"\r\r    | answer |\r    self do:\r        [:each |\r        \teach isValid ifTrue: [answer := each valueWithArguments: anArray]].\r    ^answer"},{"name":"asActionSequence","linesOfCode":2,"sourceCode":"asActionSequence\r\r\t^self"}],"meta":{"name":"WeakActionSequence class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Cubic","instanceVariables":[],"methods":[{"name":"calcEnoughSegments","linesOfCode":9,"sourceCode":"calcEnoughSegments\r\t\"Find the power of two that represents a sufficient number of  segments for this cubic.  \r\tThe measure is the sum of distances for the segments.  \r\tWe want this to be close enough not affect the straightness of  \r\tthe drawn lines. Which means within one pixel.\"\r\t\r\t^ self\r\t\tenough: 4\r\t\twithMeasure: (self measureFor: 2)\r\t\twithIn: self leeway"},{"name":"honeIn:","linesOfCode":10,"sourceCode":"honeIn: enough \r\t\"Find if there is a smaller n than enough that give the same  \r\tmeasure for n.\"\r\t\r\t[enough isPowerOfTwo]  assert.\r\tenough < 2 ifTrue: [^ enough].\r\t^ self\r\t\thoneIn: enough\r\t\tstep: enough // 2\r\t\tmeasure: (self measureFor: enough)\r\t\twithIn: self leeway"},{"name":"honeIn:step:measure:withIn:","linesOfCode":17,"sourceCode":"honeIn: centerN step: step measure: measure withIn: closeEnough \r\t\"Pick the best n by binary search.\"\r\t\r\t| nTry |\r\tstep < 1\r\t\tifTrue: [^ centerN].\r\tnTry := centerN - step.\r\t^ measure > (closeEnough + (self measureFor: nTry))\r\t\tifTrue: [self\r\t\t\t\thoneIn: centerN\r\t\t\t\tstep: step // 2\r\t\t\t\tmeasure: measure\r\t\t\t\twithIn: closeEnough]\r\t\tifFalse: [self\r\t\t\t\thoneIn: nTry\r\t\t\t\tstep: step // 2\r\t\t\t\tmeasure: measure\r\t\t\t\twithIn: closeEnough]"},{"name":"enough:withMeasure:withIn:","linesOfCode":10,"sourceCode":"enough: nTry withMeasure: lastMeasure withIn: closeEnough\r\t\"See comment in calcEnoughSegments for which I am a helper\"\r\t\r\t| measure |\r\tmeasure := self measureFor: nTry.\r\tmeasure > (lastMeasure + closeEnough)\r\t\tifFalse: [^ nTry // 2].\r\t^ self\r\t\tenough: 2 * nTry\r\t\twithMeasure: measure\r\t\twithIn: closeEnough"},{"name":"bestSegments","linesOfCode":3,"sourceCode":"bestSegments\r\t\"Return the smallest integer number of segments that give the best curve.\"\r\t\r\t^ self honeIn: self calcEnoughSegments"},{"name":"leeway","linesOfCode":3,"sourceCode":"leeway\r\t\"How close can measure be\"\r\t\r\t^ 0.1"},{"name":"measureFor:","linesOfCode":12,"sourceCode":"measureFor: n \r\t\"Return a distance measure for cubic curve with n segments. \r\tFor convienence and accuracy we use the sum of the distances. \"\r\t\"The first point is poly of 0.\"\r\t| p1 measure |\r\tp1 := self first.\r\tmeasure := 0.\r\t1 to: n do: [:i | | p2 | \r\t\t\tp2 := self polynomialEval: i / n asFloat.\r\t\t\tmeasure := measure + (p2 distanceTo: p1).\r\t\t\tp1 := p2].\r\t^ measure"}],"meta":{"name":"Cubic class","instanceVariables":[],"methods":[{"name":"with:with:with:with:","linesOfCode":3,"sourceCode":"with: pt1 with: pt2  with: pt3 with: pt4\r\t\"a cubic object is composed of 4 points\"\r\t\r\t^ self withAll: {pt1 . pt2 . pt3 . pt4}"}],"meta":null}},{"name":"CompiledCode","instanceVariables":[],"methods":[{"name":"encoderClass","linesOfCode":4,"sourceCode":"encoderClass\r\t^ self signFlag \r\t\tifTrue: [ SecondaryBytecodeSetEncoderClass ]\r\t\tifFalse: [ PrimaryBytecodeSetEncoderClass ]"},{"name":"sourceNode","linesOfCode":2,"sourceCode":"sourceNode\r\t^ self subclassResponsibility"},{"name":"scanner","linesOfCode":2,"sourceCode":"scanner\r\r\t^ InstructionStream on: self"},{"name":"gtInspectorHeaderIn:","linesOfCode":5,"sourceCode":"gtInspectorHeaderIn: composite\r\t<gtInspectorPresentationOrder: 40> \r\tcomposite text \r\t\ttitle: 'Header';\r\t\tdisplay: [ self headerDescription ]"},{"name":"comment","linesOfCode":4,"sourceCode":"comment\r\t\"Return the first comment of the receiver\"\r\t\"(self>>#comment) comment\"\r\t\r\t^ self ast firstPrecodeComment"},{"name":"literalsToSkip","linesOfCode":2,"sourceCode":"literalsToSkip\r\r\t^ self subclassResponsibility"},{"name":"flag","linesOfCode":3,"sourceCode":"flag\r\t\"Answer the user-level flag bit\"\r\r\t^((self header bitShift: -29) bitAnd: 1) = 1"},{"name":"stamp","linesOfCode":2,"sourceCode":"stamp\r\r\t^ self timeStamp"},{"name":"voidCogVMState","linesOfCode":9,"sourceCode":"voidCogVMState\r\t\"Tell the VM to remove all references to any machine code form of the method.\r\t This primitive must be called whenever a method is in use and modified.  This is\r\t more aggressive (and *much* more costly) than flushCache since it must search\r\t through all context objects, making sure that none have a (hidden) machine code pc\r\t in the receiver.  Since modifying a method will likely change the generated machine code,\r\t modifying a method (rather than redefining it) requires this more aggressive flush.\"\r\r\t<primitive: 215>\r\t^self flushCache"},{"name":"writesField:","linesOfCode":6,"sourceCode":"writesField: varIndex\r\t\"Answer whether the receiver stores into the instance variable indexed by the argument.\"\r\r\t| varIndexCode scanner |\r\tvarIndexCode := varIndex - 1.\r\t((scanner := InstructionStream on: self) scanFor: (self encoderClass instVarWriteScanBlockFor: varIndexCode using: scanner)) ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb writesField: varIndex ]"},{"name":"usesPrimaryBytecodeSet","linesOfCode":2,"sourceCode":"usesPrimaryBytecodeSet\r\t^ self header >= 0"},{"name":"hasLiteral:","linesOfCode":8,"sourceCode":"hasLiteral: literal\r\t\"Answer whether the receiver references the argument, literal.\"\r\t1 to: self numLiterals - self literalsToSkip do: \"exclude superclass + selector/properties\"\r\t\t[:index |\r\t\t| lit |\r\t\t((lit := self literalAt: index) literalEqual: literal) ifTrue: [^true].\r\t\tlit isEmbeddedBlock ifTrue: [ (lit hasLiteral: literal) ifTrue: [ ^true ] ]].\r\t^false"},{"name":"symbolicBytecodes","linesOfCode":3,"sourceCode":"symbolicBytecodes\r\t\"Answer Collection that contains of all the byte codes in a method as an instance of SymbolicInstruction\"\r\r\t^SymbolicBytecodeBuilder decode: self"},{"name":"initialPC","linesOfCode":3,"sourceCode":"initialPC\r\t\"Answer the program counter for the receiver's first bytecode.\"\r\r\t^ (self numLiterals + 1) * Smalltalk wordSize + 1"},{"name":"asOrderedCollection","linesOfCode":4,"sourceCode":"asOrderedCollection\r\t\"We should override it because most of collection methods are not working for CompiledMethod. And it can't be normally converted into OrderedCollection.\t\r\tIt is special class which needs to be ByteArray by VM. But it is not behaves like ByteArray from user perspective\"\r\t\r\t^OrderedCollection with: self"},{"name":"isNamedPrimitive","linesOfCode":2,"sourceCode":"isNamedPrimitive\r\t^self primitive = 117"},{"name":"ast","linesOfCode":2,"sourceCode":"ast\r\t^ self subclassResponsibility"},{"name":"isDoIt","linesOfCode":2,"sourceCode":"isDoIt\r\t^ false"},{"name":"clearFlag","linesOfCode":3,"sourceCode":"clearFlag\r\t\"Clear the user-level flag bit\"\r\r\tself objectAt: 1 put: (self header bitAnd: (1 << 29) bitInvert)"},{"name":"clearSignFlag","linesOfCode":5,"sourceCode":"clearSignFlag\r\t\"Clear the sign flag bit.  The sign flag bit may be\r\t used by the VM to select an alternate bytecode set.\"\r\r\tself signFlag ifTrue:\r\t\t[self objectAt: 1 put: self header - SmallInteger minVal]"},{"name":"sendsAnySelectorOf:","linesOfCode":3,"sourceCode":"sendsAnySelectorOf: aCollection\r\t\r\t(self localSendsAnySelectorOf: aCollection) ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb sendsAnySelectorOf: aCollection ]\r"},{"name":"pragmas","linesOfCode":2,"sourceCode":"pragmas\r\t^ self subclassResponsibility"},{"name":"hasInstVarRef","linesOfCode":3,"sourceCode":"hasInstVarRef\r\tself localHasInstVarRef ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb hasInstVarRef ]"},{"name":"literalsDo:","linesOfCode":4,"sourceCode":"literalsDo: aBlock\r\t\"Evaluate aBlock for each of the literals referenced by the receiver.\"\r\t1 to: self numLiterals - self literalsToSkip do:\r\t\t[:index | aBlock value: (self literalAt: index)]"},{"name":"refersToLiteral:","linesOfCode":9,"sourceCode":"refersToLiteral: aLiteral\r\t\"Answer true if any literal in this method is literal,\r\teven if embedded in array structure.\"\r\r\t1 to: self numLiterals - self literalsToSkip do: [ :index | \r\t\t\"exclude selector or additional method state (penultimate slot) \r\t\tand methodClass or outerCode (last slot)\"\r\t\t((self literalAt: index) refersToLiteral: aLiteral)\r\t\t\tifTrue: [ ^ true ] ].\r\r\t^ false"},{"name":"withAllNestedLiteralsDo:","linesOfCode":6,"sourceCode":"withAllNestedLiteralsDo: aBlockClosure \r\t\"This method traverses all the nested literals.\r\tAs a Block or Method can have literals in the nested blocks. \r\tThis is used to query all the selectors used in a method for example\"\r\t\r\tself withAllBlocksDo: [ :aCompiledCode | \r\t\taCompiledCode literals do: aBlockClosure ]"},{"name":"gtInspectorPragmasIn:","linesOfCode":27,"sourceCode":"gtInspectorPragmasIn: composite\r\t<gtInspectorPresentationOrder: 30> \r\tcomposite tabulator \r\t\ttitle: 'Pragmas';\r\t\twhen: [ :x | x pragmas notEmpty ];\r\t\twith: [ :t |  \r\t\t\tt row: #pragmas; row: #methods.\r\t\t\tt transmit to: #pragmas; andShow: [:a | \r\t\t\t\ta list\r\t\t\t\t\ttitle: 'Pragmas';\r\t\t\t\t\tdisplay: [ :method | method pragmas ];\r\t\t\t\t\twhen: [ :x | x pragmas notEmpty ] ].\r\t\t\tt transmit from: #pragmas; to: #methods; andShow: [:a | \r\t\t\t\ta list \r\t\t\t\t\ttitle: 'Methods';\r\t\t\t\t\tdisplay: [ :pragma | \r\t\t\t\t\t\t| methods | \r\t\t\t\t\t\tmethods := OrderedCollection new.\r\t\t\t\t\t\tObject withAllSubclassesDo: [ :each | \r\t\t\t\t\t\t\tmethods addAll: ((Pragma allNamed: pragma selector in: each) collect: [:pr  | pr method]) ].\r\t\t\t\t\t\tmethods ];\r\t\t\t\t\tformat: #selector ].\r\t\t\tt transmit\r\t\t\t\ttoOutsidePort: #selection;\r\t\t\t\tfrom: #methods port: #selection\r\t\t];\r\t\tstartOn: self"},{"name":"literalAt:put:","linesOfCode":4,"sourceCode":"literalAt: index put: value \r\t\"Replace the literal indexed by the first argument with the second \r\targument. Answer the second argument.\"\r\r\t^self objectAt: index + 1 put: value"},{"name":"argumentNames","linesOfCode":2,"sourceCode":"argumentNames\r\t^ self propertyAt: #argumentNames ifAbsent: [ self ast argumentNames ]"},{"name":"isRealPrimitive","linesOfCode":2,"sourceCode":"isRealPrimitive\r\t^self isPrimitive and: [ self isQuick not ]"},{"name":"package","linesOfCode":2,"sourceCode":"package\r\t^ self packageFromOrganizer: RPackage organizer"},{"name":"abstractBytecodeMessageAt:","linesOfCode":5,"sourceCode":"abstractBytecodeMessageAt: pc\r\t\"Answer the abstract bytecode message at pc in the receiver.\"\r\t^[(InstructionStream new method: self pc: pc) interpretNextInstructionFor: nil]\r\t\ton: MessageNotUnderstood\r\t\tdo: [:ex| ex message]"},{"name":"abstractBytecodeMessagesFrom:to:do:","linesOfCode":15,"sourceCode":"abstractBytecodeMessagesFrom: startpc to: endpc do: aBlock\r\t\"Evaluate aBlock with the sequence of abstract bytecodes from startpc through endpc in the receiver\"\r\t| scanner |\r\tscanner := InstructionStream new method: self pc: startpc.\r\t[scanner pc <= endpc] whileTrue:\r\t\t[[scanner interpretNextInstructionFor: nil]\r\t\t\ton: MessageNotUnderstood\r\t\t\tdo: [:ex| aBlock value: ex message]]\r\r\t\"| m msgs |\r\t msgs := OrderedCollection new.\r\t (m := CompiledMethod >> #abstractBytecodeMessagesFrom:to:)\r\t\tabstractBytecodeMessagesFrom: m initialPC\r\t\tto: m endPC\r\t\tdo: [:msg| msgs add: msg selector].\r\t msgs\""},{"name":"withAllBlocks","linesOfCode":5,"sourceCode":"withAllBlocks\r\t| all |\r\tall := IdentitySet new.\r\tself withAllBlocksDo: [ :each | all add: each ].\r\t^all"},{"name":"compiler","linesOfCode":2,"sourceCode":"compiler\r\t^self methodClass compiler"},{"name":"literalsEvenTheOnesInTheInnerBlocks","linesOfCode":12,"sourceCode":"literalsEvenTheOnesInTheInnerBlocks\r\r\t| literals numberLiterals |\r\tliterals := OrderedCollection new:\r\t\t            (numberLiterals := self numLiterals\r\t\t                               - self literalsToSkip).\r\t1 to: numberLiterals do: [ :index | \r\t\t| lit |\r\t\tlit := self literalAt: index.\r\t\tlit isEmbeddedBlock\r\t\t\tifTrue: [ literals addAll: lit literalsEvenTheOnesInTheInnerBlocks ]\r\t\t\tifFalse: [ literals addLast: lit ] ].\r\t^ literals asArray"},{"name":"gtInspectorASTIn:","linesOfCode":6,"sourceCode":"gtInspectorASTIn: composite\r\t<gtInspectorPresentationOrder: 35> \r\t(GTSimpleRBTreeBrowser new treeIn: composite)\r\t\ttitle: 'AST';\r\t\tdisplay: [ :anObject | {anObject ast} ]\r\t\t"},{"name":"bytecode","linesOfCode":9,"sourceCode":"bytecode\r\t\"Answer an ByteArray of the btyecode of the method.\"\r\r\t| start stop bytecode |\r\r\tstart := self initialPC.\r\tstop := self endPC.\r\t\r\tbytecode := ByteArray new: (stop - start + 1).\r\tstart to: stop do: [:index |\r\t\tbytecode byteAt: index - start + 1 put: (self byteAt: index)].\r\t^bytecode"},{"name":"endPC","linesOfCode":2,"sourceCode":"endPC\r\t^ self subclassResponsibility"},{"name":"hasSelector:","linesOfCode":3,"sourceCode":"hasSelector: selector \r\t\"Answers true if the method refers to the selector\"\r\t^ self hasSelector: selector specialSelectorIndex: (Smalltalk specialSelectorIndexOrNil: selector)"},{"name":"isQuick","linesOfCode":4,"sourceCode":"isQuick\r\t\"Answer whether the receiver is a quick return (of self or of an instance \r\tvariable).\"\r\t^ self primitive between: 256 and: 519"},{"name":"localSendsToSuper","linesOfCode":2,"sourceCode":"localSendsToSuper\r\t^ self encoderClass sendsToSuperFor: self"},{"name":"setSignFlag","linesOfCode":5,"sourceCode":"setSignFlag\r\t\"Set the sign flag bit.  The sign flag bit may be\r\t used by the VM to select an alternate bytecode set.\"\r\r\tself signFlag ifFalse:\r\t\t[self objectAt: 1 put: self header + SmallInteger minVal]"},{"name":"equivalentTo:","linesOfCode":6,"sourceCode":"equivalentTo: aCompiledMethod\r\t^self = aCompiledMethod\r\tor: [self class == aCompiledMethod class\r\t\tand: [self numArgs = aCompiledMethod numArgs\r\t\tand: [self numLiterals = aCompiledMethod numLiterals\r\t\tand: [self methodNode = aCompiledMethod methodNode ]]]]"},{"name":"origin","linesOfCode":2,"sourceCode":"origin\r\t^ self methodClass findOriginClassOf: self method"},{"name":"writesSlot:","linesOfCode":2,"sourceCode":"writesSlot: aSlot\r\t^aSlot isWrittenIn: self"},{"name":"rangeForPC:","linesOfCode":3,"sourceCode":"rangeForPC: aPC\t\r \t\"return which code to hightlight in the debugger\"\t\t\r \t^(self sourceNodeForPC: aPC) debugHighlightRange"},{"name":"propertyAt:ifAbsent:","linesOfCode":2,"sourceCode":"propertyAt: aString ifAbsent: aFullBlockClosure\r\t^ aFullBlockClosure value"},{"name":"indexOfLiteral:","linesOfCode":7,"sourceCode":"indexOfLiteral: literal\r\t\"Answer the literal index of the argument, literal, or zero if none.\"\r\t1 to: self numLiterals - self literalsToSkip \"exclude superclass + selector/properties\"\r\t   do:\r\t\t[:index |\r\t\tliteral == (self literalAt: index) ifTrue: [^index]].\r\t^0"},{"name":"objectAt:put:","linesOfCode":9,"sourceCode":"objectAt: index put: value \r\t\"Primitive. Store the value argument into a literal in the receiver. An \r\tindex of 2 corresponds to the first literal. Fails if the index is less than 2 \r\tor greater than the number of literals. Answer the value as the result. \r\tNormally only the compiler sends this message, because only the \r\tcompiler stores values in CompiledMethods. Essential. See Object \r\tdocumentation whatIsAPrimitive.\"\r\r\t<primitive: 69>\r\tself primitiveFailed"},{"name":"gtInspectorBytecodeIn:","linesOfCode":4,"sourceCode":"gtInspectorBytecodeIn: composite\r\t<gtInspectorPresentationOrder: 30> \r\t^ (GTBytecodeBrowser new treeIn: composite)\r\t\ttitle: 'Bytecode'"},{"name":"methodClass","linesOfCode":2,"sourceCode":"methodClass\r\tself subclassResponsibility"},{"name":"hasLiteralThorough:","linesOfCode":7,"sourceCode":"hasLiteralThorough: aLiteral\r\tself \r\t\tdeprecated: 'Use #refersToLiteral: instead.' \r\t\ton: '31 January 2020'\r\t\tin: #Pharo9\r\t\ttransformWith: '`@receiver hasLiteralThorough: `@arg' -> '`@receiver refersToLiteral: `@arg'.\r\t^ self refersToLiteral: aLiteral"},{"name":"primitiveErrorVariableName","linesOfCode":9,"sourceCode":"primitiveErrorVariableName\r\t\"Answer the primitive error code temp name, or nil if none.\"\r\tself isPrimitive ifTrue:\r\t\t[self pragmas do:\r\t\t\t[:pragma| | kwds ecIndex |\r\t\t\t((kwds := pragma selector keywords) first = 'primitive:'\r\t\t\tand: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:\r\t\t\t\t[^pragma argumentAt: ecIndex]]].\r\t^nil"},{"name":"withAllBlocksDo:","linesOfCode":3,"sourceCode":"withAllBlocksDo: aBlock \r\t\r\taBlock value: self.\r\tself allBlocksDo: aBlock\r\t"},{"name":"numArgs","linesOfCode":3,"sourceCode":"numArgs\r\t\"Answer the number of arguments the receiver takes.\"\r\r\t^ (self header bitShift: -24) bitAnd: 16r0F"},{"name":"packageFromOrganizer:","linesOfCode":13,"sourceCode":"packageFromOrganizer: anRPackageOrganizer\r\t| originSelector |\r\t\"This method returns the package this method belongs to.  \r\tIt takes into account classes and traits.  \r\tIf the method is in no package, returns nil by now\"\r\tself flag: 'TODO: use anRPackageOrganizer, or better delegate to anRPackageOrganizer'.\r\toriginSelector := self originMethod selector.\r\t\r\t^self origin packages \r\t\tdetect: [ :each | \r\t\t\tself origin isMeta\r\t\t\t\tifFalse: [ each includesSelector: originSelector ofClassName: self origin instanceSide originalName]\r\t\t\t\tifTrue: [ each includesSelector: originSelector ofMetaclassName: self origin instanceSide originalName]] \r\t\tifNone: [ nil ]"},{"name":"symbolic","linesOfCode":3,"sourceCode":"symbolic\r\t\"Answer a String that contains a list of all the byte codes in a method with a short description of each.\"\r\r\t^self longPrintString."},{"name":"gtInspectorVariableNodesIn:","linesOfCode":5,"sourceCode":"gtInspectorVariableNodesIn: aCollection\r\r\taCollection addAll: (self literals collectWithIndex: [ :aLiteral :anIndex | \r\t\tGTInspectorDynamicNode hostObject: self label: ('literal', anIndex asString) value: aLiteral ]).\r\tself initialPC to: self size do: [ :index |\r\t\taCollection add: (GTInspectorDynamicNode hostObject: self label: ('bc ', index asString) value: (self at: index) ) ] \r\t\r"},{"name":"sourceNodeForPC:","linesOfCode":2,"sourceCode":"sourceNodeForPC: arg1 \r\t^ self subclassResponsibility"},{"name":"localMessages","linesOfCode":9,"sourceCode":"localMessages\r\t\"Answer a Set of all the message selectors sent by this method.\"\r\r\t| scanner aSet |\r\taSet := IdentitySet new.\r\tscanner := InstructionStream on: self.\r\tscanner\tscanFor: [:x | \r\t\t\tscanner addSelectorTo: aSet.\r\t\t\tfalse\t\"keep scanning\"].\r\t^aSet"},{"name":"gtInspectorSourceIn:","linesOfCode":9,"sourceCode":"gtInspectorSourceIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t^ composite pharoMethod\r\t\ttitle: 'Source';\r\t\tsmalltalkClass: [ self methodClass ];\r\t\tdisplay: [ self sourceCode ];\r\t\tact: [ self browse ]\r\t\t\ticon: GLMUIThemeExtraIcons glamorousBrowse\r\t\t\tentitled: 'Browse'"},{"name":"signFlag","linesOfCode":4,"sourceCode":"signFlag\r\t\"Answer the sign flag bit.  The sign flag bit may be\r\t used by the VM to select an alternate bytecode set.\"\r\r\t^ self header < 0"},{"name":"objectAt:","linesOfCode":6,"sourceCode":"objectAt: index \r\t\"Primitive. Answer the method header (if index=1) or a literal (if index \r\t>1) from the receiver. Essential. See Object documentation \r\twhatIsAPrimitive.\"\r\r\t<primitive: 68>\r\tself primitiveFailed"},{"name":"isCollection","linesOfCode":4,"sourceCode":"isCollection\r\t\"We should override it because most of collection methods are not working for CompiledMethod. It is special class which needs to be ByteArray by VM. But it is not behaves like ByteArray from user perspective.\r\tAnd some tools uses isCollection check for specific behaviour which will fail for CompiledMethod\"\r\t^false"},{"name":"author","linesOfCode":8,"sourceCode":"author\r\t\"Answer the author of the current version of the receiver. retrieved from the sources or changes file. Answer the empty string if no time stamp is available.\"\r\r\t\"(CompiledMethod compiledMethodAt: #author) author\"\r\r\tself timeStamp ifNotEmpty: [:s | \r\t\t|subS|\r\t\tsubS := s substrings first. \r\t\tsubS first isLetter ifTrue:[^subS]].\r\t^''"},{"name":"inspectionSource","linesOfCode":10,"sourceCode":"inspectionSource\r\t<inspectorPresentationOrder: 30 title: 'Source'>\r\t\r\t^ SpCodePresenter new \r\t\tbeForBehavior: self methodClass;\r\t\ttext: self sourceCode;\r\t\tcontextMenu: (SpMenuPresenter new addGroup: [ :group | group \r\t\t\taddItem: [ :item | item \r\t\t\t\tname: 'Browse method class'; \r\t\t\t\taction: [ self methodClass browse ] ] ]);\r\t\tyourself"},{"name":"numLiterals","linesOfCode":3,"sourceCode":"numLiterals\r\t\"Answer the number of literals used by the receiver.\"\r\t^self header bitAnd: 16r7FFF"},{"name":"selector","linesOfCode":2,"sourceCode":"selector\r\t^ self subclassResponsibility"},{"name":"gtInspectorBytesIn:","linesOfCode":3,"sourceCode":"gtInspectorBytesIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t\"It makes no sense to view me as a collection of bytes\""},{"name":"originMethod","linesOfCode":2,"sourceCode":"originMethod\r\t^ self methodClass findOriginMethodOf: self method"},{"name":"readsThisContext","linesOfCode":4,"sourceCode":"readsThisContext\r\t\"Answer whether compiledMethod reads thisContext, look into embedded blocks, too\"\r\tself localReadsThisContext ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb readsThisContext]"},{"name":"accessesSlot:","linesOfCode":2,"sourceCode":"accessesSlot: aSlot\r\t^aSlot isAccessedIn: self\r\t"},{"name":"gtInspectorIrIn:","linesOfCode":7,"sourceCode":"gtInspectorIrIn: composite\r\t<gtInspectorPresentationOrder: 35> \r\tcomposite text \r\t\ttitle: 'Ir';\r\t\tdisplay: [ :anObject || string |\r\t\t\t\tstring := anObject ir longPrintString.\r\t\t\t\tstring copyFrom: 2 to: string size ]"},{"name":"usesSecondaryBytecodeSet","linesOfCode":2,"sourceCode":"usesSecondaryBytecodeSet\r\t^ self header < 0"},{"name":"longPrintOn:","linesOfCode":11,"sourceCode":"longPrintOn: aStream\r\t\"List of all the byte codes in a method with a short description of each\" \r\r\tself isQuick ifTrue: \r\t\t[self isReturnSpecial ifTrue:\r\t\t\t[^ aStream nextPutAll: 'Quick return ' , \r\t\t\t\t(#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255)].\r\t\t^ aStream nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)'].\r\r\tself isPrimitive ifTrue: [\r\t\tself printPrimitiveOn: aStream.\r\t].\r\tself symbolicBytecodes do: [ :each | each printOn: aStream ] separatedBy: [ aStream cr ]\r"},{"name":"readsSelf","linesOfCode":5,"sourceCode":"readsSelf\r\t\"Answer whether compiledMethod reads self, look into embedded blocks, too\"\r\tself isReturnSelf ifTrue: [ ^ true ].\r\tself localReadsSelf ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb readsSelf]"},{"name":"sourcePointer","linesOfCode":2,"sourceCode":"sourcePointer\r\t^ self subclassResponsibility "},{"name":"=","linesOfCode":16,"sourceCode":"= aCompiledMethod\r\t\"Answer whether the receiver implements the same code as aCompiledMethod.\"\r\r\tself == aCompiledMethod\r\t\tifTrue: [ ^ true ].\r\tself class = aCompiledMethod class\r\t\tifFalse: [ ^ false ].\r\tself size = aCompiledMethod size\r\t\tifFalse: [ ^ false ].\r\tself header = aCompiledMethod header\r\t\tifFalse: [ ^ false ].\r\tself initialPC to: self endPC do: [ :i | \r\t\t(self at: i) = (aCompiledMethod at: i)\r\t\t\tifFalse: [ ^ false ] ].\r\t(self sameLiteralsAs: aCompiledMethod)\r\t\tifFalse: [ ^ false ].\r\t^ true"},{"name":"readsField:","linesOfCode":6,"sourceCode":"readsField: varIndex \r\t\"Answer whether the receiver loads the instance variable indexed by the argument.\"\r\t| varIndexCode scanner |\r\tvarIndexCode := varIndex - 1.\r\t((scanner := InstructionStream on: self) scanFor: (self encoderClass instVarReadScanBlockFor: varIndexCode using: scanner)) ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb readsField: varIndex ]"},{"name":"compilerClass","linesOfCode":4,"sourceCode":"compilerClass\r\t^self methodClass \r\t\tifNil: [Smalltalk compilerClass] \r\t\tifNotNil: [:class | class compilerClass]."},{"name":"hasSelector:specialSelectorIndex:","linesOfCode":14,"sourceCode":"hasSelector: selector specialSelectorIndex: specialOrNil\r\t\"Answers true if the method refers to the selector.\r\t If you don't know what's a special selector, use #hasSelector:.\r\t If you do, you may call this method directly to avoid recomputing \r\t the special selector index all the time.\t\r\t I traverse the method and all the compiled blocks in the literals\"\t\r\t(self refersToLiteral: selector) ifTrue: [ ^ true ].\r\t\"refersToLiteral: traverses all blocks, but only for non-special literals\"\r\tspecialOrNil ifNil: [ ^ false ].\r\t\"if the selector is special, scan all blocks and myself\"\r\tself withAllBlocksDo: [ :aCompiledCode | \r\t\t(aCompiledCode scanFor: self encoderClass firstSpecialSelectorByte + specialOrNil)\r\t\t\tifTrue: [ ^true ] ].\r\t^false"},{"name":"inspectionPragmasContext:","linesOfCode":2,"sourceCode":"inspectionPragmasContext: aContext \r\t\r\taContext active: self hasPragmas"},{"name":"spotterItemsFor:","linesOfCode":2,"sourceCode":"spotterItemsFor: aStep\r\t\"do nothing for compiled method\""},{"name":"accessesField:","linesOfCode":3,"sourceCode":"accessesField: varIndex\r\t\"Answer whether the receiver accesses the instance variable indexed by the argument.\"\r\r\t^ (self readsField: varIndex) or: [ self writesField: varIndex ]"},{"name":"inspectionAST","linesOfCode":15,"sourceCode":"inspectionAST\r\t<inspectorPresentationOrder: 35 title: 'AST'>\r\r\t^ SpTreePresenter new \r\t\troots: { self ast };\r\t\tchildren: [ :aNode | aNode children ];\r\t\tdisplay: [ :each | \r\t\t\tString\r\t\t\t\tstreamContents: [ :stream | \r\t\t\t\t\tstream\r\t\t\t\t\t\tnextPutAll: each class name;\r\t\t\t\t\t\tnextPut: $(;\r\t\t\t\t\t\tnextPutAll: ((each formattedCode truncateTo: 50) copyReplaceAll: String cr with: String space);\r\t\t\t\t\t\tnextPut: $)\r\t\t\t ] ];\r\t\tyourself"},{"name":"readsSlot:","linesOfCode":2,"sourceCode":"readsSlot: aSlot\r\t^aSlot isReadIn: self"},{"name":"stepIntoQuickMethods","linesOfCode":2,"sourceCode":"stepIntoQuickMethods\r\t^self propertyAt: #stepIntoQuickMethod ifAbsent: [ false ]"},{"name":"innerCompiledBlocksDo:","linesOfCode":6,"sourceCode":"innerCompiledBlocksDo: aBlock\r\t\"We ignore the enclosing compiled code in compiled block by ignoring the last literal\"\r\t1 to: self numLiterals - self literalsToSkip do:\r\t\t[:index | | lit |\r\t\tlit := self literalAt: index.\r\t\tlit isEmbeddedBlock ifTrue: [ aBlock value: lit ] ]"},{"name":"sendsToSuper","linesOfCode":3,"sourceCode":"sendsToSuper\r\tself localSendsToSuper ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb sendsToSuper ]"},{"name":"hasLiteralSuchThat:","linesOfCode":10,"sourceCode":"hasLiteralSuchThat: litBlock\r\t\"Answer true if litBlock returns true for any literal in this method, even if embedded in array structure.\"\r\t1 to: self numLiterals - self literalsToSkip do: \"exclude header and methodClass or outerCode\"\r\t\t[:index | | lit |\r\t\tlit := self literalAt: index.\r\t\t((litBlock value: lit)\r\t\tor: [lit isArray and: [lit hasLiteralSuchThat: litBlock]]) ifTrue:\r\t\t\t[^true].\r\t\tlit isEmbeddedBlock ifTrue: [ (lit hasLiteralSuchThat: litBlock) ifTrue: [ ^true ] ]].\r\t^false"},{"name":"sameLiteralsAs:","linesOfCode":38,"sourceCode":"sameLiteralsAs: method\r\t\"Compare my literals to those of method. This is needed to compare compiled methods.\"\r\r\t| numLits literal1 literal2 |\r\t(numLits := self numLiterals) ~= method numLiterals\r\t\tifTrue: [ ^ false ].\r\t\"The last literal requires special checking instead of using #literalEqual:\"\r\t1 to: numLits - 1 do: [ :index | \r\t\tliteral1 := self literalAt: index.\r\t\tliteral2 := method literalAt: index.\r\t\t(literal1 == literal2 or: [ literal1 literalEqual: literal2 ])\r\t\t\tifFalse: [ \r\t\t\t\t(index = 1 and: [ self isNamedPrimitive | self isExternalCallPrimitive ])\r\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\tliteral1 isArray\r\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t(literal2 isArray and: [ literal1 allButLast = literal2 allButLast ])\r\t\t\t\t\t\t\t\t\tifFalse: [ ^ false ] ]\r\t\t\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t\t\t\"ExternalLibraryFunction\"\r\t\t\t\t\t\t\t\t(literal1 analogousCodeTo: literal2)\r\t\t\t\t\t\t\t\t\tifFalse: [ ^ false ] ] ]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\tindex = (numLits - 1)\r\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t\"properties\"\r\t\t\t\t\t\t\t\t\"don't create properties if they don't exist\"\r\t\t\t\t\t\t\t\t(literal1 isSymbol and: [ literal2 isSymbol ]) \r\t\t\t\t\t\t\t\t\tifTrue: [ ^ false ]\r\t\t\t\t\t\t\t\t\tifFalse: [\r\t\t\t\t\t\t\t\t\t\t(self properties analogousCodeTo: method properties) ifFalse: [ ^false ] ] ]\r\t\t\t\t\t\t\tifFalse: [ ^ false ] ] ] ].\r\t\"Class side methods have non unique (nil -> a Metaclass) as literal and cannot be compared equal\"\r\tliteral1 := self literalAt: numLits.\r\tliteral2 := method literalAt: numLits.\r\t^literal1 class == literal2 class\r\t     and: [literal1 isAssociation\r\t                ifTrue: [literal1 key = literal2 key and: [literal1 value = literal2 value]]\r\t                ifFalse: [literal1 = literal2]]"},{"name":"setFrameBit:","linesOfCode":7,"sourceCode":"setFrameBit: boolean \r\t\"true for large frame, else false\"\r\t| largeFrameBit newHeader |\r\tlargeFrameBit := 16r20000.\r\tnewHeader := self header bitAnd: largeFrameBit bitInvert.\r\tboolean ifTrue: [ newHeader := newHeader + largeFrameBit ].\r\tself objectAt: 1 put: newHeader."},{"name":"hasSourceCode","linesOfCode":2,"sourceCode":"hasSourceCode\r\t^ self subclassResponsibility"},{"name":"properties","linesOfCode":2,"sourceCode":"properties\r\t^ self subclassResponsibility"},{"name":"isReturnSelf","linesOfCode":3,"sourceCode":"isReturnSelf\r\t\"Answer whether the receiver is a quick return of self.\"\r\r\t^ self primitive = 256"},{"name":"pcPreviousTo:","linesOfCode":9,"sourceCode":"pcPreviousTo: pc\r\t| scanner client prevPc |\r\tpc > self endPC ifTrue: [^self endPC].\r\tscanner := InstructionStream on: self.\r\tclient := InstructionClient new.\r\t[scanner pc < pc] whileTrue:\r\t\t[prevPc := scanner pc.\r\t\t scanner interpretNextInstructionFor: client].\r\t^prevPc"},{"name":"accessesRef:","linesOfCode":5,"sourceCode":"accessesRef: literalVariable\r\t\"Answer whether this method accesses the LiteralVariable\"\r\t\"we do not need to call readsRef: or #writesRef:, as if the variable \r\tis stored as a Literal, it will be accessed. This check is much faster\"\r\r\t^ self hasLiteral: literalVariable"},{"name":"definition","linesOfCode":7,"sourceCode":"definition\r\r\t\"Polymorphic to class definition\"\r\r\tself\r\t\tdeprecated: #definition\r\t\ttransformWith:\r\t\t'`@receiver definition' -> '`@receiver definitionString'.\r\r\t^ self definitionString"},{"name":"headerDescription","linesOfCode":23,"sourceCode":"headerDescription\r\t\"Answer a description containing the information about the form of the \r\treceiver and the form of the context needed to run the receiver.\"\r\r\t| s |\r\ts := '' writeStream.\r\tself header printOn: s.\r\ts cr; nextPutAll: '\"signFlag: '.\r\tself signFlag printOn: s.\r\ts nextPutAll: ' ('.\r\tself encoderClass name printOn: s.\r\ts nextPut: $).\r\ts cr; nextPutAll: 'primitive: '.\r\tself primitive printOn: s.\r\ts cr; nextPutAll: ' numArgs: '.\r\tself numArgs printOn: s.\r\ts cr; nextPutAll: ' numTemps: '.\r\tself numTemps printOn: s.\r\ts cr; nextPutAll: ' numLiterals: '.\r\tself numLiterals printOn: s.\r\ts cr; nextPutAll: ' frameSize: '.\r\tself frameSize printOn: s.\r\ts nextPut: $\"; cr.\r\t^ s contents"},{"name":"primitive","linesOfCode":2,"sourceCode":"primitive\r\t^ self subclassResponsibility"},{"name":"localSendsAnySelectorOf:","linesOfCode":6,"sourceCode":"localSendsAnySelectorOf: aCollection\r\t\r\tself literalsDo: [ :lit |\r\t\t(lit isSymbol and: [ aCollection includes: lit ]) \r\t\t\tifTrue: [ ^ self messages includesAny: aCollection ]\r\t].\r\r\t^ false \r"},{"name":"bytecodesHash","linesOfCode":8,"sourceCode":"bytecodesHash\r\t\"Answer a 16-bit checksum of the bytecodes.\"\r\r\t^ CRC crc16FromCollection: (ByteArray \r\t\tnew: self size \r\t\tstreamContents: [ :stream | self \r\t\t\tfrom: self initialPC \r\t\t\tto: self endPC \r\t\t\tdo: [ :byte | stream nextPut: byte ] ])"},{"name":"gtInspectorItemsIn:","linesOfCode":2,"sourceCode":"gtInspectorItemsIn: composite\r\t\"It makes no sense to view me as a collection of items\""},{"name":"inspectionBytecode","linesOfCode":6,"sourceCode":"inspectionBytecode\r\t<inspectorPresentationOrder: 20 title: 'Bytecode'>\r\r\t^ SpListPresenter new \r\t\titems: self symbolicBytecodes;\r\t\tdisplay: [ :aBytecode | aBytecode printString ];\r\t\tyourself\r"},{"name":"header","linesOfCode":4,"sourceCode":"header\r\t\"Answer the word containing the information about the form of the \r\treceiver and the form of the context needed to run the receiver.\"\r\r\t^self objectAt: 1"},{"name":"methodNode","linesOfCode":2,"sourceCode":"methodNode\r\t^ self subclassResponsibility"},{"name":"literalStrings","linesOfCode":14,"sourceCode":"literalStrings\r\t\r\t| litStrs |\r\tself deprecated: 'Will be removed' on: ' 8 September 2020' in: 'Pharo 9'.\r\t\"as the implementation shows: this is very use case specific, the current implementation \r\tmakes no sense and has no users\"\r\tlitStrs := OrderedCollection new: self numLiterals.\r\tself literalsDo:\r\t\t[:lit | \r\t\t(lit isVariableBinding)\r\t\t\tifTrue: [litStrs addLast: lit key]\r\t\t\tifFalse: [(lit isSymbol)\r\t\t\t\tifTrue: [litStrs addAll: lit keywords]\r\t\t\t\tifFalse: [litStrs addLast: lit printString]]].\r\t^ litStrs"},{"name":"allLiterals","linesOfCode":8,"sourceCode":"allLiterals\r\t\"Answer an Array of the literals referenced by the receiver.\t\r\t including superclass + selector/properties\"\r\t| literals numberLiterals |\r\tliterals := Array new: (numberLiterals := self numLiterals).\r\t1 to: numberLiterals do: [:index |\r\t\tliterals at: index put: (self objectAt: index + 1)].\r\t^literals"},{"name":"method","linesOfCode":2,"sourceCode":"method\r\t^ self subclassResponsibility"},{"name":"definitionString","linesOfCode":3,"sourceCode":"definitionString\r\r\t\"Polymorphic to class definitionString\"\r\r\t^ self sourceCode"},{"name":"scanFor:","linesOfCode":4,"sourceCode":"scanFor: byte \r\t\"Answer whether the receiver contains the argument as a bytecode.\"\r\r\t^ (InstructionStream on: self) scanFor: [:instr | instr = byte]\r\"\rSmalltalk browseAllSelect: [:m | m scanFor: 134]\r\""},{"name":"needsFrameSize:","linesOfCode":6,"sourceCode":"needsFrameSize: newFrameSize\r\t\"Set the largeFrameBit to accomodate the newFrameSize\"\r\t(self numTemps + newFrameSize) > LargeFrame ifTrue:\r\t\t[^ self error: 'Cannot compile -- stack including temps is too deep'].\r\tself setFrameBit: ((self numTemps + newFrameSize) > SmallFrame \r\t\tor: [ self primitive = 84 \"perform:withArguments:\"])"},{"name":"localReadsSelf","linesOfCode":2,"sourceCode":"localReadsSelf\r\t^ self encoderClass readsSelfFor: self"},{"name":"numTemps","linesOfCode":3,"sourceCode":"numTemps\r\t\"Answer the number of temporary variables used by the receiver.\"\r\t\r\t^ (self header bitShift: -18) bitAnd: 16r3F"},{"name":"frameSize","linesOfCode":6,"sourceCode":"frameSize\r\t\"Answer the size of temporary frame needed to run the receiver.\"\r\t\"NOTE:  Versions 2.7 and later use two sizes of contexts.\"\r\r\t(self header noMask: 16r20000)\r\t\tifTrue: [^ SmallFrame]\r\t\tifFalse: [^ LargeFrame]\r"},{"name":"hasPragmaNamed:","linesOfCode":2,"sourceCode":"hasPragmaNamed: arg1 \r\t^ self subclassResponsibility"},{"name":"abstractBytecodeMessagesDo:","linesOfCode":10,"sourceCode":"abstractBytecodeMessagesDo: aBlock\r\t\"Evaluate aBlock with the sequence of abstract bytecodes in the receiver\"\r\tself abstractBytecodeMessagesFrom: self initialPC\r\t\tto: self endPC\r\t\tdo: aBlock\r\r\t\"| msgs |\r\t msgs := OrderedCollection new.\r\t CompiledMethod >> #abstractBytecodeMessagesFrom:to: abstractBytecodeMessagesDo:\r\t\t[:msg| msgs add: msg selector].\r\t msgs\""},{"name":"debuggerMap","linesOfCode":2,"sourceCode":"debuggerMap\r\t^self compilerClass debuggerMethodMapForMethod: self."},{"name":"messages","linesOfCode":6,"sourceCode":"messages\r\t\"Answer a Set of all the message selectors sent by this method.\"\r\t| aSet |\r\taSet := self localMessages.\r\tself innerCompiledBlocksDo: [ :cb | aSet := aSet , cb messages ].\r\t^ aSet "},{"name":"isExternalCallPrimitive","linesOfCode":2,"sourceCode":"isExternalCallPrimitive\r\t^self primitive = 120"},{"name":"hash","linesOfCode":16,"sourceCode":"hash\r\t\"CompiledMethod>>#= compares code, i.e. same literals and same bytecode.\r\t So we look at the header, methodClass and some bytes between initialPC and endPC,\r\t but /not/ the selector because the equal method does not compare selectors.\r\t Note that we must override ByteArray>hash which looks at all bytes of the receiver.\r\t Using bytes from the pointer part of a COmpiledmethod can lead to a variable hash\r\t if and when when the GC moves literals in the receiver.\"\r\t| initialPC endPC hash |\r\tinitialPC := self initialPC.\r\tendPC := self endPC.\r\thash := self species hash + self header + initialPC + endPC + self methodClass hash bitAnd: 16rFFFFFFF.\r\t\"sample approximately 20 bytes\"\r\tinitialPC to: endPC by: (endPC - initialPC // 20 max: 1) do:\r\t\t[:i| hash := hash + (self at: i)].\r\t^hash\r\r\t\"(CompiledMethod>>#hash) hash\"\r"},{"name":"localReadsRef:","linesOfCode":7,"sourceCode":"localReadsRef: literalAssociation \r\t\"Answer whether the receiver loads the argument.\"\r\t| litIndex scanner |\r\t(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:\r\t\t[^false].\r\tlitIndex := litIndex - 1.\r\t^(scanner := InstructionStream on: self) scanFor: (self encoderClass bindingReadScanBlockFor: litIndex using: scanner)"},{"name":"sendsSelector:","linesOfCode":3,"sourceCode":"sendsSelector: aSymbol \t\r\t\"Answer whether the method sends a particular selector\"\r\t^ self messages includes: aSymbol"},{"name":"isPrimitive","linesOfCode":2,"sourceCode":"isPrimitive\r\t^self primitive > 0"},{"name":"literals","linesOfCode":10,"sourceCode":"literals\r\r\t\"Answer an Array of the literals referenced by the receiver.\t\r\t Exclude superclass + selector/properties\"\r\r\t| literals numberLiterals |\r\tliterals := Array new:\r\t\t            (numberLiterals := self numLiterals\r\t\t                               - self literalsToSkip).\r\t1 to: numberLiterals do: [ :index | \r\tliterals at: index put: (self literalAt: index) ].\r\t^ literals"},{"name":"hasPragmas","linesOfCode":2,"sourceCode":"hasPragmas\r\r\t^ self pragmas notEmpty"},{"name":"localHasInstVarRef","linesOfCode":3,"sourceCode":"localHasInstVarRef\r\t\"Answer whether the method references an instance variable.\"\r\r\t\r\t^ InstVarRefLocator check: self"},{"name":"literalAt:","linesOfCode":3,"sourceCode":"literalAt: index \r\t\"Answer the literal indexed by the argument.\"\r\r\t^self objectAt: index + 1"},{"name":"innerCompiledBlocksAnySatisfy:","linesOfCode":3,"sourceCode":"innerCompiledBlocksAnySatisfy: aBlock\r\tself innerCompiledBlocksDo: [ :cb | (aBlock value: cb) ifTrue: [ ^ true ] ].\r\t^ false"},{"name":"localWritesRef:","linesOfCode":7,"sourceCode":"localWritesRef: literalAssociation \r\t\"Answer whether the receiver stores into the argument.\"\r\t| litIndex scanner |\r\t(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:\r\t\t[^false].\r\tlitIndex := litIndex - 1.\r\t^(scanner := InstructionStream on: self) scanFor: (self encoderClass bindingWriteScanBlockFor: litIndex using: scanner)"},{"name":"inspectionHeader","linesOfCode":5,"sourceCode":"inspectionHeader\r\t<inspectorPresentationOrder: 40 title: 'Header'> \r\t\r\t^ SpTextPresenter new \r\t\ttext: self headerDescription;\r\t\tyourself"},{"name":"inspectorNodes","linesOfCode":16,"sourceCode":"inspectorNodes\r\t\"Answer a list of attributes as nodes\"\r\t| nodes |\r\r\tnodes := OrderedCollection new.\r\tnodes addAll: (self literals \r\t\tcollectWithIndex: [ :aLiteral :anIndex | \r\t\t\tStInspectorDynamicNode \r\t\t\t\thostObject: self \r\t\t\t\tlabel: ('literal', anIndex asString) \r\t\t\t\tvalue: aLiteral ]).\r\t\r\tself initialPC to: self size do: [ :index |\r\t\tnodes add: (StInspectorDynamicNode \r\t\t\thostObject: self \r\t\t\tlabel: ('bc ', index asString) \r\t\t\tvalue: (self at: index) ) ] .\r\t\r\t^ nodes"},{"name":"asString","linesOfCode":2,"sourceCode":"asString\r\r\t  ^self sourceCode"},{"name":"literalsAt:","linesOfCode":3,"sourceCode":"literalsAt: anIndex\r\t\"All literals are shifted of one slot. First slot is the method header\"\r\t^ self objectAt: anIndex + 1"},{"name":"inspectionPragmas","linesOfCode":6,"sourceCode":"inspectionPragmas\r\t<inspectorPresentationOrder: 30 title: 'Pragmas'> \r\r\t^ SpListPresenter new\r\t\titems: self pragmas;\r\t\tdisplay: [ :aPragma | aPragma printString ];\r\t\tyourself"},{"name":"timeStamp","linesOfCode":4,"sourceCode":"timeStamp\r\t\"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available.\"\r\t\"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp\"\r\r\t^ SourceFiles timeStampAt: self sourcePointer."},{"name":"allBlocksDo:","linesOfCode":4,"sourceCode":"allBlocksDo: aBlock\r\r\tself literals \r\t\tselect: [ :aLiteral | aLiteral isEmbeddedBlock ] \r\t\tthenDo: [ :aLiteral | aLiteral withAllBlocksDo: aBlock  ]"},{"name":"readsRef:","linesOfCode":4,"sourceCode":"readsRef: literalAssociation \r\t\"Answer whether the receiver loads the argument.\"\r\t(self localReadsRef: literalAssociation) ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb readsRef: literalAssociation ]"},{"name":"isTestMethod","linesOfCode":2,"sourceCode":"isTestMethod\r\t^ self subclassResponsibility"},{"name":"localReadsThisContext","linesOfCode":2,"sourceCode":"localReadsThisContext\r\t^ self encoderClass readsThisContextFor: self"},{"name":"sourceCode","linesOfCode":2,"sourceCode":"sourceCode\r\t^ self subclassResponsibility"},{"name":"writesRef:","linesOfCode":4,"sourceCode":"writesRef: literalAssociation \r\t\"Answer whether the receiver stores into the argument.\"\r\t(self localWritesRef: literalAssociation) ifTrue: [ ^ true ].\r\t^ self innerCompiledBlocksAnySatisfy: [ :cb | cb writesRef: literalAssociation ]"}],"meta":{"name":"CompiledCode class","instanceVariables":[],"methods":[{"name":"newMethod:header:","linesOfCode":12,"sourceCode":"newMethod: numberOfBytes header: headerWord\r\t\"Primitive. Answer an instance of me. The number of literals (and other \r\t information) is specified by the headerWord (see my class comment).\r\t The first argument specifies the number of fields for bytecodes in the\r\t method. Fail if either argument is not a SmallInteger, or if numberOfBytes\r\t is negative, or if memory is low. Once the header of a method is set by\r\t this primitive, it cannot be changed to change the number of literals.\r\t Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 79 error: ec>\r\tec == #'insufficient object memory' ifTrue:\r\t\t[^self handleFailingNewMethod: numberOfBytes header: headerWord].\r\t^self primitiveFailed"}],"meta":null}},{"name":"ExternalAddress","instanceVariables":[],"methods":[{"name":"pointer","linesOfCode":15,"sourceCode":"pointer\r\t\"Answers a pointer to the this address. \r\t Sometimes, an ExternalAddress represents a pointer, so you do not need this, but some others \r\t it represents just an address. Yes, I know, difference is subtle. \r\t Take this as an example:\r\t\t\r\t\tSQSurfaceDispatch externalNew. \r\r\t This will answer an instance if FFIExternalStructure with an ExternalAddress as handle, but \r\t this handle WILL NOT represent a pointer address, just an address. \r\t This is why, later in a call where I use the surface: \r\t\r\t\tAthensCairoSurface>>#initializeForNewSession\r\t\r\t... I need to keep a pointer to the surface, just the external address is not enough.\"\r\t^ (ExternalAddress allocate: self size)\r\t\tpointerAt: 1 put: self;\r\t\tyourself"},{"name":"signedShortAt:put:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex put: value\r\t^ self int16AtOffset: byteIndex - 1 put: value"},{"name":"uint8AtOffset:put:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset put: value\r\t<primitive: 646>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: false"},{"name":"fromInteger:","linesOfCode":16,"sourceCode":"fromInteger: address\r\t\"set my handle to point at address.\"\r\t\"Do we really need this? bf 2/21/2001 23:48\"\r\r\t| sz pointer |\r\tsz := self size.\r\tpointer := ByteArray new: sz.\r\tpointer integerAt: 1 put: address size: sz signed: false.\r\tself basicAt: 1 put: (pointer byteAt: 1);\r\t\tbasicAt: 2 put: (pointer byteAt: 2);\r\t\tbasicAt: 3 put: (pointer byteAt: 3);\r\t\tbasicAt: 4 put: (pointer byteAt: 4).\r\tsz = 8 ifTrue:\r\t\t[self basicAt: 5 put: (pointer byteAt: 5);\r\t\t\tbasicAt: 6 put: (pointer byteAt: 6);\r\t\t\tbasicAt: 7 put: (pointer byteAt: 7);\r\t\t\tbasicAt: 8 put: (pointer byteAt: 8)]"},{"name":"pointerAtOffset:put:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset put: value\r\t<primitive: 654>\r\t\"Store a pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\tself unsignedByteAt: zeroBasedOffset+i put: (value basicAt: i)].\r\t^value"},{"name":"thunk","linesOfCode":2,"sourceCode":"thunk\r\t^ self"},{"name":"isNull","linesOfCode":4,"sourceCode":"isNull\r\t\"Answer true if I am a null pointer\"\r\t1 to: self size do:[:i| (self at: i) = 0 ifFalse:[^false]].\r\t^true"},{"name":"float32AtOffset:put:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset put: value\r\t<primitive: 658>\r\t\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1 put: value"},{"name":"float64AtOffset:","linesOfCode":3,"sourceCode":"float64AtOffset: zeroBasedOffset\r\t<primitive: 644>\r\t\r\t^ FFIBackend current on: self float64At: zeroBasedOffset + 1\r"},{"name":"int32AtOffset:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset\r\t<primitive: 636>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: true"},{"name":"shallowCopy","linesOfCode":4,"sourceCode":"shallowCopy\r\t\"Re-implemented to avoid superclass call to #new:\"\r\t\"But superclass's shallowCopy sends basicNew: and basicNew: is ok. eem 2/21/2016 15:31\"\r\t^self clone"},{"name":"asInteger","linesOfCode":3,"sourceCode":"asInteger\r\t\"convert address to integer\"\r\t^ self asByteArrayPointer integerAt: 1 size: self size signed: false"},{"name":"uint16AtOffset:put:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset put: value\r\t<primitive: 648>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: false"},{"name":"=","linesOfCode":6,"sourceCode":"= other\r\r\tself == other ifTrue: [ ^ true ].\r\tself species == other species ifFalse: [ ^ false ].\r\t1 to: self size do: [ :index | \r\t\t(self at: index) = (other at: index) ifFalse: [ ^ false ] ].\r\t\r\t^ true"},{"name":"asByteArrayPointer","linesOfCode":5,"sourceCode":"asByteArrayPointer\r\t\"Answer a ByteArray containing a copy of pointer to the contents of the receiver.\"\r\t| sz |\r\t^(ByteArray basicNew: (sz := self size))\r\t\treplaceFrom: 1 to: sz with: self startingAt: 1 \"answers self\""},{"name":"floatAt:put:","linesOfCode":3,"sourceCode":"floatAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self float32AtOffset: byteIndex - 1 put: value"},{"name":"clone","linesOfCode":3,"sourceCode":"clone\r\r\t<primitive: 148>\r\tself primitiveFailed"},{"name":"boolean8AtOffset:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset\r\t<primitive: 630>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) ~= 0"},{"name":"autoRelease","linesOfCode":2,"sourceCode":"autoRelease\r\t^ self class finalizationRegistry add: self"},{"name":"pointerAt:","linesOfCode":3,"sourceCode":"pointerAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self pointerAtOffset: byteIndex - 1"},{"name":"beNull","linesOfCode":3,"sourceCode":"beNull\r\t\"Make the receiver a NULL pointer\"\r\tself atAllPut: 0."},{"name":"isExternalAddress","linesOfCode":3,"sourceCode":"isExternalAddress\r\t\"Return true if the receiver describes the address of an object in the outside world\"\r\t^true"},{"name":"oldFree","linesOfCode":6,"sourceCode":"oldFree\r\t\"Primitive. Free the object pointed to on the external heap.\r\tDangerous - may break your system if the receiver hasn't been\r\tallocated by ExternalAddress class>>allocate:. No checks are done.\"\r\t<primitive:'primitiveFFIFree' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"int16AtOffset:put:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset put: value\r\t<primitive: 649>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: true"},{"name":"int8AtOffset:put:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset put: value\r\t<primitive: 647>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: true"},{"name":"uint32AtOffset:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset\r\t<primitive: 635>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: false"},{"name":"unpackFromArity:","linesOfCode":8,"sourceCode":"unpackFromArity: arity\r\t\"This will 'unpack' a pointer from a certain arity. See #unpackToArity: for a better explanation.\"\r\t| rolledPointer |\r\t\t\r\trolledPointer := self.\r\t\"Start in 2 because first pointer is self\"\r\t2 to: arity do: [ :index | rolledPointer := rolledPointer pointerAt: 1 ].\r\t^ rolledPointer\t"},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream\r\t\"print this as a hex address ('@ 16rFFFFFFFF') to distinguish it from ByteArrays\"\r\r\taStream nextPutAll: '@ '; nextPutAll: (self asInteger storeStringBase: 16 length: 11 padded: true)"},{"name":"booleanAt:","linesOfCode":3,"sourceCode":"booleanAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self boolean8AtOffset: byteIndex - 1"},{"name":"int64AtOffset:put:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset put: value\r\t<primitive: 653>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: true"},{"name":"free","linesOfCode":2,"sourceCode":"free\r\r\t^ FFIBackend current free: self"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":11,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t| dstAddress srcAddress repSize |\r\t\r\tself flag: #pharoTodo. \"Maybe replace it with a primitive (like the one at Alien)?\"\r\trepSize := stop - start + 1.\r\tdstAddress := start = 1 \r\t\tifTrue: [ self ] \r\t\tifFalse: [ self + (start - 1) ].\r\tsrcAddress := repStart = 1 \r\t\tifTrue: [ replacement ] \r\t\tifFalse: [ replacement copyFrom: repStart to: repStart + repSize ].\t\r\tLibC memCopy: srcAddress to: dstAddress size: repSize"},{"name":"signedLongAt:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex\r\t^ self int32AtOffset: byteIndex - 1"},{"name":"unsignedLongLongAt:put:","linesOfCode":3,"sourceCode":"unsignedLongLongAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint64AtOffset: byteIndex - 1 put: value"},{"name":"fromAddress:","linesOfCode":2,"sourceCode":"fromAddress: aNumber\r\t^ self fromInteger: aNumber"},{"name":"unsignedLongAt:put:","linesOfCode":3,"sourceCode":"unsignedLongAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint32AtOffset: byteIndex - 1 put: value"},{"name":"signedLongAt:put:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex put: value\r\t^ self int32AtOffset: byteIndex - 1 put: value"},{"name":"char8AtOffset:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset\r\t<primitive: 640>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) asCharacter"},{"name":"pointerAt:put:","linesOfCode":3,"sourceCode":"pointerAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self pointerAtOffset: byteIndex - 1 put: value"},{"name":"uint16AtOffset:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset\r\t<primitive: 633>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: false"},{"name":"unsignedShortAt:","linesOfCode":3,"sourceCode":"unsignedShortAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint16AtOffset: byteIndex - 1"},{"name":"byteAt:put:","linesOfCode":3,"sourceCode":"byteAt: byteOffset put: value\r\t\"Go through a different primitive since the receiver describes data in the outside world\"\r\t^self unsignedByteAt: byteOffset put: value"},{"name":"doubleAt:put:","linesOfCode":3,"sourceCode":"doubleAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self float64AtOffset: byteIndex - 1 put: value"},{"name":"registerAsExternalResource","linesOfCode":8,"sourceCode":"registerAsExternalResource\r\tself\r\t\tdeprecated: 'Use #autoRelease instead.'\r\t\ton: '2016-01-22'\r\t\tin: #Pharo5\r\t\ttransformWith: '`@rec registerAsExternalResource' -> '`@rec autoRelease'.\r\t  \r\t^ self class finalizationRegistry add: self"},{"name":"pointerAutoRelease","linesOfCode":3,"sourceCode":"pointerAutoRelease\r\t\"Same as #pointer (see its comment for detals), but contents are garbage collected automatically\"\r\t^ self pointer autoRelease"},{"name":"fromCString","linesOfCode":8,"sourceCode":"fromCString\r\t| index aByte |\r\r\t^ (ByteArray streamContents: [ :aStream |\r\t\t\tindex := 1.\r\t\t\t[(aByte := self unsignedByteAt: index) = 0] \r\t\t\t\twhileFalse: [\r\t\t\t\t\taStream nextPut: aByte.\r\t\t\t\t\tindex := index + 1]]) utf8Decoded\r"},{"name":"char32AtOffset:put:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset put: value\r\t<primitive: 657>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 4 signed: false"},{"name":"signedLongLongAt:put:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex put: value\r\t^ self int64AtOffset: byteIndex - 1 put: value"},{"name":"unsignedByteAt:","linesOfCode":3,"sourceCode":"unsignedByteAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint8AtOffset: byteIndex - 1"},{"name":"packToArity:","linesOfCode":22,"sourceCode":"packToArity: arity\r\t\"This will 'pack' a pointer to a certain arity. \r\tWhat does this means? Let's say I have a method who will be called with a ** arity (that's 'arity 2'): \r\t\r\tmethod: aPointer\r\t\tself ffiCall: #( method ( MyExternalObjectClass **aPointer) )\r\t\t\r\tThis usually means that method will put a pointer in the address of aPointer. \r\tAnd what I actually want is this pointer. So I do Something like this: \r\t\r\tp := MyExternalObjectClass new.\r\tself mehod: p.\r\t\r\tAnd I expect to have 'p' correctly initialised on return. \r\tWell... tha's not so simple :)\r\t\r\tWhen compiling #method:, UnifiedFFI needs to first 'pack' the pointer (which means to \r\ttake a pointer of a pointer of a pointer... as many pointers as arity solicited), and then, \r\tafter call, it needs to 'unpack' all this pointers (see #unpackFromArity: method)  \r\t\"\r\t| rolledPointer |\r\t\t\r\trolledPointer := self.\r\t\"Start in 2 because first pointer is self\"\r\t2 to: arity do: [ :index | rolledPointer := rolledPointer pointerAutoRelease ].\r\t^ rolledPointer"},{"name":"adoptAddress:","linesOfCode":4,"sourceCode":"adoptAddress: anExternalAddress\r\tanExternalAddress = 0 ifTrue: [ ^ self beNull ].\r\t1 to: self size do: [ :index | \r\t\tself basicAt: index put: (anExternalAddress at: index) ]"},{"name":"float32AtOffset:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset\r\t<primitive: 643>\r\t\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1"},{"name":"char16AtOffset:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset\r\t<primitive: 641>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 2 signed: false) asCharacter"},{"name":"unsignedLongLongAt:","linesOfCode":3,"sourceCode":"unsignedLongLongAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint64AtOffset: byteIndex - 1"},{"name":"signedCharAt:","linesOfCode":2,"sourceCode":"signedCharAt: byteOffset\r\t^ self char8AtOffset: byteOffset - 1"},{"name":"signedShortAt:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex\r\t^ self int16AtOffset: byteIndex - 1"},{"name":"float64AtOffset:put:","linesOfCode":6,"sourceCode":"float64AtOffset: zeroBasedOffset put: value\r\r\t<primitive: 659>\r\t^ FFIBackend current\r\t\t  on: self\r\t\t  float64At: zeroBasedOffset + 1\r\t\t  put: value"},{"name":"uint64AtOffset:put:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset put: value\r\t<primitive: 652>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: false"},{"name":"signedLongLongAt:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex\r\t^ self int64AtOffset: byteIndex - 1"},{"name":"char16AtOffset:put:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset put: value\r\t<primitive: 656>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 2 signed: false"},{"name":"uint32AtOffset:put:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset put: value\r\t<primitive: 650>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: false"},{"name":"pointerAtOffset:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset\r\t<primitive: 639>\r\t\"Answer a pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress new.\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: zeroBasedOffset+i)].\r\t^addr"},{"name":"signedCharAt:put:","linesOfCode":2,"sourceCode":"signedCharAt: byteIndex put: aCharacter\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"tfPointerAddress","linesOfCode":2,"sourceCode":"tfPointerAddress\r\r\t^ self"},{"name":"int16AtOffset:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset\r\t<primitive: 634>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: true"},{"name":"readArrayOf:until:","linesOfCode":24,"sourceCode":"readArrayOf: aType until: aBlock\r\t\"Reads an array of aType until aBlock returns true.\r\t this is an util to extract arrays from answers style char ** or int*, etc. \r\t Example: \r\t\r\t\tsomeAddress readArrayOf: #uint32 until: [ :each | each isZero ].\r\t\tsomeAddress readArrayOf: #'void *' until: [ :each | each isNull ].\r\t\"\r\r\t| externalType |\r\t\"resolve type if needed\"\r\texternalType := aType isString\r\t\tifTrue: [ FFIExternalType resolveType: aType ]\r\t\tifFalse: [ aType ].\r\r\t\"then build the array\"\r\t^ Array\r\t\tstreamContents: [ :array | \r\t\t\t| address last count |\r\t\t\taddress := self.\r\t\t\tcount := 0.\r\t\t\t[ address isNull\r\t\t\t\tor: [ last := externalType handle: address at: 1.\r\t\t\t\t\tcount := count + 1.\r\t\t\t\t\taBlock cull: last cull: count ] ]\r\t\t\t\twhileFalse: [ array nextPut: last.\r\t\t\t\t\taddress := address + externalType typeSize ] ]"},{"name":"uint64AtOffset:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset\r\t<primitive: 637>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: false"},{"name":"unpackHandleFromArity:","linesOfCode":2,"sourceCode":"unpackHandleFromArity: arity\r\t^ (self unpackFromArity: arity) unsignedLongAt: 1\r\t"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: byteOffset\r\t\"Go through a different primitive since the receiver describes data in the outside world\"\r\t^self unsignedByteAt: byteOffset"},{"name":"doubleAt:","linesOfCode":3,"sourceCode":"doubleAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self float64AtOffset: byteIndex - 1"},{"name":"unsignedByteAt:put:","linesOfCode":3,"sourceCode":"unsignedByteAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint8AtOffset: byteIndex - 1 put: value"},{"name":"+","linesOfCode":13,"sourceCode":"+ offset\r\t\"Create an address that is offset by the given number of bytes.\r\tMore tricky than one would think due to the FFI's handling of ExternalAddress\r\tas pointer to an object so that 'self unsignedLongAt: ' would dereference.\"\r\r\t| bytes |\r\t\"Convert xaddr -> bytes\"\r\tbytes := self asByteArrayPointer.\r\t\"Update bytes using platform dependent accessors\"\r\tself size = 4\r\t\tifTrue: [bytes unsignedLongAt: 1 put: (bytes unsignedLongAt: 1) + offset]\r\t\tifFalse: [bytes unsignedLongLongAt: 1 put: (bytes unsignedLongLongAt: 1) + offset].\r\t\"Convert bytes -> xaddr\"\r\t^bytes asExternalPointer"},{"name":"asExternalPointer","linesOfCode":3,"sourceCode":"asExternalPointer\r\t\"No need to convert.\"\r\t^self"},{"name":"int64AtOffset:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset\r\t<primitive: 638>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: true"},{"name":"uint8AtOffset:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset\r\t<primitive: 631>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: false"},{"name":"unsignedLongAt:","linesOfCode":3,"sourceCode":"unsignedLongAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint32AtOffset: byteIndex - 1"},{"name":"char32AtOffset:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset\r\t<primitive: 642>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 4 signed: false) asCharacter"},{"name":"unsignedCharAt:put:","linesOfCode":3,"sourceCode":"unsignedCharAt: byteIndex put: aCharacter\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"unsignedCharAt:","linesOfCode":3,"sourceCode":"unsignedCharAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self char8AtOffset: byteIndex - 1"},{"name":"copyFrom:to:","linesOfCode":6,"sourceCode":"copyFrom: startIndex to: endIndex\r\t| result size |\r\tsize := endIndex - startIndex + 1.\r\tresult := ByteArray new: size. \r\tLibC memCopy: (self + (startIndex - 1)) to: result size: size.\r\t^ result"},{"name":"asExternalAddress","linesOfCode":2,"sourceCode":"asExternalAddress\r\r\t^ self"},{"name":"booleanAt:put:","linesOfCode":3,"sourceCode":"booleanAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self boolean8AtOffset: byteIndex - 1 put: value"},{"name":"finalize","linesOfCode":5,"sourceCode":"finalize\r\t\"I am an executor (a copy) of an ExternalAddress that was just garbage collected.\r\tI must finalize. my mission is to free memory\"\r\tself isNull ifTrue: [^self].\r\tself free"},{"name":"getHandle","linesOfCode":2,"sourceCode":"getHandle\r\t\r\t^ self"},{"name":"int8AtOffset:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset\r\t<primitive: 632>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: true"},{"name":"boolean8AtOffset:put:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset put: value\r\t<primitive: 645>\r\t^ self integerAt: zeroBasedOffset + 1 put: (value ifTrue:[1] ifFalse:[0]) size: 1 signed: false"},{"name":"floatAt:","linesOfCode":3,"sourceCode":"floatAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self float32AtOffset: byteIndex - 1"},{"name":"unsignedShortAt:put:","linesOfCode":3,"sourceCode":"unsignedShortAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self uint16AtOffset: byteIndex - 1 put: value"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\t^ self asInteger"},{"name":"gcpointer","linesOfCode":6,"sourceCode":"gcpointer\r\t\"Same as #pointer (see its comment for detals), but contents are garbage collected automatically\"\r\tself deprecated: 'Use \"pointer autoRelease\" instead.' on: '2016-01-22' in: #Pharo5.  \r\t^ (ExternalAddress gcallocate: self size)\r\t\tpointerAt: 1 put: self;\r\t\tyourself"},{"name":"int32AtOffset:put:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset put: value\r\t<primitive: 651>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: true"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^ aGeneralMapper\r\t\tvisitSubstitution: self\r\t\tby: self class null\r\t\tonRecursionDo: [ ^ aGeneralMapper visitFixedObject: self ]"},{"name":"char8AtOffset:put:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset put: value\r\t<primitive: 655>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 1 signed: false"}],"meta":{"name":"ExternalAddress class","instanceVariables":[{"name":"wordSize"}],"methods":[{"name":"new:","linesOfCode":5,"sourceCode":"new: n\r\t\"Only create ExternalAddresses of the right size.\"\r\t^n = self wordSize\r\t\tifTrue: [super new: n]\r\t\tifFalse: [self shouldNotImplement]"},{"name":"loadSymbol:","linesOfCode":5,"sourceCode":"loadSymbol: moduleSymbol\r\t\"Load global symbol (one that you can find in current VM binary)\"\r\t^ self \r\t\tloadSymbol: moduleSymbol \r\t\tmodule: nil"},{"name":"gcallocate:","linesOfCode":8,"sourceCode":"gcallocate: byteSize\r\t\"Primitive. Allocate an object on the external heap.\r\tThe external memory will be freed when i am garbage collected.\r\tBEWARE: there should be no copy of self, nor any pointer to a sub part...\"\r\t\r\t| externalAddress |\r\texternalAddress := self allocate: byteSize.\r\tself finalizationRegistry add: externalAddress.\r\t^externalAddress"},{"name":"loadSymbol:module:","linesOfCode":2,"sourceCode":"loadSymbol: moduleSymbol module: module \r\r\t^ FFIBackend current loadSymbol: moduleSymbol module: module "},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"External addresses are either four or eight bytes long.\"\r\t^super new: self wordSize"},{"name":"allocate:bytesDuring:","linesOfCode":4,"sourceCode":"allocate: byteSize bytesDuring: aBlock\r\r\t| address |\r\taddress := self allocate: byteSize.\r\t^ [ aBlock value: address ] ensure: [ address free ]"},{"name":"startUp:","linesOfCode":6,"sourceCode":"startUp: resuming\r\t\"If starting the image afresh all external addresses should be zero.\r\t In addition, if the word size has changed then external addresses shoiuld be resized.\r\t The two steps are combined for efficiency.\"\r\tresuming ifTrue: [\r\t\tself allInstancesDo: [ :each | each beNull ]]"},{"name":"allocate:","linesOfCode":2,"sourceCode":"allocate: byteSize\r\t\r\t^ FFIBackend current allocate: byteSize"},{"name":"loadSymbol:from:","linesOfCode":4,"sourceCode":"loadSymbol: moduleSymbol from: moduleNameOrClass \r\t^ self \r\t\tloadSymbol: moduleSymbol \r\t\tmodule: moduleNameOrClass asFFILibrary libraryName.\r\t"},{"name":"wordSize","linesOfCode":2,"sourceCode":"wordSize\r\t^wordSize ifNil: [ wordSize := Smalltalk wordSize ]"},{"name":"fromAddress:","linesOfCode":3,"sourceCode":"fromAddress: aNumber\r\t\"Answers an external address who points to aNumber\"\r\t^ self new fromAddress: aNumber"},{"name":"newPointer","linesOfCode":2,"sourceCode":"newPointer\r\t^ self allocate: self wordSize "},{"name":"null","linesOfCode":2,"sourceCode":"null\r\t^ self new"},{"name":"fromString:","linesOfCode":7,"sourceCode":"fromString: aString\r\t| result |\r\t\r\tresult := self allocate: aString size + 1.\r\t(self assert: result notNil).\r\tresult writeString: aString.\r\tresult unsignedByteAt: aString size + 1 put: 0.\r\t^ result"}],"meta":null}},{"name":"UUID","instanceVariables":[],"methods":[{"name":">","linesOfCode":3,"sourceCode":"> aMagnitude \r\t\"Answer whether the receiver is greater than the argument.\"\r\r\t^aMagnitude < self"},{"name":"asString","linesOfCode":3,"sourceCode":"asString\r\t\"Return a String with my official representation, 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens)\"\r\t\r\t^ self printString"},{"name":"printString","linesOfCode":5,"sourceCode":"printString\r\t\"Return a String with my official representation, 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens)\"\r\r\t^ String \r\t\tnew: 36 \r\t\tstreamContents: [ :stringStream | self printOn: stringStream ]"},{"name":"<","linesOfCode":8,"sourceCode":"< aMagnitude \r\t\"Answer whether the receiver is less than the argument.\"\r\r\t(self size = aMagnitude size) ifFalse: [ \r\t\t^ self size < aMagnitude size ].\r\t1 to: self size do: [:i |\r\t\t(self at: i) = (aMagnitude at: i) ifFalse: [\r\t\t\t^ (self at: i) < (aMagnitude at: i) ]].\t\t\t\r\t^false."},{"name":"<=","linesOfCode":3,"sourceCode":"<= aMagnitude \r\t\"Answer whether the receiver is less than or equal to the argument.\"\r\r\t^(self > aMagnitude) not"},{"name":"printOn:","linesOfCode":11,"sourceCode":"printOn: aStream\r\t\"Print my official representation, 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens) on aStream\"\r\r\t1 to: 4 do: [ :i | (self at: i) printLowercaseHexByteOn: aStream ].\r\taStream nextPut: $-.\r\t5 to: 6 do: [ :i | (self at: i) printLowercaseHexByteOn: aStream ].\r\taStream nextPut: $-.\r\t7 to: 8 do: [ :i | (self at: i) printLowercaseHexByteOn: aStream ].\r\taStream nextPut: $-.\r\t9 to: 10 do: [ :i | (self at: i) printLowercaseHexByteOn: aStream ].\r\taStream nextPut: $-.\r\t11 to: 16 do: [ :i | (self at: i) printLowercaseHexByteOn: aStream ]"},{"name":"asString36","linesOfCode":9,"sourceCode":"asString36\r\t\"Return a String encoding the receiver as a base 36 number using 0-9 and lowercase a-z.\r\tThis is the shortest representation still being able to work as\r\tfilenames etc since it does not depend on case nor characters\r\tthat might cause problems, and it is reasonably short.\"\r\r\t| num |\r\tnum := 0.\r\t1 to: self size do: [ :i | num := num + ((256 raisedTo: i - 1) * (self at: i)) ].\r\t^ (num printStringBase: 36) asLowercase"},{"name":"readFrom:","linesOfCode":11,"sourceCode":"readFrom: aStream\r\t\"Read my official representation, 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens) from aStream\"\r\t\r\t1 to: 4 do: [ :i | self at: i put: (Integer readHexByteFrom: aStream) ].\r\taStream next = $- ifFalse: [ self error: '- separator expected' ].\r\t5 to: 6 do: [ :i | self at: i put: (Integer readHexByteFrom: aStream) ].\r\taStream next = $- ifFalse: [ self error: '- separator expected' ].\r\t7 to: 8 do: [ :i | self at: i put: (Integer readHexByteFrom: aStream) ].\r\taStream next = $- ifFalse: [ self error: '- separator expected' ].\r\t9 to: 10 do: [ :i | self at: i put: (Integer readHexByteFrom: aStream) ].\r\taStream next = $- ifFalse: [ self error: '- separator expected' ].\r\t11 to: 16 do: [ :i | self at: i put: (Integer readHexByteFrom: aStream) ]"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tUUIDGenerator default placeFields: self"},{"name":"isNilUUID","linesOfCode":3,"sourceCode":"isNilUUID\r\t\"Return true when I am equal to the nilUUID, 00000000-0000-0000-0000-000000000000, false otherwise\"\r\t\r\t^ self allSatisfy: [ :each | each isZero ]"},{"name":"asWBTVarSubstitution","linesOfCode":2,"sourceCode":"asWBTVarSubstitution\r\t^ self asString"},{"name":">=","linesOfCode":3,"sourceCode":">= aMagnitude \r\t\"Answer whether the receiver is greater than or equal to the argument.\"\r\r\t^(self < aMagnitude) not"}],"meta":{"name":"UUID class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: aSize\r\r\t(aSize == 16) ifFalse: [ self error: 'Wrong UUID size' ].\r\t\r\t^ super new: aSize"},{"name":"nilUUID","linesOfCode":5,"sourceCode":"nilUUID\r\t\"Return a empty un-initialized UUID, with all zero values, 00000000-0000-0000-0000-000000000000\"\r\t\r\t\"self nilUUID\"\r\t\r\t\"Must call basicNew: here because I have a non-trivial initialize method.\"\r\r\t^ self basicNew: 16"},{"name":"forWbtName:","linesOfCode":2,"sourceCode":"forWbtName: uuidName\r\t^ self forNamespace: (self fromString: '7a6049b5-8870-0d00-aebb-345f05f0abb3') name: uuidName"},{"name":"fromString:","linesOfCode":7,"sourceCode":"fromString: aString\r\t\"Read a UUID from aString with my official representation, 32 lowercase hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens)\"\r\r\t| uuid |\r\taString size ~= 36 ifTrue: [ self error: 'a UUID should be 36 characters' ].\r\tuuid := self nilUUID. \r\tuuid readFrom: aString readStream.\r\t^ uuid"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\t\"Create and return a new UUID\"\r\t\r\t\"self new\"\r\t\r\t^ (self new: 16)"},{"name":"fromString36:","linesOfCode":10,"sourceCode":"fromString36: aString\r\t\"Decode a UUID from a base 36 string using 0-9 and lowercase a-z.\r\tThis is the shortest representation still being able to work as\r\tfilenames etc since it does not depend on case nor characters\r\tthat might cause problems.\"\r\r\t| object num |\r\tobject := self nilUUID.\r\tnum := Integer readFrom: aString asUppercase readStream base: 36.\r\t1 to: 16 do: [:i | object at: i put: (num byteAt: i)].\r\t^object"},{"name":"forNamespace:name:","linesOfCode":10,"sourceCode":"forNamespace: uuidNamespace name: uuidName\r\t| hash result |\r\thash := SHA1 hashMessage: (uuidNamespace as: ByteArray) , uuidName utf8Encoded.\r\tresult := self new.\r\t1 to: 16 do: [ :i | result at: i put: (hash at: i) ].\r\t\"Version 5. SHA1 name based.\"\r\tresult at: 7 put: ((result at: 7) & 2r1111 | (5 << 4)).\r\r\t\"Variant 10\"\r\tresult at: 9 put: ((result at: 9) & 2r111111 | 2r10000000).\r\t\r\t^ result"}],"meta":null}},{"name":"SocketAddress","instanceVariables":[],"methods":[{"name":"isPrivateAddress","linesOfCode":4,"sourceCode":"isPrivateAddress\r\t^ self first = 10\r\t\tor: [ (self first = 172 and: [ self second between: 16 and: 31 ])\r\t\t\t\tor: [ self first = 192 and: [ self second = 168 ] ] ]"},{"name":"gtDisplayOn:","linesOfCode":3,"sourceCode":"gtDisplayOn: stream\r\t\"Overwrite to get standard object behaviour\"\r\t\r\t^ self printOn: stream"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: stream\r\tself \r\t\tdo: [ :each | each printOn: stream ] \r\t\tseparatedBy: [ stream nextPut: $. ]"},{"name":"asSocketAddress","linesOfCode":1,"sourceCode":"asSocketAddress\r"}],"meta":{"name":"SocketAddress class","instanceVariables":[],"methods":[{"name":"fromDottedString:","linesOfCode":10,"sourceCode":"fromDottedString: string\r\t\"Create a SocketAddress from its dotted notation\"\r\r\t\"self fromDottedString: '192.168.1.1'\"\r\r\t| integers |\r\tintegers := ($. split: string) collect: [ :each | Integer readFrom: each ].\r\tintegers size = 4 ifFalse: [ SizeMismatch signal ].\r\tintegers do: [ :each | \r\t\t(each between: 0 and: 255)\r\t\t\tifFalse: [ DomainError signalFrom: 0 to: 255 ] ].\r\t^ self newFrom: integers"},{"name":"fromOldByteAddress:","linesOfCode":4,"sourceCode":"fromOldByteAddress: byteArray\r\t\"Create a SocketAddress from byteArray, enforcing the correc length, 4\"\r\t\r\tbyteArray size = 4 ifFalse: [ SizeMismatch signal ].\r\t^ self newFrom: byteArray"},{"name":"zero","linesOfCode":3,"sourceCode":"zero\r\t\"Return the zero SocketAddress, 0.0.0.0\"\r\t\r\t^ self basicNew: 4"}],"meta":null}},{"name":"Alien","instanceVariables":[],"methods":[{"name":"char8AtOffset:put:","linesOfCode":2,"sourceCode":"char8AtOffset: zeroBasedOffset put: value\r\t^ self unsignedByteAt: zeroBasedOffset + 1 put: value asInteger"},{"name":"pointer","linesOfCode":6,"sourceCode":"pointer\r\t\"Answer a pointer to the receiver in the form of an Alien.\r\t This will fail if the receiver is not indirect.\"\r\tself isPointer ifTrue:\r\t\t[self error: 'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].\r\t^self class forPointer: self address"},{"name":"signedShortAt:put:","linesOfCode":3,"sourceCode":"signedShortAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedShortAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFindSymbol:","linesOfCode":8,"sourceCode":"primFindSymbol: symbolName \"<String> ^<Integer>\"\r\t\"The receiver is assumed to be a proxy whose first field contans the handle of a library\r\t answered by primLoadLibrary.  Attempt to find symbolName in the library and answer\r\t its address, or fail if the receiver is invalid or the symbol cannot be found.\"\r\t<primitive: 'primInLibraryFindSymbol' module: 'IA32ABI' error: errorCode>\r\t^errorCode == #'not found'\r\t\tifTrue: [LibrarySymbolNotFoundError signal]\r\t\tifFalse: [self primitiveFailed]"},{"name":"primFFICallResult:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | SmallInteger> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"pointerAtOffset:put:","linesOfCode":8,"sourceCode":"pointerAtOffset: zeroBasedOffset put: value\r\t\"Store a pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\tself unsignedByteAt: zeroBasedOffset+i put: (value basicAt: i)].\r\t^value"},{"name":"primFFICallResult:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"float32AtOffset:put:","linesOfCode":2,"sourceCode":"float32AtOffset: zeroBasedOffset put: value\r\t^ self floatAt: zeroBasedOffset + 1 put: value"},{"name":"float64AtOffset:","linesOfCode":2,"sourceCode":"float64AtOffset: zeroBasedOffset\r\t^ self doubleAt: zeroBasedOffset + 1"},{"name":"primFFICallResult:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"int32AtOffset:","linesOfCode":2,"sourceCode":"int32AtOffset: zeroBasedOffset\r\t^ self signedLongAt: zeroBasedOffset + 1"},{"name":"primFFICallResult:with:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" with: arg8 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"isPointer","linesOfCode":2,"sourceCode":"isPointer\r\t^self sizeField = 0"},{"name":"primFFICallResult:withArguments:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" withArguments: args \"<Array of: Alien | Integer> ^<Alien>\"\r\t<primitive: 'primVarArgsCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"signedWordAtWordIndex:","linesOfCode":4,"sourceCode":"signedWordAtWordIndex: wordIndex\r\t^WordSize = 4\r\t\tifTrue: [self signedLongAt: wordIndex - 1 * 4 + 1]\r\t\tifFalse: [self signedLongLongAt: wordIndex - 1 * 8 + 1]"},{"name":"floatAt:put:","linesOfCode":3,"sourceCode":"floatAt: index \"<Integer>\" put: value \"<Float | Integer> ^<Float | Integer>\"\r\t<primitive: 'primFloatAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:with:with:with:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" with: arg8 \"<Alien | Integer>\" with: arg9 \"<Alien | Integer>\" with: arg10 \"<Alien | Integer>\" with: arg11 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:with:with:with:with:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" with: arg8 \"<Alien | Integer>\" with: arg9 \"<Alien | Integer>\" with: arg10 \"<Alien | Integer>\" with: arg11 \"<Alien | Integer>\" with: arg12 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"boolean8AtOffset:","linesOfCode":2,"sourceCode":"boolean8AtOffset: zeroBasedOffset\r\t^ (self unsignedByteAt: zeroBasedOffset + 1) ~= 0"},{"name":"pointerAt:","linesOfCode":3,"sourceCode":"pointerAt: byteIndex\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self pointerAtOffset: byteIndex - 1"},{"name":"strcpyFrom:","linesOfCode":7,"sourceCode":"strcpyFrom: startIndex \"<Integer> ^<ByteString>\"\r\t| length string |\r\tlength := self strlenStartingAt: startIndex.\r\tself copyInto: (string := ByteString new: length)\r\t\tfrom: 1 to: length\r\t\tin: self startingAt: startIndex.\r\t^string"},{"name":"asSignedByte","linesOfCode":3,"sourceCode":"asSignedByte \"^<Integer>\"\r\t\"Answer an Integer created from the first byte of the receiver interpreted as a signed value.\"\r\t\r\t^self signedByteAt: 1"},{"name":"strcpyUTF8","linesOfCode":2,"sourceCode":"strcpyUTF8 \"^<String>\"\r\t^self strcpyUTF8From: 1"},{"name":"uint32AtOffset:","linesOfCode":2,"sourceCode":"uint32AtOffset: zeroBasedOffset\r\t^ self unsignedLongAt: zeroBasedOffset + 1"},{"name":"booleanAt:","linesOfCode":2,"sourceCode":"booleanAt: byteIndex\r\t^ (self unsignedByteAt: byteIndex) ~= 0"},{"name":"asSignedLong","linesOfCode":3,"sourceCode":"asSignedLong \"^<Integer>\"\r\t\"Answer an Integer created from the first 4 bytes of the receiver interpreted as a signed value.\"\r\t\r\t^self signedLongAt: 1"},{"name":"asUnsignedLong","linesOfCode":3,"sourceCode":"asUnsignedLong \"^<Integer>\"\r\t\"Answer an Integer created from the first 4 bytes of the receiver interpreted as an unsigned value.\"\r\t\r\t^self unsignedLongAt: 1"},{"name":"free","linesOfCode":2,"sourceCode":"free\r\tself primFree"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\t\"Subclasses should redefine this method to perform initializations on instance creation\"\r\t\"Overrides ProtoObjects' method for explicitness.\""},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":3,"sourceCode":"replaceFrom: start \"<Integer>\" to: stop \"<Integer>\" with: replacement \"<Alien | indexableByteSubclass>\" startingAt: repStart \"<Integer>\" \"^<self>\"\r\t<primitive: 'primAlienReplace' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"signedLongAt:","linesOfCode":3,"sourceCode":"signedLongAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedLongAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"copyInto:from:to:in:startingAt:","linesOfCode":3,"sourceCode":"copyInto: aByteObject \"<Alien | indexableByteSubclass>\" from: start \"<Integer>\" to: stop \"<Integer>\" in: replacement \"<Alien | indexableByteSubclass>\" startingAt: repStart \"<Integer>\" \"^<self>\"\r\t<primitive: 'primAlienReplace' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"sizeFieldPut:","linesOfCode":3,"sourceCode":"sizeFieldPut: size \"<Integer> ^<Integer>\"\r\t<primitive: 'primSizeFieldPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"addressField","linesOfCode":3,"sourceCode":"addressField \"^<Integer>\"\r\t<primitive: 'primAddressField' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"strlenStartingAt:","linesOfCode":3,"sourceCode":"strlenStartingAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primStrlenFromStartIndex' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"asAlien","linesOfCode":2,"sourceCode":"asAlien\r\t^self"},{"name":"unsignedLongLongAt:put:","linesOfCode":3,"sourceCode":"unsignedLongLongAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedLongLongAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"unsignedLongAt:put:","linesOfCode":3,"sourceCode":"unsignedLongAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedLongAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"freeAfter:","linesOfCode":4,"sourceCode":"freeAfter: aBlock\r\t\"The receiver must be a pointer to a previously allocated external C heap memory block. Invoke aBlock passing the receiver as the argument, then free the receiver. Allows automatic allocation and freeing of C artifacts using patters such as\r\t(Alien newCString: 'foo') freeAfter: [:cstring | ...use cstring here...].\"\r\t\r\t^[aBlock value: self] ensure: [self free]"},{"name":"signedLongAt:put:","linesOfCode":3,"sourceCode":"signedLongAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedLongAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"char8AtOffset:","linesOfCode":2,"sourceCode":"char8AtOffset: zeroBasedOffset\r\t^ (self unsignedByteAt: zeroBasedOffset + 1) asCharacter"},{"name":"unsignedShortAt:","linesOfCode":3,"sourceCode":"unsignedShortAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedShortAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"address","linesOfCode":4,"sourceCode":"address\r\t^self sizeField <= 0\r\t\tifTrue: [self addressField]\r\t\tifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']"},{"name":"pointerAt:put:","linesOfCode":3,"sourceCode":"pointerAt: byteIndex put: value\r\t\"This method is duplicated in this subclass with the purpose of ensuring a monomorphic inline cache in the following message send.\"\r\t^ self pointerAtOffset: byteIndex - 1 put: value"},{"name":"strlen","linesOfCode":2,"sourceCode":"strlen\r\t^self strlenStartingAt: 1"},{"name":"uint16AtOffset:","linesOfCode":2,"sourceCode":"uint16AtOffset: zeroBasedOffset\r\t^ self unsignedShortAt: zeroBasedOffset + 1"},{"name":"doubleAt:put:","linesOfCode":3,"sourceCode":"doubleAt: index \"<Integer>\" put: value \"<Float | Integer> ^<Float | Integer>\"\r\t<primitive: 'primDoubleAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"asUnsignedByte","linesOfCode":3,"sourceCode":"asUnsignedByte \"^<Integer>\"\r\t\"Answer an Integer created from the first byte of the receiver interpreted as an unsigned value.\"\r\t\r\t^self unsignedByteAt: 1"},{"name":"unsignedByteAt:","linesOfCode":3,"sourceCode":"unsignedByteAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedByteAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"signedLongLongAt:put:","linesOfCode":3,"sourceCode":"signedLongLongAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedLongLongAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"char32AtOffset:put:","linesOfCode":2,"sourceCode":"char32AtOffset: zeroBasedOffset put: value\r\t^ self unsignedLongAt: zeroBasedOffset + 1 put: value asInteger"},{"name":"primFFICallResult:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"strlenThroughPointerAt:","linesOfCode":3,"sourceCode":"strlenThroughPointerAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primStrlenThroughPointerAtIndex' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"float32AtOffset:","linesOfCode":2,"sourceCode":"float32AtOffset: zeroBasedOffset\r\t^ self floatAt: zeroBasedOffset + 1"},{"name":"char16AtOffset:","linesOfCode":2,"sourceCode":"char16AtOffset: zeroBasedOffset\r\t^ (self unsignedShortAt: zeroBasedOffset + 1) asCharacter"},{"name":"primFFICallResult:with:with:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" with: arg8 \"<Alien | Integer>\" with: arg9 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"unsignedLongLongAt:","linesOfCode":3,"sourceCode":"unsignedLongLongAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedLongLongAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"primFFICallResult:with:with:with:with:with:with:with:with:with:with:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien>\" with: firstArg \"<Alien | Integer>\" with: secondArg \"<Alien | Integer>\" with: thirdArg \"<Alien | Integer>\" with: fourthArg \"<Alien | Integer>\" with: fifthArg \"<Alien | Integer>\" with: sixthArg \"<Alien | Integer>\" with: arg7 \"<Alien | Integer>\" with: arg8 \"<Alien | Integer>\" with: arg9 \"<Alien | Integer>\" with: arg10 \"<Alien | Integer>\" \"^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"signedShortAt:","linesOfCode":3,"sourceCode":"signedShortAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedShortAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"float64AtOffset:put:","linesOfCode":2,"sourceCode":"float64AtOffset: zeroBasedOffset put: value\r\t^ self doubleAt: zeroBasedOffset + 1 put: value"},{"name":"signedLongLongAt:","linesOfCode":3,"sourceCode":"signedLongLongAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedLongLongAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"char16AtOffset:put:","linesOfCode":2,"sourceCode":"char16AtOffset: zeroBasedOffset put: value\r\t^ self unsignedShortAt: zeroBasedOffset + 1 put: value asInteger"},{"name":"pointerAtOffset:","linesOfCode":8,"sourceCode":"pointerAtOffset: zeroBasedOffset\r\t\"Answer a pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress new.\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: zeroBasedOffset+i)].\r\t^addr"},{"name":"addressFieldPut:","linesOfCode":3,"sourceCode":"addressFieldPut: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primAddressFieldPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"strcpyUTF8From:","linesOfCode":7,"sourceCode":"strcpyUTF8From: startIndex \"<Integer> ^<String>\"\r\t| length bytes |\r\tlength := self strlenStartingAt: startIndex.\r\tself copyInto: (bytes := ByteArray new: length)\r\t\tfrom: 1 to: length\r\t\tin: self startingAt: startIndex.\r\t^bytes utf8ToIso"},{"name":"int16AtOffset:","linesOfCode":2,"sourceCode":"int16AtOffset: zeroBasedOffset\r\t^ self signedShortAt: zeroBasedOffset + 1"},{"name":"uint64AtOffset:","linesOfCode":2,"sourceCode":"uint64AtOffset: zeroBasedOffset\r\t^ self unsignedLongLongAt: zeroBasedOffset + 1"},{"name":"signedByteAt:","linesOfCode":3,"sourceCode":"signedByteAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedByteAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"unsignedByteAt:put:","linesOfCode":3,"sourceCode":"unsignedByteAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedByteAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"doubleAt:","linesOfCode":3,"sourceCode":"doubleAt: index \"<Integer> ^<Float>\"\r\t<primitive: 'primDoubleAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"int64AtOffset:","linesOfCode":2,"sourceCode":"int64AtOffset: zeroBasedOffset\r\t^ self signedLongLongAt: zeroBasedOffset + 1"},{"name":"uint8AtOffset:","linesOfCode":2,"sourceCode":"uint8AtOffset: zeroBasedOffset\r\t^ self unsignedByteAt: zeroBasedOffset + 1"},{"name":"unsignedLongAt:","linesOfCode":3,"sourceCode":"unsignedLongAt: index \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedLongAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"char32AtOffset:","linesOfCode":2,"sourceCode":"char32AtOffset: zeroBasedOffset\r\t^ (self unsignedLongAt: zeroBasedOffset + 1) asCharacter"},{"name":"asSignedShort","linesOfCode":3,"sourceCode":"asSignedShort \"^<Integer>\"\r\t\"Answer an Integer created from the first 2 bytes of the receiver interpreted as a signed value.\"\r\t\r\t^self signedShortAt: 1"},{"name":"sizeField","linesOfCode":3,"sourceCode":"sizeField \"^<Integer>\"\r\t<primitive: 'primSizeField' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"integerAt:size:signed:","linesOfCode":2,"sourceCode":"integerAt: byteOffset size: size signed: signed\r\r\t^ (ExternalAddress fromAddress: self address) integerAt: byteOffset size: size signed: signed"},{"name":"asUnsignedShort","linesOfCode":3,"sourceCode":"asUnsignedShort \"^<Integer>\"\r\t\"Answer an Integer created from the first 2 bytes of the receiver interpreted as an unsigned value.\"\r\t\r\t^self unsignedShortAt: 1"},{"name":"asExternalAddress","linesOfCode":2,"sourceCode":"asExternalAddress\r\r\t^ ExternalAddress fromAddress: self address"},{"name":"booleanAt:put:","linesOfCode":2,"sourceCode":"booleanAt: byteIndex put: value\r\t^ self unsignedByteAt: byteIndex put: (value ifTrue: [ 1 ] ifFalse: [ 0 ])"},{"name":"storeOn:","linesOfCode":24,"sourceCode":"storeOn: aStream\r\t| sizeField |\r\t(sizeField := self sizeField) ~= 0 ifTrue:\r\t\t[aStream nextPut: $(].\r\taStream nextPut: $(; print: self class.\r\tsizeField = 0\r\t\tifTrue:\r\t\t\t[aStream nextPutAll: ' forPointer: '; nextPutAll: self addressField storeStringHex]\r\t\tifFalse:\r\t\t\t[aStream\r\t\t\t\tnextPutAll: (sizeField < 0 ifTrue: [' newC: '] ifFalse: [' new: ']);\r\t\t\t\tprint: (sizeField := sizeField abs); nextPut: $).\r\t\t\t 1 to: sizeField by: 4 do:\r\t\t\t\t[:i| | v |\r\t\t\t\t(v := self unsignedLongAt: i) ~= 0 ifTrue:\r\t\t\t\t\t[aStream\r\t\t\t\t\t\tcrtab;\r\t\t\t\t\t\tnextPutAll: 'unsignedLongAt: '; print: i;\r\t\t\t\t\t\tnextPutAll: ' put: '; print: v; nextPut: $;]].\r\t\t\t aStream crtab; nextPutAll: #yourself].\r\taStream nextPut: $)\r\r\t\"{\t(Alien forPointer: 0) storeString.\r\t\t(Alien new: 8) storeString.\r\t\t(Alien newC: 8) storeString }\""},{"name":"unsignedShortAt:put:","linesOfCode":3,"sourceCode":"unsignedShortAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primUnsignedShortAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"as:","linesOfCode":9,"sourceCode":"as: anAlienClass\r\t\"Attempt to coerce the receiver into a different class of Alien.  Performs minimal checks!! Use with caution!!\"\r\t| alienClassDataSize |\r\t\"Always attempt to access anAlienClass dataSize as a run-time check for anAlienClass actually being an Alien class.\"\r\talienClassDataSize := anAlienClass dataSize.\r\tself isPointer ifFalse:\r\t\t[self dataSize >= alienClassDataSize ifFalse:\r\t\t\t[self error: 'receiver too small to coerce']].\r\tanAlienClass adoptInstance: self"},{"name":"floatAt:","linesOfCode":3,"sourceCode":"floatAt: index \"<Integer> ^<Float>\"\r\t<primitive: 'primFloatAt' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"signedByteAt:put:","linesOfCode":3,"sourceCode":"signedByteAt: index \"<Integer>\" put: value \"<Integer> ^<Integer>\"\r\t<primitive: 'primSignedByteAtPut' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"strcpy","linesOfCode":2,"sourceCode":"strcpy \"^<ByteString>\"\r\t^self strcpyFrom: 1"},{"name":"boolean8AtOffset:put:","linesOfCode":2,"sourceCode":"boolean8AtOffset: zeroBasedOffset put: value\r\t^ self unsignedByteAt: zeroBasedOffset + 1 put: (value ifTrue: [ 1 ] ifFalse: [ 0 ])"},{"name":"int8AtOffset:","linesOfCode":2,"sourceCode":"int8AtOffset: zeroBasedOffset\r\t^ self signedByteAt: zeroBasedOffset + 1"},{"name":"primFree","linesOfCode":7,"sourceCode":"primFree\r\t\"Free the memory referenced by the receiver, or fail if\r\t the receiver is direct or the indirect pointer is invalid.\r\t Note that if successful the address and size fields are\r\t zero'ed, effectively preventing double-freeing hazards.\"\r\t<primitive: 'primBoxedFree' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"dataSize","linesOfCode":2,"sourceCode":"dataSize\r\t^self sizeField abs"},{"name":"primFFICallResult:","linesOfCode":3,"sourceCode":"primFFICallResult: result \"<Alien> ^<Alien>\"\r\t<primitive: 'primCallOutIntegralReturn' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"}],"meta":{"name":"Alien class","instanceVariables":[{"name":"lifoCallbackSemaphore"}],"methods":[{"name":"forPointer:","linesOfCode":7,"sourceCode":"forPointer: address \"<Integer>\" \"^<Alien>\"\r\t\"N.B.  This method assumes one is creating a pointer to already initialized data, hence initiaize is not sent.\r\t(Perhaps some alternative, eg. initializePointer, should be sent?\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: 0;\r\t\taddressFieldPut: address;\r\t\tyourself"},{"name":"Cmalloc:","linesOfCode":3,"sourceCode":"Cmalloc: byteSize \"<Integer> ^<Integer>\"\r\t<primitive: 'primMalloc' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"new:","linesOfCode":5,"sourceCode":"new: byteSize\r\t\"Answer a new instance of the given byte size whose data resides on the Smalltalk heap directly in the instance.\"\r\t^(self basicNew: byteSize + WordSize)\r\t\tsizeFieldPut: byteSize;\r\t\tinitialize"},{"name":"newC:","linesOfCode":7,"sourceCode":"newC: byteSize\r\t\"Answer a new instance of the given byte size whose data resides on the external C heap.\r\t As with instances residing on the Smalltalk heap the data is zero-filled.\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: byteSize negated;\r\t\taddressFieldPut: (self Ccalloc: byteSize);\r\t\tinitialize"},{"name":"rawNewC:","linesOfCode":7,"sourceCode":"rawNewC: byteSize\r\t\"Answer a new instance of the given byte size whose data resides on the external C heap.\r\t Unlike newC: the data is *not* zero-filled.\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: byteSize negated;\r\t\taddressFieldPut: (self Cmalloc: byteSize);\r\t\tinitialize"},{"name":"lookupOrNil:inLibrary:","linesOfCode":6,"sourceCode":"lookupOrNil: symbol  \"<String>\" inLibrary: libraryName \"<String> ^<Alien>\"\r\t\"Answer the address of symbol in libraryName, or nil if it is not in the library.\r\tExceptions will be raised for invalid libraries, symbol names, etc.\"\r\t^[self lookup: symbol inLibrary: libraryName ]\r\t\ton: LibrarySymbolNotFoundError\r\t\tdo: [:ex| nil]"},{"name":"ensureNotifiedAtStartup","linesOfCode":7,"sourceCode":"ensureNotifiedAtStartup\r\t\"Alien needs to be notified at system startup to clear the LoadedLibraries table\r\tand otherwise sanitise Aliens with dangling pointers.\"\r\tself ~~ Alien ifTrue: [^self].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: self name\r\t\tatPriority: 60"},{"name":"startUp:","linesOfCode":11,"sourceCode":"startUp: resuming\r\tresuming ifTrue:\r\t\t[LoadedLibraries := Dictionary new: LoadedLibraries size.\r\t\t\"Any addresses in the finalization registry at the time the image\r\t\t comes up in a new session MUST NOT be finalized and should\r\t\t immediately be discarded. These addresses are no longer valid.\"\r\t\t GCMallocedAliens ifNotNil:\r\t\t\t[:gcMallocedAliens| gcMallocedAliens removeAll].\r\t\t\"The io lock is off in the new session, so we shut down the process if it's running.\"\r\t\tProcessIoEvents := false.\r\t\tWordSize := Smalltalk wordSize]"},{"name":"primFree:","linesOfCode":3,"sourceCode":"primFree: address \"<Integer>\"\r\t<primitive: 'primFree' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"atAddress:","linesOfCode":7,"sourceCode":"atAddress: pointer \"<Integer>\" \"^<Alien>\"\r\t\"N.B.  This method assumes one is creating a pointer to already initialized data, hence initiaize is not sent.\r\t(Perhaps some alternative, eg. initializePointer, should be sent?\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: self dataSize negated;\r\t\taddressFieldPut: pointer;\r\t\tyourself"},{"name":"primLoadLibrary:","linesOfCode":6,"sourceCode":"primLoadLibrary: libraryName \"<String> ^<Integer>\"\r\t\"Attempt to load the shared library/DLL named libraryName and\r\t answer a handle which can be used in primFindSymbol:inLibrary:,\r\t or fail if libraryName is invalid or libraryName cannot be found.\"\r\t<primitive: 'primLoadLibrary' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"newGC","linesOfCode":4,"sourceCode":"newGC\r\t\"Answer a new instance of the default size whose data resides on the external C heap,\r\t and whose data will be reclaimed automatically when the instance is garbage collected.\"\r\t^self newGC: self dataSize"},{"name":"exampleCqsort","linesOfCode":22,"sourceCode":"exampleCqsort\r\t\"Call the libc qsort function (which requires a callback).\"\r\t\"Alien exampleCqsort\"\r\t\"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0\"\r\t| cb rand nElements sizeofDouble values orig sort |\r\trand := Random new.\r\tvalues := Alien newC: (nElements := 100) * (sizeofDouble := 8).\r\t1 to: values dataSize by: sizeofDouble do:\r\t\t[:i| values doubleAt: i put: rand next].\r\torig := (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].\r\tcb := Callback\r\t\t\tsignature:  #(int (*)(const void *, const void *))\r\t\t\tblock: [ :arg1 :arg2 | ((arg1 doubleAt: 1) - (arg2 doubleAt: 1)) sign].\r\t(Alien lookup: 'qsort' inLibrary: Alien libcName)\r\t\tprimFFICallResult: nil\r\t\twith: values pointer\r\t\twith: nElements\r\t\twith: sizeofDouble\r\t\twith: cb thunk.\r\tsort := (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].\r\tvalues free.\r\t^orig -> sort"},{"name":"invokeCallback:stack:registers:jmpbuf:","linesOfCode":10,"sourceCode":"invokeCallback: thunkPtr \"<Integer>\" stack: stackPtr \"<Integer>\" registers: regsPtr \"<Integer>\" jmpbuf: jmpBufPtr \"<Integer>\" \"^<FFICallbackReturnValue>\"\r\t\"The low-level entry-point for callbacks sent from the VM/IA32ABI plugin.\r\t Return via primReturnFromContext:through:.  thisContext's sender is the\r\t call-out context.\"\r\t| resultProxy |\r\t[resultProxy := Callback evaluateCallbackForThunk: thunkPtr stack: stackPtr]\r\t\tifCurtailed: [self error: 'attempt to non-local return across a callback'].\r\tresultProxy ifNil:\r\t\t[(resultProxy := FFICallbackReturnValue new) returnInteger: 0].\r\tresultProxy primReturnFromContext: thisContext through: jmpBufPtr"},{"name":"ensureLoaded:","linesOfCode":11,"sourceCode":"ensureLoaded: aLibraryName \"<String> ^<Alien>\"\r\t^LoadedLibraries\r\t\tat: aLibraryName\r\t\tifAbsentPut:\r\t\t\t[| lib alien |\r\t\t\t lib := self primLoadLibrary: aLibraryName.\r\t\t\t alien := Alien new: WordSize.\r\t\t\t WordSize = 4\r\t\t\t\tifTrue: [alien unsignedLongAt: 1 put: lib]\r\t\t\t\tifFalse: [alien unsignedLongLongAt: 1 put: lib].\r\t\t\t alien]"},{"name":"newC","linesOfCode":3,"sourceCode":"newC\r\t\"Answer a new instance of the default size whose data resides on the external C heap.\"\r\t^self newC: self dataSize"},{"name":"invokeCallbackContext:","linesOfCode":22,"sourceCode":"invokeCallbackContext: vmCallbackContextAddress \"<Integer>\" \"^<FFICallbackReturnValue>\"\r\t\"The low-level entry-point for callbacks sent from the VM/IA32ABI plugin.\r\t Evaluate the callback corresponding to the thunk referenced by vmCallbackContextAddress,\r\t a pointer to a VMCallbackContext32 or VMCallbackContext64, set up by the VM's thunkEntry\r\t routine.  Return to C via primSignal:andReturnAs:fromContext:.  thisContext's sender is the\r\t call-out context.\"\r\t| callbackAlien type |\r\tcallbackAlien := (Smalltalk wordSize = 4\r\t\t\t\t\t\tifTrue: [VMCallbackContext32]\r\t\t\t\t\t\tifFalse: [VMCallbackContext64])\r\t\t\t\t\t\t\tatAddress: vmCallbackContextAddress.\r\t[type := Callback evaluateCallbackForContext: callbackAlien]\r\t\tifCurtailed: [self error: 'attempt to non-local return across a callback'].\r\ttype ifNil:\r\t\t[type := 1. callbackAlien wordResult: -1].\r\t\"Now attempt to return to C.  The primitive will answer false if this is not the most recent Callback,\r\t in which case we should wait on the lifoCallbackSemaphore which will be signalled when the most\r\t recent callback successfully returns.  If this is the most recent callback the primitive will signal all\r\t the processes waiting on the lifoCallbackSemaphore, one of which will be the next most recent.\r\t Hence all nested callbacks will end up returning in the right order.\"\r\t[callbackAlien primSignal: lifoCallbackSemaphore andReturnAs: type fromContext: thisContext] whileFalse:\r\t\t[lifoCallbackSemaphore wait]"},{"name":"primInLibrary:findSymbol:","linesOfCode":3,"sourceCode":"primInLibrary: libraryHandle \"<Alien>\" findSymbol: symbolName \"<String> ^<Integer>\"\r\t<primitive: 'primInLibraryFindSymbol' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"atAddress:dataSize:","linesOfCode":7,"sourceCode":"atAddress: address \"<Integer>\" dataSize: dataByteSize \"<Integer>\" \"^<Alien>\"\r\t\"N.B.  This method assumes one is creating a pointer to already initialized data, hence initiaize is not sent.\r\t(Perhaps some alternative, eg. initializePointer, should be sent?\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: dataByteSize asInteger abs negated;\r\t\taddressFieldPut: address;\r\t\tyourself"},{"name":"libcName","linesOfCode":17,"sourceCode":"libcName\r\t| platform |\r\tplatform := SmalltalkImage current platformName.\r\tplatform = 'Mac OS' ifTrue:\r\t\t[^SmalltalkImage current os version asInteger >= 1070\r\t\t\tifTrue: ['libobjc.dylib']\r\t\t\tifFalse:\r\t\t\t\t[SmalltalkImage current os version asInteger >= 1050\r\t\t\t\t\tifTrue: ['libgcc_s.1.dylib']\r\t\t\t\t\tifFalse: ['libc.dylib']]].\r\tplatform = 'unix' ifTrue:\r\t\t[SmalltalkImage current os version = 'linux-gnu' ifTrue:\r\t\t\t[^'libc.so.6'].\r\t\t ^'libc.so'].\r\tplatform = 'Win32' ifTrue:\r\t\t[^'msvcrt.dll'].\r\t^nil"},{"name":"Ccalloc:","linesOfCode":3,"sourceCode":"Ccalloc: byteSize \"<Integer> ^<Integer>\"\r\t<primitive: 'primCalloc' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"forWord","linesOfCode":4,"sourceCode":"forWord \"<Integer>\" \"^<Alien>\"\r\t^(self basicNew: WordSize * 2)\r\t\tsizeFieldPut: WordSize;\r\t\tyourself"},{"name":"newCString:","linesOfCode":8,"sourceCode":"newCString: aString \"<String> ^<Alien>\"\r\t\"Answer an Alien pointing to a null-terminated copy of aString on the external C heap.\"\r\r\t| size |\r\tsize := aString size.\r\t^(Alien rawNewC: size + 1)\r\t\treplaceFrom: 1 to: size with: aString startingAt: 1;\r\t\tunsignedByteAt: size + 1 put: 0;\r\t\tyourself"},{"name":"lookup:inLibrary:","linesOfCode":5,"sourceCode":"lookup: symbol \"<String>\" inLibrary: libraryNameOrAlien \"<String|Alien> ^<Alien>\"\r\t^self forPointer: ((libraryNameOrAlien isString\r\t\t\t\t\t\tifTrue: [self ensureLoaded: libraryNameOrAlien]\r\t\t\t\t\t\tifFalse: [libraryNameOrAlien])\r\t\t\t\t\t\t\tprimFindSymbol: symbol)"},{"name":"finalize:","linesOfCode":2,"sourceCode":"finalize: mallocTag\r\tself primFree: mallocTag"},{"name":"initialize","linesOfCode":13,"sourceCode":"initialize\r\t\"Alien initialize\"\r\tLoadedLibraries ifNil:\r\t\t[LoadedLibraries := Dictionary new].\r\tGCMallocedAliens ifNil:\r\t\t[GCMallocedAliens := AlienWeakTable newForOwner: self].\r\tWordSize := Smalltalk wordSize.\r\tlifoCallbackSemaphore := Semaphore new.\r\r\tself ensureNotifiedAtStartup.\r\t\r\t(Smalltalk specialObjectsArray at: 53) ifNil:\r\t\t[Smalltalk specialObjectsArray at: 53 put: Alien].\r\t(Smalltalk specialObjectsArray at: 55) ifNil:\r\t\t[Smalltalk specialObjectsArray at: 55 put: UnsafeAlien]\t"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Answer a new instance of the default size whose data resides on the Smalltalk heap directly in the instance.\"\r\t^self new: self dataSize"},{"name":"wordSize","linesOfCode":2,"sourceCode":"wordSize\r\t^WordSize"},{"name":"examplePrintf","linesOfCode":11,"sourceCode":"examplePrintf\r\t\"Call the libc printf function.\"\r\t\"Alien examplePrintf\"\r\t| r s |\r\t(self lookup: 'printf' inLibrary: self libcName)\r\t\tprimFFICallResult: (r := Alien forWord)\r\t\twithArguments: {(s := ('Hello World %d %x !!', (String with: Character lf)) asAlien) pointer.\r\t\t\t\t\t\t 123.\r\t\t\t\t\t\t 48879}.\r\ts free.\r\t^r signedWordAtWordIndex: 1"},{"name":"dataSize","linesOfCode":4,"sourceCode":"dataSize \"^<Integer>\"\r\t\"Answer the number of bytes required to represent an instance of the receiver.\r\tThis excludes the size word's own bytes and is just the size of the data.\"\r\t^self subclassResponsibility"},{"name":"newGC:","linesOfCode":12,"sourceCode":"newGC: byteSize\r\t\"Answer a new instance of the given byte size whose data resides on the external C heap,\r\t and whose data will be reclaimed automatically when the instance is garbage collected.\r\t As with instances residing on the Smalltalk heap the data is zero-filled.\"\r\t| alien address |\r\t(alien := self basicNew: WordSize * 2)\r\t\tsizeFieldPut: byteSize negated.\r\taddress := self Ccalloc: byteSize.\r\tGCMallocedAliens add: alien finalizing: address.\r\t^alien\r\t\taddressFieldPut: address;\r\t\tinitialize"}],"meta":null}},{"name":"ByteString","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t| ba sz |\r\tsz := self byteSize.\r\tba := ByteArray new: sz.\r\tba replaceFrom: 1 to: sz with: self startingAt: 1.\r\t^ba"},{"name":"asOctetString","linesOfCode":2,"sourceCode":"asOctetString\r\r\t^ self.\r"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^(self at: index) asciiValue"},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\r\tanEncoder encodeString: self"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":3,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Use double dispatching for speed\"\r\t^aCollection findFirstInByteString: self startingAt: start"},{"name":"isByteString","linesOfCode":4,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t\"'abc' isByteString >>> true\"\r\t^true"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":7,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\treplacement class == WideString ifTrue: [\r\t\tself becomeForward: (WideString from: self).\r\t]. \r\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart.\r"},{"name":"convertFromSystemString","linesOfCode":8,"sourceCode":"convertFromSystemString\r\r\t| readStream |\r\treadStream := self readStream.\r\t^ self class new: self size streamContents: [ :writeStream |\r\t\t| converter |\r\t\tconverter := LanguageEnvironment defaultSystemConverter.\r\t\t[readStream atEnd] whileFalse: [\r\t\t\twriteStream nextPut: (converter nextFromStream: readStream)]].\r"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\r\t^ key findIn: body startingAt: start matchTable: matchTable."},{"name":"isOctetString","linesOfCode":6,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t\"'abc' isOctetString >>> true\"\r\t\r\t^ true.\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":6,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a byte char string, I know that we have to scan single-byte characters and don't have to handle encodings etc\"\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\t^aFont scanByteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX"},{"name":"beginsWith:","linesOfCode":15,"sourceCode":"beginsWith: prefix\r\t\"Answer whether the receiver begins with the given prefix string.\r\tThe comparison is case-sensitive.\"\r\r\t\"IMPLEMENTATION NOTE:\r\tfollowing algorithm is optimized in primitive only in case self and prefix are bytes like.\r\tOtherwise, if self is wide, then super outperforms,\r\tOtherwise, if prefix is wide, primitive is not correct\"\r\t\r\t\"('pharo' beginsWith: '') >>> false\"\r\t\"('pharo' beginsWith: 'pharo-project') >>> false\"\r\t\"('pharo' beginsWith: 'phuro') >>> false\"\r\t\"('pharo' beginsWith: 'pha') >>> true\"\r\t\r\tprefix class isBytes ifFalse: [^super beginsWith: prefix].\r\t\r\tself size < prefix size ifTrue: [^ false].\r\t^ (self findSubstring: prefix in: self startingAt: 1\r\t\t\tmatchTable: CaseSensitiveOrder) = 1\r"},{"name":"isAsciiString","linesOfCode":2,"sourceCode":"isAsciiString\r\r\r ^(self class findFirstInString: self inSet: NonAsciiMap startingAt: 1) = 0"},{"name":"at:","linesOfCode":6,"sourceCode":"at: index \r\t\"Primitive. Answer the Character stored in the field of the receiver\r\tindexed by the argument. Fail if the index argument is not an Integer or\r\tis out of bounds. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^ Character value: (super at: index)"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitHookPrimitive: self"},{"name":"asKeyCombination","linesOfCode":4,"sourceCode":"asKeyCombination\r\tself size > 1 \r\t\tifTrue: [ self error: 'Shortcuts only take a single letter'].\r\t^ KMSingleKeyCombination from: self first"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock\r\t\"Use double dispatching for speed\"\r\t| index |\r\t^(index := aCollection findFirstInByteString: self startingAt: start) = 0\r\t\tifTrue: [aBlock value]\r\t\tifFalse: [index]"},{"name":"byteAt:put:","linesOfCode":4,"sourceCode":"byteAt: index put: value\r\t<primitive: 61>\r\tself at: index put: value asCharacter.\r\t^value"},{"name":"at:put:","linesOfCode":19,"sourceCode":"at: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter \r\t\tifFalse:[^self errorImproperStore].\r\taCharacter isOctetCharacter ifFalse:[\r\t\t\"Convert to WideString\"\r\t\tself becomeForward: (WideString from: self).\r\t\t^self at: index put: aCharacter.\r\t].\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index ] ]\r\t\tifFalse: [self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #at:put: index: index value: aCharacter ].\r"},{"name":"hasWideCharacterFrom:to:","linesOfCode":3,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Only WideStrings contain these characters\"\r\t^false"}],"meta":{"name":"ByteString class","instanceVariables":[],"methods":[{"name":"stringHash:initialHash:","linesOfCode":14,"sourceCode":"stringHash: aString initialHash: speciesHash\r\r\t| stringSize hash low |\r\t<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>\r\r\t<var: #aHash declareC: 'int speciesHash'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\r\tstringSize := aString size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: stringSize do: [:pos |\r\t\thash := hash + (aString basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash"},{"name":"materializeFrom:","linesOfCode":2,"sourceCode":"materializeFrom: aDecoder\r\r\t^ aDecoder nextEncodedString"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":9,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\r\r\t| stringSize |\r\t<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>\r\t<var: #aCharacter declareC: 'int anInteger'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\r\tstringSize := aString size.\r\tstart to: stringSize do: [:pos |\r\t\t(aString basicAt: pos) = anInteger ifTrue: [^ pos]].\r\r\t^ 0"},{"name":"nonAsciiMap","linesOfCode":2,"sourceCode":"nonAsciiMap\r\t^NonAsciiMap"},{"name":"compare:with:collated:","linesOfCode":20,"sourceCode":"compare: string1 with: string2 collated: order\r\t\"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array.\"\r\r\t<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>\r\t<var: #string1 declareC: 'unsigned char *string1'>\r\t<var: #string2 declareC: 'unsigned char *string2'>\r\t<var: #order declareC: 'unsigned char *order'>\r\t| len1 len2 c1 c2 |\r\tlen1 := string1 size.\r\tlen2 := string2 size.\r\t1 to: (len1 min: len2) do: [ :i | \r\t\tc1 := order at: (string1 basicAt: i) + 1.\r\t\tc2 := order at: (string2 basicAt: i) + 1.\r\t\tc1 = c2\r\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\tifFalse: [ 3 ] ] ].\r\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t^ len1 < len2\r\t\tifTrue: [ 1 ]\r\t\tifFalse: [ 3 ]"},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize\r\t\"ByteString initialize\"\r\r\tNonAsciiMap := ByteArray new: 256.\r\t0 to: 255 do: [ :i | \r\t\ti < 128\r\t\t\tifTrue: [ NonAsciiMap at: i + 1 put: 0\t\"valid ascii subset\" ]\r\t\t\tifFalse: [ NonAsciiMap at: i + 1 put: 1\t\"extended charset\" ] ]"},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":12,"sourceCode":"findFirstInString: aString  inSet: inclusionMap  startingAt: start\r\t| i stringSize |\r\t<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\t<var: #inclusionMap  declareC: 'char *inclusionMap'>\r\r\tinclusionMap size ~= 256 ifTrue: [ ^0 ].\r\r\ti := start.\r\tstringSize := aString size.\r\t[ i <= stringSize and: [ (inclusionMap at: (aString basicAt: i) + 1) = 0 ] ] whileTrue: [ \r\t\ti := i + 1 ].\r\r\ti > stringSize ifTrue: [ ^0 ].\r\t^i"},{"name":"translate:from:to:table:","linesOfCode":7,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t\"translate the characters in the string by the given table, in place\"\r\t<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>\r\t<var: #table  declareC: 'unsigned char *table'>\r\t<var: #aString  declareC: 'unsigned char *aString'>\r\r\tstart to: stop do: [ :i |\r\t\taString at: i put: (table at: (aString basicAt: i) + 1) ]"}],"meta":null}},{"name":"Symbol","instanceVariables":[],"methods":[{"name":"at:put:","linesOfCode":3,"sourceCode":"at: anInteger put: anObject \r\t\"You cannot modify the receiver.\"\r\r\tself errorNoModification"},{"name":"isSymbol","linesOfCode":2,"sourceCode":"isSymbol\r\t^ true "},{"name":"isSelectorSymbol","linesOfCode":2,"sourceCode":"isSelectorSymbol\r\t^ (self class selectorTable like: self) notNil"},{"name":"isTestSelector","linesOfCode":3,"sourceCode":"isTestSelector\r\r\t^ self isUnary and: [ \r\t\t  (self beginsWith: 'test') or: [ self beginsWith: 'should' ] ]"},{"name":"rsValue:","linesOfCode":2,"sourceCode":"rsValue: anObject \r\t^ anObject perform: self"},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser.\"\r\r\t^ PPPredicateObjectParser perform: self"},{"name":"includesKey:","linesOfCode":2,"sourceCode":"includesKey: sym\r\t^self == sym."},{"name":"errorNoModification","linesOfCode":2,"sourceCode":"errorNoModification\r\r\tself error: 'symbols can not be modified.'"},{"name":"isInfix","linesOfCode":3,"sourceCode":"isInfix\r\t\"Answer whether the receiver is an infix message selector.\"\r\r\t^ self precedence = 2"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeSymbol: self"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser.\"\r\r\t^ PP2NodeFactory instance perform: self"},{"name":"asAnnouncement","linesOfCode":2,"sourceCode":"asAnnouncement\r\r\t^ self"},{"name":"shallowCopy","linesOfCode":2,"sourceCode":"shallowCopy\r\t\"Answer with the receiver, because Symbols are unique.\""},{"name":"gtInspectorImplementorsIn:","linesOfCode":7,"sourceCode":"gtInspectorImplementorsIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\tcomposite list \r\t\ttitle: 'Implementors';\r\t\tdisplay: [ self systemNavigation allImplementorsOf: self ];\r\t\tformat: #name;\r\t\tshowOnly: 30"},{"name":"=","linesOfCode":6,"sourceCode":"= aSymbol\r\t\"Compare the receiver and aSymbol.\" \r\tself == aSymbol ifTrue: [^ true].\r\tself class == aSymbol class ifTrue: [^ false].\r\t\"Use String comparison otherwise\"\r\t^ super = aSymbol"},{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ MetacelloMethodSectionPath with: {self}"},{"name":"noiseValueAt:withAmplitude:withTilingPeriod:","linesOfCode":2,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude withTilingPeriod: tilingPeriod\r\t^ (coord perform: self with: tilingPeriod) * amplitude"},{"name":"isKeyword","linesOfCode":3,"sourceCode":"isKeyword\r\t\"Answer whether the receiver is a message keyword.\"\r\r\t^ self precedence = 3"},{"name":"isMbndAnonymousSymbol","linesOfCode":2,"sourceCode":"isMbndAnonymousSymbol\r\t^ self = #_"},{"name":"flushCache","linesOfCode":3,"sourceCode":"flushCache\r\t\"Tell the virtual machine to remove all entries with this symbol as a selector from its method lookup caches, if it has any.  This \tmust be done whenever a method is added, redefined or removed, so that message lookups reflect the revised organization.  c.f. \tBehavior>>flushCache & CompiledMethod>>flushCache.  Essential. See MethodDictionary class comment.\"\r\r\t<primitive: 119>\r"},{"name":"brickValue:","linesOfCode":2,"sourceCode":"brickValue: aBrick\r\r\t^ self cull: aBrick"},{"name":"isDoIt","linesOfCode":2,"sourceCode":"isDoIt\r\r\t^ (self == #DoIt) or: [self == #DoItIn:]."},{"name":"rwValue:","linesOfCode":2,"sourceCode":"rwValue: anObject \r\t^ anObject perform: self"},{"name":"setPostLoadDoItInMetacelloSpec:","linesOfCode":8,"sourceCode":"setPostLoadDoItInMetacelloSpec: aMetacelloSpec\r    self precedence == 0\r        ifTrue: [ self error: 'Invalid selector' ].\r    aMetacelloSpec\r        setPostLoadDoIt:\r            (aMetacelloSpec project valueHolderSpec\r                value: self;\r                yourself)"},{"name":"setPreLoadDoItInMetacelloSpec:","linesOfCode":8,"sourceCode":"setPreLoadDoItInMetacelloSpec: aMetacelloSpec\r    self precedence == 0\r        ifTrue: [ self error: 'Invalid selector' ].\r    aMetacelloSpec\r        setPreLoadDoIt:\r            (aMetacelloSpec project valueHolderSpec\r                value: self;\r                yourself)"},{"name":"identifiesClapParameter:","linesOfCode":2,"sourceCode":"identifiesClapParameter: aClapParameter\r\t^ self = aClapParameter identifier"},{"name":"gtInspectorSendersIn:","linesOfCode":7,"sourceCode":"gtInspectorSendersIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\tcomposite list \r\t\ttitle: 'Senders';\r\t\tdisplay: [ self systemNavigation allSendersOf: self ];\r\t\tformat: #name;\r\t\tshowOnly: 30 "},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":2,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart\r\r\tself errorNoModification"},{"name":"=>","linesOfCode":5,"sourceCode":"=> aVariable\r\t\"If the slot we give as argument is not present in the image, we create an UndefinedSlot with the AST of the slot definition\"\r\r\t^ aVariable \r\t\tifNil: [ UndefinedSlot named: self ast: thisContext sender sourceNodeExecuted]\r\t\tifNotNil: [ aVariable named: self ]"},{"name":"asGlamourOriginIdentifier","linesOfCode":2,"sourceCode":"asGlamourOriginIdentifier\r\t^ GLMPortIdentifier defaultOriginOf: self"},{"name":"collatedBy:","linesOfCode":4,"sourceCode":"collatedBy: aSortFunction\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated iusing aSortFunction.\"\r\t\"(#('abc' 'de' 'fghi') sorted: (#size collatedBy: [:e|e bitAnd: 1]) , #size) >>> #( 'de' 'fghi' 'abc')\"\r\r\t^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction"},{"name":"brickValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"brickValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject perform: self withEnoughArguments: aCollection"},{"name":"uncapitalized","linesOfCode":3,"sourceCode":"uncapitalized\r\t\"Answer an object like the receiver but with first character downshifted if necessary\"\r\r\t^ self asString uncapitalized asSymbol"},{"name":"asTestSelector","linesOfCode":10,"sourceCode":"asTestSelector\r\r\t\"Converts a method selector into a test selector in form of #testOriginalSelector\"\r\r\t\"#+ asTestSelector >>> #testPlus\"\r\t\"#+-<> asTestSelector >>>  #testPlusMinusLessThanGreaterThan\"\r\t\"#message asTestSelector  >>> #testMessage\"\r\t\"#mySelector asTestSelector >>> #testMySelector\"\r\t\"#at:putNext: asTestSelector >>> #testAtPutNext\"\r\r\tself isBinary ifTrue: [ \r\t\t^ (#test, (self flatCollect: [ :each | (((Character specialCharacterNames at: each) copyReplaceAll: '-' with: ' ') substrings collect: #capitalized) joinUsing: ''])) asSymbol ].\r\t\r\t^ (#test, (((self copyReplaceAll: ':' with: ' ') substrings collect: #capitalized) joinUsing: '')) asSymbol"},{"name":"handlesAnnouncement:","linesOfCode":7,"sourceCode":"handlesAnnouncement: anAnnouncement \r\t\"Anything else than the announcement identifier (in the case of symbol i.e. #foo for ... on: #foo send: #bar to: nil) will not \r\tbe handled.\"\r\t\r\t\"Announcer new \r\t\ton: #FOO send: #bar to: nil;\r\t\tannounce: #FOO should raise DNU bar\"\r\t\r\t^ anAnnouncement == self"},{"name":"senders","linesOfCode":2,"sourceCode":"senders\r\t^ SystemNavigation default allSendersOf: self"},{"name":"cull:","linesOfCode":2,"sourceCode":"cull: anObject \r\t^anObject perform: self."},{"name":"separateKeywords","linesOfCode":11,"sourceCode":"separateKeywords\r\t\"#'foo:zork:' separateKeywords -> 'foo:  zork:'\"\r\r\tself isKeyword\r\t\tifFalse: [ ^ self ].\r\t^ String streamContents: [ :stream | \r\t\t\t(self findTokens: $:) \r\t\t\t\tdo: [ :each | \r\t\t\t\t\tstream\r\t\t\t\t\t\tnextPutAll: each;\r\t\t\t\t\t\tnextPut: $: ]\r\t\t\t\tseparatedBy: [ stream nextPutAll: '  ' ] ]"},{"name":"phlowValue:value:","linesOfCode":2,"sourceCode":"phlowValue: anObject value: otherObject\r\r\t^ anObject perform: self withEnoughArguments: { otherObject }"},{"name":",","linesOfCode":5,"sourceCode":", otherSymbolOrString\r\t\"Concatenate the receiver with otherSymbolOrString and return the result.\r\tOverwritten to always return Symbol results,\r\twhether the argument is a Symbol or a String\"\r\t\r\t^ (super , otherSymbolOrString) asSymbol"},{"name":"prepareForDelivery","linesOfCode":2,"sourceCode":"prepareForDelivery\r\t\"somehow symbol can be announcemnt\""},{"name":"phlowValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"phlowValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject perform: self withEnoughArguments: aCollection"},{"name":"precedence","linesOfCode":8,"sourceCode":"precedence\r\t\"Answer the receiver's precedence, assuming it is a valid Smalltalk\r\tmessage selector or 0 otherwise.  The numbers are 1 for unary,\r\t2 for binary and 3 for keyword selectors.\"\r\r\tself size = 0 ifTrue: [^ 0].\r\t(self first isLetter or: [ self first = $_ ]) ifFalse: [^ 2].\r\tself last = $: ifTrue: [^ 3].\r\t^ 1"},{"name":"asGlamourTargetIdentifier","linesOfCode":2,"sourceCode":"asGlamourTargetIdentifier\r\t^ GLMPortIdentifier defaultTargetOf: self"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createSymbolObjectInstance: self"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget literalSymbolType"},{"name":"isUnary","linesOfCode":3,"sourceCode":"isUnary\r\t\"Answer whether the receiver is an unary message selector.\"\r\r\t^ self precedence = 1"},{"name":"setForDo:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: {self} do: aBlock"},{"name":"copy","linesOfCode":2,"sourceCode":"copy\r\t\"Answer with the receiver, because Symbols are unique.\""},{"name":"sorted:","linesOfCode":3,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison. We convert the symbol to an array because symbols can't be changed.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"asMutator","linesOfCode":10,"sourceCode":"asMutator\r\t\"Return a setter message from a getter message.\r\tReturn self if it is already a setter. \r\tPay attention the implementation should be improved to return valid selector.\"\r\t\r\t\"#name asMutator >>> #name:\"\r\t\"#name: asMutator >>> #name:\"\r\r\t\"#_ asMutator >>> #_:\"\r\t\"#foo:: asMutator >>> #'foo::'\"\r\t\r\tself endsWithAColon ifTrue:[ ^ self ].\r\t^ (self copyWith: $:) asSymbol"},{"name":"asSortFunction","linesOfCode":4,"sourceCode":"asSortFunction\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size ascending) >>> #('de' 'abc' 'fghi')\"\r\r\t^PropertySortFunction property: self"},{"name":"glamourValueWithArgs:","linesOfCode":4,"sourceCode":"glamourValueWithArgs: anArray \r\t \r\tanArray size < 1 ifTrue: [^nil]. \r\t^anArray first perform: self"},{"name":"capitalized","linesOfCode":2,"sourceCode":"capitalized\r\t^ self asString capitalized asSymbol"},{"name":"isBinary","linesOfCode":3,"sourceCode":"isBinary\r\t\"Answer whether the receiver is a binary message selector.\"\r\r\t^ self precedence = 2"},{"name":"value:","linesOfCode":2,"sourceCode":"value: anObject \r\t^anObject perform: self."},{"name":"setForVersion:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForVersion: aString withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: {self} version: aString"},{"name":"asMetacelloAttributeList","linesOfCode":2,"sourceCode":"asMetacelloAttributeList\r    ^ {self}"},{"name":"numArgs:","linesOfCode":14,"sourceCode":"numArgs: n\r\t\"Answer a string that can be used as a selector with n arguments.\r\t TODO: need to be extended to support shrinking and for selectors like #+ \" \r\r\t| selector numArgs offs |\r\t\r\tselector := self.\r\t(numArgs := selector numArgs) >= n \r\t\tifTrue: [ ^ self ].\r\t\r\t^ self class new: 16 streamContents: [ :stream|\r\t\tstream nextPutAll: self.\r\t\t(numArgs = 0) \r\t\t\tifTrue: [ stream nextPut: $:. offs := 0] \r\t\t\tifFalse: [ offs := 1 ].\r\t\t2 to: n - numArgs + offs do: [:i | \r\t\t\tstream nextPutAll: 'with:' ]].\r\t\r"},{"name":"asString","linesOfCode":6,"sourceCode":"asString \r\t\"Refer to the comment in String|asString.\"\r\t| newString |\r\tnewString := self species new: self size.\r\tnewString replaceFrom: 1 to: newString size with: self startingAt: 1.\r\t^newString"},{"name":"asSymbol","linesOfCode":2,"sourceCode":"asSymbol \r\t\"Refer to the comment in String|asSymbol.\""},{"name":"asMethodPreamble","linesOfCode":14,"sourceCode":"asMethodPreamble\r\tself numArgs = 0\r\t\tifTrue: [ ^ self asString ].\r\t^ String\r\t\tstreamContents: [ :str | \r\t\t\t| keywords |\r\t\t\tkeywords := self keywords.\r\t\t\tkeywords\r\t\t\t\tdoWithIndex: [ :each :index | \r\t\t\t\t\tstr\r\t\t\t\t\t\tnextPutAll: each;\r\t\t\t\t\t\tnextPutAll: ' var';\r\t\t\t\t\t\tnextPutAll: index asString.\r\t\t\t\t\tindex = keywords size ifFalse: [ str space ] ] ]"},{"name":"descending","linesOfCode":4,"sourceCode":"descending\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in descending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size descending) >>> #('fghi' 'abc' 'de')\"\r\r\t^self asSortFunction reversed"},{"name":"storeOn:","linesOfCode":5,"sourceCode":"storeOn: aStream \r\r\taStream nextPut: $#.\r\t(self isLiteralSymbol)\r\t\tifTrue: [aStream nextPutAll: self]\r\t\tifFalse: [super storeOn: aStream]"},{"name":"phlowValue:","linesOfCode":2,"sourceCode":"phlowValue: anObject\r\r\t^ self cull: anObject"},{"name":"asIcon","linesOfCode":4,"sourceCode":"asIcon\r\tself deprecated: 'Do not use #foo asIcon but self iconNamed: #foo' \r\t\ttransformWith: '`@rec asIcon'  -> 'self iconNamed: `@rec'.\r\t^ Smalltalk ui icons iconNamed: self"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeSymbol: self"},{"name":"noiseValueAt:withAmplitude:","linesOfCode":2,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude\r\t^ (coord perform: self) * amplitude"},{"name":"ascending","linesOfCode":4,"sourceCode":"ascending\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size ascending) >>> #('de' 'abc' 'fghi')\"\r\r\t^self asSortFunction "},{"name":"asClapIdentifier","linesOfCode":2,"sourceCode":"asClapIdentifier\r\t^ self"},{"name":"isOrientedFill","linesOfCode":3,"sourceCode":"isOrientedFill\r\t\"Needs to be implemented here because symbols can occupy 'color' slots of morphs.\"\r\r\t^ false"},{"name":"implementors","linesOfCode":2,"sourceCode":"implementors\r\t^SystemNavigation new allImplementorsOf: self"},{"name":"string:","linesOfCode":3,"sourceCode":"string: aString\r\r\t1 to: aString size do: [:j | super at: j put: (aString at: j)].\r\t^self  "},{"name":"veryDeepCopyWith:","linesOfCode":2,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Return self.  I am immutable in the Morphic world.  Do not record me.\""}],"meta":{"name":"Symbol class","instanceVariables":[],"methods":[{"name":"selectorsContaining:","linesOfCode":26,"sourceCode":"selectorsContaining: aString\r\t\"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter.\"\r\r\t| size selectorList ascii |\r\r\tselectorList := OrderedCollection new.\r\t(size := aString size) = 0 ifTrue: [^selectorList].\r\r\taString size = 1 ifTrue:\r\t\t[\r\t\t\tascii := aString first asciiValue.\r\t\t\tascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]\r\t\t].\r\r\t(aString first isAlphaNumeric) ifFalse:\r\t\t[\r\t\t\taString size = 2 ifTrue: \r\t\t\t\t[Symbol hasInterned: aString ifTrue:\r\t\t\t\t\t[:s | selectorList add: s]].\r\t\t\t^selectorList\r\t\t].\r\r\tselectorList := selectorList copyFrom: 2 to: selectorList size.\r\r\tself allSymbolTablesDo: [:each |\r\t\teach size >= size ifTrue:\r\t\t\t[(each findSubstring: aString in: each startingAt: 1 \r\t\t\t\tmatchTable: CaseInsensitiveOrder) > 0\r\t\t\t\t\t\tifTrue: [selectorList add: each]]].\r\r\t^selectorList reject: [:each | \"reject non-selectors, but keep ones that begin with an uppercase\"\r\t\teach numArgs < 0 and: [each asString uncapitalized numArgs < 0]].\r\r\"Symbol selectorsContaining: 'scon'\""},{"name":"new:","linesOfCode":2,"sourceCode":"new: aSize\r\r\tself shouldNotImplement ."},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ (super new: size streamContents: aBlock) asSymbol"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ String"},{"name":"thatStarts:skipping:","linesOfCode":25,"sourceCode":"thatStarts: leadingCharacters skipping: skipSym\r\t\"Answer a selector symbol that starts with leadingCharacters.\r\tSymbols beginning with a lower-case letter handled directly here.\r\tIgnore case after first char.\r\tIf skipSym is not nil, it is a previous answer; start searching after it.\r\tIf no symbols are found, answer nil.\r\tUsed by Alt-q (Command-q) routines\"\r\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\r\tself allSymbolTablesDo: [:each |\r\t\t\teach size >= size ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: false) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r\r\"Symbol thatStarts: 'sf' skipping: nil\"\r\"Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:\"\r\"Symbol thatStarts: 'candidate' skipping: nil\"\r"},{"name":"rehash","linesOfCode":6,"sourceCode":"rehash\r   \"Symbol rehash\"\r\t\"Rebuild the hash table, reclaiming unreferenced Symbols.\"\r\r\tSymbolTable := WeakSet withAll: self allSubInstances.\r\tNewSymbols := WeakSet new.\r\tself rebuildSelectorTable."},{"name":"forbiddenSelectorsForMethodFinder","linesOfCode":2,"sourceCode":"forbiddenSelectorsForMethodFinder\r\r\t^ #(string: privateAt:put:)"},{"name":"findInterned:","linesOfCode":3,"sourceCode":"findInterned: aString\r\r\tself hasInterned:aString ifTrue:[:symbol| ^symbol].\r\t^nil."},{"name":"allSymbols","linesOfCode":7,"sourceCode":"allSymbols\r\t\"Answer all interned symbols\"\r\t^Array streamContents:[:s|\r\t\ts nextPutAll: NewSymbols.\r\t\ts nextPutAll: OneCharacterSymbols.\r\t\ts nextPutAll: SymbolTable.\r\t].\r"},{"name":"initSelectorTable","linesOfCode":2,"sourceCode":"initSelectorTable\r\t^ SelectorTable := WeakSet new"},{"name":"hasInterned:ifTrue:","linesOfCode":8,"sourceCode":"hasInterned: aString ifTrue: symBlock\r\t\"Answer with false if aString hasnt been interned (into a Symbol),  \r\totherwise supply the symbol to symBlock and return true.\"\r\r\t^ (self lookup: aString)\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :symbol | \r\t\t\tsymBlock value: symbol.\r\t\t\ttrue ]"},{"name":"possibleSelectorsFor:","linesOfCode":23,"sourceCode":"possibleSelectorsFor: misspelled \r\t\"Answer an ordered collection of possible corrections\r\tfor the misspelled selector in order of likelyhood\"\r\r\t| numArgs candidates lookupString best binary short long first |\r\tlookupString := misspelled asLowercase. \"correct uppercase selectors to lowercase\"\r\tnumArgs := lookupString numArgs.\r\t(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].\r\tfirst := lookupString first.\r\tshort := lookupString size - (lookupString size // 4 max: 3) max: 2.\r\tlong := lookupString size + (lookupString size // 4 max: 3).\r\r\t\"First assemble candidates for detailed scoring\"\r\tcandidates := OrderedCollection new.\r\tself allSymbolTablesDo: [:s | | ss | (((ss := s size) >= short\t\"not too short\"\r\t\t\tand: [ss <= long\t\t\t\"not too long\"\r\t\t\t\t\tor: [(s at: 1) = first]])\t\"well, any length OK if starts w/same letter\"\r\t\t\tand: [s numArgs = numArgs])\t\"and numArgs is the same\"\r\t\t\tifTrue: [candidates add: s]].\r\r\t\"Then further prune these by correctAgainst:\"\r\tbest := lookupString correctAgainst: candidates.\r\t((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [\r\t\tbinary := misspelled, ':'.\t\t\"try for missing colon\"\r\t\tSymbol hasInterned: binary ifTrue: [:him | best addFirst: him]].\r\t^ best"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t^ (aCollection as: String) asSymbol\r\r\"\tSymbol newFrom: {$P. $e. $n}\r\t{$P. $e. $n} as: Symbol\r\""},{"name":"allSymbolTablesDo:after:","linesOfCode":3,"sourceCode":"allSymbolTablesDo: aBlock after: aSymbol\r\r\tNewSymbols do: aBlock after: aSymbol.\r\tSymbolTable do: aBlock after: aSymbol."},{"name":"withAll:","linesOfCode":2,"sourceCode":"withAll: aCollection\r\t^ self newFrom: aCollection"},{"name":"shutDown:","linesOfCode":3,"sourceCode":"shutDown: aboutToQuit\r\r\tSymbolTable addAll: NewSymbols.\r\tNewSymbols := WeakSet new.\r"},{"name":"internSelector:","linesOfCode":5,"sourceCode":"internSelector: aStringOrSymbol\r\t| selector |\r\tselector := (self selectorTable like: aStringOrSymbol)\r\t\tifNil: [ self selectorTable add: aStringOrSymbol asSymbol ].\r\t^ selector"},{"name":"readFrom:","linesOfCode":4,"sourceCode":"readFrom: strm  \r\t\"Symbol readFromString: '#abc'\"\r\r\tstrm peek = $# ifFalse: [self error: 'Symbols must be introduced by #'].\r    \t^ strm contents parseLiterals first.\r "},{"name":"cleanUp","linesOfCode":4,"sourceCode":"cleanUp\r\t\"Flush caches\"\r\r\tself compactSymbolTable.\r\tself rebuildSelectorTable"},{"name":"selectorTable","linesOfCode":2,"sourceCode":"selectorTable\r\t^SelectorTable ifNil: [self initSelectorTable]"},{"name":"findInternedSelector:","linesOfCode":8,"sourceCode":"findInternedSelector: aString\r\t| symbol |\r\tsymbol := self findInterned: aString.\r\t\"if it isn't found or not a SelectorSymbol - return nil\"\r\t(symbol isNil or: [ symbol isSelectorSymbol not ])\r\t\tifTrue: [ ^ nil ].\r\t\"otherwise, return this symbol\"\r\t^ symbol"},{"name":"selectorThatStartsCaseSensitive:skipping:","linesOfCode":17,"sourceCode":"selectorThatStartsCaseSensitive: leadingCharacters skipping: skipSym\r\t\"Same as thatStartsCaseSensitive:skipping: but on the SelectorTable only\"\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\tself selectorTable do: [:each |\r\t\t\t(each notNil and: [each size >= size]) ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: true) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r"},{"name":"allSymbolTablesDo:","linesOfCode":3,"sourceCode":"allSymbolTablesDo: aBlock\r\r\tNewSymbols do: aBlock.\r\tSymbolTable do: aBlock."},{"name":"compactSymbolTable","linesOfCode":7,"sourceCode":"compactSymbolTable\r\t\"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)\"\r\r\t| oldSize |\r\r\tSmalltalk garbageCollect.\r\toldSize := SymbolTable array size.\r\tSymbolTable growTo: SymbolTable size * 4 // 3 + 100.\r\t^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'"},{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\tSymbol rehash.\r\tOneCharacterSymbols := nil.\r\tOneCharacterSymbols := (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: #Symbol"},{"name":"thatStartsCaseSensitive:skipping:","linesOfCode":17,"sourceCode":"thatStartsCaseSensitive: leadingCharacters skipping: skipSym\r\t\"Same as thatStarts:skipping: but caseSensitive\"\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\tself allSymbolTablesDo: [:each |\r\t\t\teach size >= size ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: true) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r"},{"name":"with:","linesOfCode":2,"sourceCode":"with: aCharacter\r\t^self newFrom: aCharacter asOrderedCollection"},{"name":"internCharacter:","linesOfCode":4,"sourceCode":"internCharacter: aCharacter\r\taCharacter asciiValue > 256 ifTrue:[^self intern: aCharacter asString].\r\tOneCharacterSymbols ifNil: [^self intern: aCharacter asString].\r\t^OneCharacterSymbols at: aCharacter asciiValue + 1\r"},{"name":"intern:","linesOfCode":12,"sourceCode":"intern: aStringOrSymbol \r\r\t^(self lookup: aStringOrSymbol) ifNil:[\r\t\t| aClass aSymbol |\r\t\taStringOrSymbol isSymbol ifTrue:[\r\t\t\taSymbol := aStringOrSymbol.\r\t\t] ifFalse:[\r\t\t\taClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].\r\t\t\taSymbol := aClass basicNew: aStringOrSymbol size.\r\t\t\taSymbol string: aStringOrSymbol.\r\t\t].\r\t\tNewSymbols add: aSymbol.\r\t\taSymbol]."},{"name":"rebuildSelectorTable","linesOfCode":7,"sourceCode":"rebuildSelectorTable\r\tself initSelectorTable.\r\tCompiledMethod\r\t\tallInstancesDo: [ :method | \r\t\t\t| selector |\r\t\t\tselector := method selector.\r\t\t\tselector ifNotNil: [ SelectorTable add: selector ] ]"},{"name":"lookup:","linesOfCode":4,"sourceCode":"lookup: aStringOrSymbol\r\r\t^(SymbolTable like: aStringOrSymbol) ifNil: [\r\t\tNewSymbols like: aStringOrSymbol\r\t]"}],"meta":null}},{"name":"WideString","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\r\t^ self size * 4.\r"},{"name":"asByteArray","linesOfCode":10,"sourceCode":"asByteArray \r\t\"Convert to a ByteArray with the ascii values of the string.\"\r\t\"'a' asByteArray >>> #[97]\"\r\t\"'A' asByteArray >>> #[65]\"\r\t\"'ABA' asByteArray >>> #[65 66 65]\"\r\t| b |\r\tb := ByteArray new: self byteSize.\r\t1 to: self size * 4 do: [:i |\r\t\tb at: i put: (self byteAt: i)].\r\t^ b"},{"name":"byteAt:","linesOfCode":5,"sourceCode":"byteAt: index\r\r\t| d r |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\t^ (self wordAt: d) byteAt: ((4 - r) + 1).\r"},{"name":"wordAt:","linesOfCode":3,"sourceCode":"wordAt: index\r\t<primitive: 60>\r\t^ (self basicAt: index).\r"},{"name":"wordAt:put:","linesOfCode":3,"sourceCode":"wordAt: index put: anInteger\r\t<primitive: 61>\r\tself basicAt: index put: anInteger.\r"},{"name":"asFourCode","linesOfCode":9,"sourceCode":"asFourCode\r\r\t| result |\r\tself size = 1 ifFalse: [^ Error signal: 'must be exactly four octets' ].\r\tresult := self basicAt: 1.\r\t(result bitAnd: 16r80000000) = 0 \r\t\tifFalse: [ Error signal: 'cannot resolve fourcode' ].\r\t(result bitAnd: 16r40000000) = 0 \r\t\tifFalse: [ ^ result - 16r80000000 ].\r\t^ result\r"},{"name":"includesUnifiedCharacter","linesOfCode":2,"sourceCode":"includesUnifiedCharacter\r\r\t^ self isUnicodeStringWithCJK\r"},{"name":"isUnicodeStringWithCJK","linesOfCode":2,"sourceCode":"isUnicodeStringWithCJK\r\r\t^self anySatisfy: [:char | Unicode isUnifiedKanji: char charCode]\r\t"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":6,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\r\t<primitive: 105>\r\treplacement class == String ifTrue: [\r\t\t^ self replaceFrom: start to: stop with: (replacement asWideString) startingAt: repStart.\r\t]. \r\r\t^ super replaceFrom: start to: stop with: replacement startingAt: repStart.\r"},{"name":"asUppercase","linesOfCode":4,"sourceCode":"asUppercase\r\t\"Answer a copy of self with all characters in an upper case.\r\tThis might be a difficult task, ask Unicode.\"\r\t\r\t^ Unicode toUppercaseString: self"},{"name":"asLowercase","linesOfCode":4,"sourceCode":"asLowercase\r\t\"Answer a copy of self with all characters in a lower case.\r\tThis might be a difficult task, ask Unicode.\"\r\t\r\t^ Unicode toLowercaseString: self"},{"name":"mutateJISX0208StringToUnicode","linesOfCode":9,"sourceCode":"mutateJISX0208StringToUnicode\r\r\t| c |\r\t1 to: self size do: [:i |\r\t\tc := self at: i.\r\t\t(c leadingChar = JISX0208 leadingChar or: [\r\t\t\tc leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [\r\t\t\tself basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.\r\t\t]\r\t].\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":8,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a wide char string, I know that we have to scan multi-byte characters and handle encodings etc\"\r\t| charSet |\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\tcharSet := self encodedCharSetAt: startIndex.\r\t^charSet scanMultibyteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX font: aFont\t"},{"name":"copyFrom:to:","linesOfCode":5,"sourceCode":"copyFrom: start to: stop\r\r\t| n |\r\tn := super copyFrom: start to: stop.\r\tn isOctetString ifTrue: [^ n asOctetString].\r\t^ n.\r"},{"name":"at:","linesOfCode":10,"sourceCode":"at: index\r\t\"Answer the Character stored in the field of the receiver indexed by the\r\t argument.  Primitive.  Fail if the index argument is not an Integer or is out\r\t of bounds.  Essential.  See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^index isInteger\r\t\tifTrue:\r\t\t\t[self errorSubscriptBounds: index]\r\t\tifFalse:\r\t\t\t[self errorNonIntegerIndex]"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^true"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ self."},{"name":"byteAt:put:","linesOfCode":8,"sourceCode":"byteAt: index put: aByte\r\r\t| d r w |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\tw := (self wordAt: d) bitAnd: ((16rFF<<((4 - r)*8)) bitInvert32).\r\tw := w + (aByte<<((4 - r)*8)).\r\tself basicAt: d put: w.\r\t^ aByte.\r"},{"name":"at:put:","linesOfCode":15,"sourceCode":"at: index put: aCharacter\r\t\"Store the Character into the field of the receiver indicated by the index.\r\t Primitive.  Fail if the index is not an Integer or is out of bounds, or if the\r\t argument is not a Character.  Essential.  See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter\r\t\tifTrue:\r\t\t\t[index isInteger\r\t\t\t\tifTrue: [ ( index between: 1 and: self size )\r\t\t\t\t\tifFalse: [ ^ self errorSubscriptBounds: index ] ]\r\t\t\t\tifFalse: [ ^ self errorNonIntegerIndex ]]\r\t\tifFalse:\r\t\t\t[ ^ self errorImproperStore ].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #at:put: index: index value: aCharacter ]."},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstring: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"WideString class","instanceVariables":[],"methods":[{"name":"from:","linesOfCode":7,"sourceCode":"from: aString \r\r\t| newString |\r\t(aString isMemberOf: self)\r\t\tifTrue: [^ aString copy].\r\tnewString := self new: aString size.\r\t1 to: aString size do: [:index | newString basicAt: index put: (aString basicAt: index)].\r\t^ newString\r"},{"name":"fromString:","linesOfCode":11,"sourceCode":"fromString: aString \r\t\"Answer an instance of me that is a copy of the argument, aString.\"\r\r\t| inst |\r\t(aString isMemberOf: self) ifTrue: [\r\t\t^ aString copy.\r\t].\r\tinst := self new: aString size.\r\t1 to: aString size do: [:pos |\r\t\tinst basicAt: pos put: (aString basicAt: pos).\r\t].\r\t^ inst.\r"},{"name":"fromByteArray:","linesOfCode":12,"sourceCode":"fromByteArray: aByteArray \r\r\t| inst |\r\taByteArray size \\\\ 4 = 0 ifFalse: [^ ByteString fromByteArray: aByteArray ].\r\tinst := self new: aByteArray size // 4.\r\t4 to: aByteArray size by: 4 do: [:i |\r\t\tinst basicAt: i // 4\r\t\t\tput: ((aByteArray at: i - 3) << 24) + \r\t\t\t\t((aByteArray at: i - 2) << 16) +\r\t\t\t\t ((aByteArray at: i - 1) << 8) +\r\t\t\t\t(aByteArray at: i)\r\t].\r\r\t^ inst\r"},{"name":"newFromStream:","linesOfCode":10,"sourceCode":"newFromStream: s\r\t\"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk.\"\r\t| len |\r\r\ts next = 16r80 ifTrue:\r\t\t[\"A compressed format.  Could copy what BitMap does, or use a \r\t\tspecial sound compression format.  Callers normally compress their own way.\"\r\t\t^ self error: 'not implemented'].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ s nextWordsInto: (self basicNew: len)"}],"meta":null}},{"name":"PointArray","instanceVariables":[],"methods":[{"name":"asPointArray","linesOfCode":2,"sourceCode":"asPointArray\r\t^ self"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Return the number of elements in the receiver\"\r\t^super size // 2"}],"meta":{"name":"PointArray class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^super new: n*2"}],"meta":null}},{"name":"SparseLargeArray","instanceVariables":[{"name":"arrayClass"}],"methods":[{"name":"noCheckAt:","linesOfCode":4,"sourceCode":"noCheckAt: index\r      ^(self basicAt: index - base // chunkSize + 1)\r               ifNil: [defaultValue]\r               ifNotNil: [:chunk| chunk at: index - base \\\\ chunkSize + 1]"},{"name":"atAllPut:","linesOfCode":6,"sourceCode":"atAllPut: anObject\r       \"Put anObject at every one of the receiver's indices.\"\r\r       1 to: self basicSize do:\r               [:i|\r               self basicAt: i put: nil].\r       defaultValue := anObject"},{"name":"analyzeSpaceSaving","linesOfCode":22,"sourceCode":"analyzeSpaceSaving\r\r      | elems tablesTotal nonNilTables lastPage lastChunkSize |\r      elems := 0.\r       tablesTotal := self basicSize.\r       nonNilTables := 0.\r       lastPage := self basicAt: self basicSize.\r       (lastChunkSize := size \\\\ chunkSize) = 0 ifTrue:\r               [lastChunkSize := chunkSize].\r       1 to: self basicSize do:\r               [:i | | page |\r               (page := self basicAt: i) ifNotNil:\r                       [nonNilTables := nonNilTables + 1.\r                        1 to: (page == lastPage ifTrue: [lastChunkSize] ifFalse: [chunkSize]) do:\r                               [:j|\r                               (page at: j) ~= defaultValue ifTrue:\r                                       [elems := elems + 1]]]].\r\r       ^String streamContents:\r               [:strm |\r               strm nextPutAll: 'total: '; print: size.\r               strm nextPutAll: ' elements: '; print: elems.\r               strm nextPutAll: ' tables: '; print: tablesTotal.\r               strm nextPutAll: ' non-nil: '; print: nonNilTables]"},{"name":"initChunkSize:size:arrayClass:base:defaultValue:","linesOfCode":6,"sourceCode":"initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d\r       chunkSize := aChunkSize.\r       size := aSize.\r       base := b.\r       defaultValue := d.\r       arrayClass := aClass"},{"name":"noCheckAt:put:","linesOfCode":14,"sourceCode":"noCheckAt: index put: value\r       | chunkIndex chunk lastChunkSize |\r       chunkIndex := index - base // chunkSize + 1.\r       (chunk := self basicAt: chunkIndex) ifNil:\r               [value = defaultValue ifTrue:\r                       [^value].\r               chunk := arrayClass\r                                       new: ((chunkIndex == self basicSize\r                                                  and: [(lastChunkSize := size \\\\ chunkSize) > 0])\r                                                       ifTrue: [lastChunkSize]\r                                                       ifFalse: [chunkSize])\r                                       withAll: defaultValue.\r               self basicAt: chunkIndex put: chunk].\r       ^chunk at: index - base \\\\ chunkSize + 1 put: value"}],"meta":{"name":"SparseLargeArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FFIArray","instanceVariables":[],"methods":[],"meta":{"name":"FFIArray class","instanceVariables":[{"name":"type"},{"name":"numberOfElements"}],"methods":[{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator \r\t^ FFITypeArrayType objectClass: self"},{"name":"type:size:","linesOfCode":4,"sourceCode":"type: aType \tsize: elements\r\ttype := aType.\r\tnumberOfElements := elements\r\t\t"},{"name":"externalNew","linesOfCode":6,"sourceCode":"externalNew \r\t\"Create a new array in the C heap. \r\t This array needs to be disposed (using #free method)... or you can declare it #autoRelease\"\r\t^ self basicNew \r\t\tinitializeExternalType: self type size: self numberOfElements;\r\t\tyourself"},{"name":"ofType:size:","linesOfCode":4,"sourceCode":"ofType: aTypeName size: elements\r\t^ FFIArray newAnonymousSubclass \r\t\ttype: (FFIExternalType resolveType: aTypeName)\t\r\t\tsize: elements"},{"name":"new","linesOfCode":4,"sourceCode":"new \r\t^ self basicNew \r\t\tinitializeType: self type size: self numberOfElements;\r\t\tyourself"},{"name":"newArrayTypeOf:size:","linesOfCode":4,"sourceCode":"newArrayTypeOf: aTypeName size: elements\r\t^ FFIArray newAnonymousSubclass \r\t\ttype: (FFIExternalType resolveType: aTypeName)\t\r\t\tsize: elements"},{"name":"numberOfElements","linesOfCode":2,"sourceCode":"numberOfElements\r\t^ numberOfElements"},{"name":"type","linesOfCode":2,"sourceCode":"type \r\t^ type"},{"name":"fromHandle:","linesOfCode":4,"sourceCode":"fromHandle: aHandle\r\t^ self basicNew \r\t\tinitializeHandle: aHandle type: self type size: self numberOfElements;\r\t\tyourself"}],"meta":null}},{"name":"CairoGlyphsArray","instanceVariables":[{"name":"allocatedByCairo"}],"methods":[{"name":"allocatedByCairo","linesOfCode":2,"sourceCode":"allocatedByCairo\r\t^ allocatedByCairo "},{"name":"allocatedByCairo:","linesOfCode":2,"sourceCode":"allocatedByCairo: aBoolean\r\tallocatedByCairo := aBoolean"}],"meta":{"name":"CairoGlyphsArray class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: size \r\t^ self newType: CairoGlyph size: size"},{"name":"externalNew:","linesOfCode":2,"sourceCode":"externalNew: size \r\t^ self externalNewType: CairoGlyph size: size"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: nil"}],"meta":null}},{"name":"LGitExternalArray","instanceVariables":[],"methods":[],"meta":{"name":"LGitExternalArray class","instanceVariables":[],"methods":[{"name":"externalNew:","linesOfCode":4,"sourceCode":"externalNew: numberOfElements\r\t^ self \r\t\texternalNewType: self type \r\t\tsize: numberOfElements"},{"name":"onAddress:size:","linesOfCode":2,"sourceCode":"onAddress: handle size: numberOfElements\r\t^ self fromHandle: handle type: self type size: numberOfElements"},{"name":"type","linesOfCode":2,"sourceCode":"type \r\t^ self subclassResponsibility"}],"meta":null}},{"name":"LLVMValueRefArray","instanceVariables":[],"methods":[],"meta":{"name":"LLVMValueRefArray class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: size\r\t^ self newType: #'void*' size: size"},{"name":"withAll:","linesOfCode":7,"sourceCode":"withAll: elements\r\t| result |\r\tresult := self new: elements size.\r\telements doWithIndex: [ :el :index |\r\t\tresult at: index put: el validHandle getHandle\r\t].\r\t^ result"}],"meta":null}},{"name":"RWForceBasedLayoutOctTree","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tnodeSplitCountThreshold := 1."},{"name":"nodeClass","linesOfCode":2,"sourceCode":"nodeClass\r\t^ RWForceBasedLayoutOctTreeNode"}],"meta":{"name":"RWForceBasedLayoutOctTree class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakKeyToCollectionDictionary","instanceVariables":[],"methods":[{"name":"noCheckAddForRehash:","linesOfCode":8,"sourceCode":"noCheckAddForRehash: anAssociation\r\t| cleanedValue |\r\tanAssociation key ifNil:[^self].\r\tcleanedValue := anAssociation value copyWithout: nil.\r\tcleanedValue notEmpty ifTrue:[\r\t\tanAssociation value: cleanedValue.\r\t\tsuper noCheckAddForRehash: anAssociation.\r\t]."},{"name":"finalizeValues","linesOfCode":2,"sourceCode":"finalizeValues \r\tself rehash"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":14,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tassociation key ifNotNil: [ :key | \"Don't let the key go away\"\r\t\t\t\t| cleanedValue |\r\t\t\t\t(cleanedValue := association value copyWithout: nil) isEmpty \r\t\t\t\t\tifFalse: [\r\t\t\t\t\t\tassociation value: cleanedValue.\r\t\t\t\t\t\tarray\r\t\t\t\t\t\t\tat: (self scanForEmptySlotFor: key)\r\t\t\t\t\t\t\tput: association.\r\t\t\t\t\t\ttally := tally + 1 ] ] ] ]"}],"meta":{"name":"WeakKeyToCollectionDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ASTCache","instanceVariables":[],"methods":[{"name":"at:","linesOfCode":7,"sourceCode":"at: aCompiledMethod\r\t\"for doit methods, the ast is stored in the method propery\"\r\t^ aCompiledMethod propertyAt: #ast ifAbsent: [ \r\t\t  self\r\t\t\t  at: aCompiledMethod\r\t\t\t  ifAbsentPut: [ \r\t\t\t  self class cacheMissStrategy getASTFor: aCompiledMethod ] ]"},{"name":"reset","linesOfCode":2,"sourceCode":"reset\r\tself removeAll"}],"meta":{"name":"ASTCache class","instanceVariables":[{"name":"default"}],"methods":[{"name":"at:","linesOfCode":2,"sourceCode":"at: aCompiledMethod\r\t^ self default at: aCompiledMethod"},{"name":"default","linesOfCode":4,"sourceCode":"default\r\t^ default ifNil: [ \r\t\tSessionManager default registerSystemClassNamed: self name.\r\t\tdefault := self new ]"},{"name":"reset","linesOfCode":4,"sourceCode":"reset\r\t<script>\r\tself default reset.\r\tself announceCacheReset"},{"name":"shutDown","linesOfCode":2,"sourceCode":"shutDown\t\r\tself reset"},{"name":"cacheMissStrategy:","linesOfCode":2,"sourceCode":"cacheMissStrategy: aCacheMissStrategy\r\t^ CacheMissStrategy := aCacheMissStrategy"},{"name":"cacheMissStrategy","linesOfCode":3,"sourceCode":"cacheMissStrategy\r\t^ CacheMissStrategy\r\t\tifNil: [ CacheMissStrategy := ASTCacheMissStrategy new ]"},{"name":"default:","linesOfCode":2,"sourceCode":"default: anASTCache\r\tdefault := anASTCache"},{"name":"announceCacheReset","linesOfCode":2,"sourceCode":"announceCacheReset\r\r\tSystemAnnouncer uniqueInstance announce: ASTCacheReset new "}],"meta":null}},{"name":"CompiledBlock","instanceVariables":[],"methods":[{"name":"outerCode:","linesOfCode":2,"sourceCode":"outerCode: aCompiledCode\r\t^self literalAt: self numLiterals put: aCompiledCode"},{"name":"hasProperty:","linesOfCode":2,"sourceCode":"hasProperty: aString \r\t\r\t^ false"},{"name":"sourceNodeInOuter","linesOfCode":2,"sourceCode":"sourceNodeInOuter\r\t^ self outerCode sourceNodeForPC: self pcInOuter"},{"name":"sourceNode","linesOfCode":2,"sourceCode":"sourceNode\r\t^ self sourceNodeInOuter"},{"name":"isEmbeddedBlock","linesOfCode":2,"sourceCode":"isEmbeddedBlock\r\t^ true"},{"name":"endPC","linesOfCode":3,"sourceCode":"endPC\r\t\"Answer the index of the last bytecode.\"\r\t^ self size"},{"name":"isEqualRegardlessTrailerTo:","linesOfCode":2,"sourceCode":"isEqualRegardlessTrailerTo: aCompiledBlock\r\t^ self = aCompiledBlock"},{"name":"literalsToSkip","linesOfCode":2,"sourceCode":"literalsToSkip\r\r\t^ 1"},{"name":"isCompiledBlock","linesOfCode":2,"sourceCode":"isCompiledBlock\r\t^ true"},{"name":"sourcePointer","linesOfCode":2,"sourceCode":"sourcePointer\r\t^self outerCode sourcePointer"},{"name":"hasPragmaNamed:","linesOfCode":2,"sourceCode":"hasPragmaNamed: aSymbol\r\t^ false"},{"name":"gtDisplayOn:","linesOfCode":2,"sourceCode":"gtDisplayOn: stream\r\tself printOn: stream"},{"name":"methodClass","linesOfCode":3,"sourceCode":"methodClass\r\t\"answer the compiled method that I am installed in, or nil if none.\"\r\t^self outerCode methodClass"},{"name":"propertyAt:","linesOfCode":2,"sourceCode":"propertyAt: aString \r\t\r\t^ nil"},{"name":"hash","linesOfCode":16,"sourceCode":"hash\r\t\"CompiledMethod>>#= compares code, i.e. same literals and same bytecode.\r\t So we look at the header, methodClass and some bytes between initialPC and endPC,\r\t but /not/ the selector because the equal method does not compare selectors.\r\t Note that we must override ByteArray>hash which looks at all bytes of the receiver.\r\t Using bytes from the pointer part of a COmpiledmethod can lead to a variable hash\r\t if and when when the GC moves literals in the receiver.\"\r\t| initialPC endPC hash |\r\tinitialPC := self initialPC.\r\tendPC := self endPC.\r\thash := self species hash + self header + initialPC + endPC.\r\t\"sample approximately 20 bytes\"\r\tinitialPC to: endPC by: (endPC - initialPC // 20 max: 1) do:\r\t\t[:i| hash := hash + (self at: i)].\r\t^hash\r\r\t\"(CompiledMethod>>#hash) hash\"\r"},{"name":"fuelPrepare","linesOfCode":2,"sourceCode":"fuelPrepare\r\t\"Nothing to do here\""},{"name":"ast","linesOfCode":2,"sourceCode":"ast\r\t^ self sourceNodeInOuter"},{"name":"hasMethodReturn","linesOfCode":4,"sourceCode":"hasMethodReturn\r\t\"Answer whether the receiver has a method-return ('^') in its code.\"\r\t^ (InstructionStream on: self) scanFor: [:byte | \r\t\t self encoderClass methodReturnBytecodes includes: byte]"},{"name":"sameLiteralsAs:","linesOfCode":13,"sourceCode":"sameLiteralsAs: method\r\t\"Compare my literals to those of method. This is needed to compare compiled methods.\"\r\r\t| numLits literal1 literal2 |\r\t(numLits := self numLiterals) ~= method numLiterals\r\t\tifTrue: [ ^ false ].\r\t\"The last literal requires special checking instead of using #literalEqual:\"\r\t1 to: numLits - 1 do: [ :index | \r\t\tliteral1 := self literalAt: index.\r\t\tliteral2 := method literalAt: index.\r\t\t(literal1 == literal2 or: [ literal1 literalEqual: literal2 ])\r\t\t\tifFalse: [ ^ false ] ].\r\t\"we can't do = on outer code or it will recursively call this code\"\r\t^ true"},{"name":"pcInOuter","linesOfCode":21,"sourceCode":"pcInOuter\r\t| outer end instructionStream |\r\touter := self outerCode.\r\tinstructionStream := InstructionStream on: outer.\r\tend := outer endPC.\r\t[instructionStream pc <= end] whileTrue: \r\t\t[ (self encoderClass isCreateFullBlock: self code: outer at: instructionStream pc)\r\t\t\tifTrue: [ ^ instructionStream pc ].\r\t\t\tinstructionStream pc: (instructionStream nextPc: (outer at: instructionStream pc))].\r\t\"scan for clean block\"\t\r\tinstructionStream := InstructionStream on: outer.\r\t[instructionStream pc <= end] whileTrue: [\r\t\t\t| literalOffset |\r\t\t\tliteralOffset := self encoderClass literalIndexOfBytecodeAt: instructionStream pc in: outer.\r\t\t\tliteralOffset ifNotNil: [\r\t\t\t\t| literal |\r\t\t\t\tliteral := (self outerCode literalAt: literalOffset + 1).\r\t\t\t\t(literal class == CleanBlockClosure and: [literal compiledBlock = self  ])ifTrue: [ ^ instructionStream pc ].  ].\r\t\t\tinstructionStream pc: (instructionStream nextPc: (outer at: instructionStream pc))].\t\r\t\t\r\tself error: 'block not installed in outer code'."},{"name":"outerCode","linesOfCode":3,"sourceCode":"outerCode\r\t\"answer the compiled code that I am installed in, or nil if none.\"\r\t^self literalAt: self numLiterals"},{"name":"hasSourceCode","linesOfCode":2,"sourceCode":"hasSourceCode\r\t^ self method hasSourceCode"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: anStream\r\t\r\tanStream \r\t\tnextPutAll: 'a CompiledBlock: ';\r\t\tnextPutAll: self sourceNode sourceCode "},{"name":"properties","linesOfCode":2,"sourceCode":"properties\r\t^ nil->nil"},{"name":"pragmas","linesOfCode":2,"sourceCode":"pragmas\r\t^ #()"},{"name":"sourceNodeForPC:","linesOfCode":4,"sourceCode":"sourceNodeForPC: aPC\r\t| blockNode |\r\tblockNode := self outerCode sourceNodeForPC: self pcInOuter.\r\t^blockNode sourceNodeForPC: aPC"},{"name":"isInstalled","linesOfCode":2,"sourceCode":"isInstalled\r\t\r\t^ self method isInstalled"},{"name":"primitive","linesOfCode":2,"sourceCode":"primitive\r\t^ 0"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitCompiledBlock: self"},{"name":"methodNode","linesOfCode":2,"sourceCode":"methodNode\r\t^ self outerCode methodNode"},{"name":"selector","linesOfCode":2,"sourceCode":"selector\r\t^ self outerCode selector"},{"name":"isTestMethod","linesOfCode":2,"sourceCode":"isTestMethod\r\t^ false"},{"name":"sourceCode","linesOfCode":2,"sourceCode":"sourceCode\r\t^ self outerCode sourceCode"},{"name":"method","linesOfCode":3,"sourceCode":"method\r\t\"answer the compiled method that I am installed in, or nil if none.\"\r\t^self outerCode method"}],"meta":{"name":"CompiledBlock class","instanceVariables":[],"methods":[],"meta":null}},{"name":"CompiledMethod","instanceVariables":[],"methods":[{"name":"asRingDefinition","linesOfCode":4,"sourceCode":"asRingDefinition\r\t\"Retrieves an active RGMethodDefinition object based on the receiver.\r\tNote that its class is not converted.\"\r\t\r\t^ self asActiveRingDefinition"},{"name":"sourceNode","linesOfCode":2,"sourceCode":"sourceNode\r\t^self ast"},{"name":"destroyTwin","linesOfCode":2,"sourceCode":"destroyTwin\r\tself reflectiveMethod: nil"},{"name":"literalsToSkip","linesOfCode":2,"sourceCode":"literalsToSkip\r\r\t^ 2"},{"name":"pragmasDo:","linesOfCode":4,"sourceCode":"pragmasDo: aBlock\r\t| selectorOrProperties |\r\t(selectorOrProperties := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [selectorOrProperties pragmasDo: aBlock]"},{"name":"astForStylingInCalypso","linesOfCode":4,"sourceCode":"astForStylingInCalypso\r\t\"this method simplified remote method styling. \r\tRemote proxy will redefine it by building AST on client side\"\r\t^self ast"},{"name":"protocol:","linesOfCode":2,"sourceCode":"protocol: aString\r\t^ self methodClass organization classify: self selector under: aString"},{"name":"asRingMinimalDefinitionIn:","linesOfCode":3,"sourceCode":"asRingMinimalDefinitionIn: anRGEnvironment\r\r\t^ anRGEnvironment backend definitionFor: self ifAbsentRegister: [\r\t\tRGMethod named: self selector asSymbol parent: (self methodClass asRingMinimalDefinitionIn: anRGEnvironment)]\r"},{"name":"writesField:","linesOfCode":4,"sourceCode":"writesField: varIndex\r\t\"Answer whether the receiver stores into the instance variable indexed by the argument.\"\r\tself isQuick ifTrue: [^false].\r\t^ super writesField: varIndex"},{"name":"selfMessages","linesOfCode":2,"sourceCode":"selfMessages\r\t^self ast selfMessages"},{"name":"ban:","linesOfCode":7,"sourceCode":"ban: aCritique\r\r\tReSystemAnnouncer uniqueInstance\r\t\tnotifyCritique: aCritique\r\t\tof: aCritique sourceAnchor entity\r\t\tbannedOn: self.\r\r\t(TheManifestBuilder of: self)\r\t\tbanRule: aCritique rule for: self."},{"name":"criticNameOn:","linesOfCode":9,"sourceCode":"criticNameOn: aStream\r\t\"This behavior may be folded later by changing the name of this method or using another one.\"\r\t\r\taStream \r\t\t<< self methodClass name \r\t\t<< '>>#' \r\t\t<< self selector  \r\t\t<< ' (' \r\t\t<< self methodClass instanceSide category \r\t\t<< ')'"},{"name":"prepareForSimulationWith:","linesOfCode":10,"sourceCode":"prepareForSimulationWith: numArgs\r\t\"This method changes the argument count of a CompiledMethod header to numArgs, its temporary count to numArgs + 1 and change the code handling primitive error to store the error code in the unique temporary of the method\"\r\t\t\t\r\t| newHeader |\r\tnewHeader := (((self header bitAnd: 2r01110000000000111111111111111111) \r\t\t\tbitOr: (numArgs bitShift: 24))\r\t\t\tbitOr: (numArgs + 1 bitShift: 18)).\r\tnewHeader := newHeader + (self class headerFlagForEncoder: self encoderClass).\r\tself objectAt: 1 put: newHeader.\r\t\r\tself encoderClass prepareMethod: self forSimulationWith: numArgs"},{"name":"pragmas","linesOfCode":5,"sourceCode":"pragmas\r\t| selectorOrProperties |\r\t^(selectorOrProperties := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [selectorOrProperties pragmas]\r\t\tifFalse: [#()]"},{"name":"dependentClassesWithOccurences","linesOfCode":13,"sourceCode":"dependentClassesWithOccurences\r\t\"Return the list of classes used myself. The result contains my superclass. The result may contains multiple times the same element.\"\r\t\r\t\"(Morph>>#drawOn:) dependentClassesWithOccurences\"\r\t\"(CompiledMethod>>#dependentClassesWithOccurences) dependentClassesWithOccurences\"\r\t| cll | \r\tcll := OrderedCollection new.\r\t\r\t\"We unify a class and its metaclass\"\r\tself literalsDo: [ :l | \r\t\t\t\t\t\"We also check if the method is not an extension\"\r\t\t\t\t\t((l isVariableBinding \r\t\t\t\t\tand: [ l value notNil ]) \r\t\t\t\t\tand: [ l value isBehavior ])  ifTrue: [ cll add: l value ] ].\r\t^ cll asArray"},{"name":"asFullRingDefinition","linesOfCode":9,"sourceCode":"asFullRingDefinition\r\r\t\"Retrieves an active RGMethodDefinition which knows its parent <class>.\r\tNote that the full conversion does not happen at the level of the class. If you need that request asFullRingDefinition to the class\"\r\t| rgClass rgMethod |\r\trgClass := self realClass asRingDefinition.\r\trgMethod := self asActiveRingDefinition.\r\trgClass addMethod: rgMethod.\r\trgMethod package: (RGContainer packageOfMethod: rgMethod).\r\t^ rgMethod"},{"name":"refersToLiteral:","linesOfCode":3,"sourceCode":"refersToLiteral: aLiteral\r\t\"Answer true if any literal in this method is literal, even if embedded in array structure.\"\r\t\r\t^(self pragmaRefersToLiteral: aLiteral) or: [ super refersToLiteral: aLiteral]"},{"name":"spotterForImplementorsFor:","linesOfCode":7,"sourceCode":"spotterForImplementorsFor: aStep\r\t<spotterOrder: 10>\r\taStep listProcessor\r\t\t\ttitle: 'Implementors';\r\t\t\tallCandidates: [ self implementors collect: [:each | each compiledMethod] ];\r\t\t\tfilter: GTFilterSubstring;\r\t\t\tkeyBinding: $m command"},{"name":"drTestsName","linesOfCode":2,"sourceCode":"drTestsName\r\t^ self printString"},{"name":"banLevelCandidates","linesOfCode":3,"sourceCode":"banLevelCandidates\r\"returns code entities which can ban a rule for this entity\"\r\r\t^ { self } , self methodClass banLevelCandidates"},{"name":"isCompiledMethod","linesOfCode":2,"sourceCode":"isCompiledMethod\r\r\t^ true"},{"name":"argumentNames","linesOfCode":2,"sourceCode":"argumentNames\r\t^ self propertyAt: #argumentNames ifAbsent: [ super argumentNames ]"},{"name":"createTwin","linesOfCode":2,"sourceCode":"createTwin\r\tself reflectiveMethod: (ReflectiveMethod on: self)"},{"name":"reflectiveMethod","linesOfCode":2,"sourceCode":"reflectiveMethod\r\t^self propertyAt: #reflectiveMethod ifAbsent: nil"},{"name":"pragmaRefersToLiteral:","linesOfCode":3,"sourceCode":"pragmaRefersToLiteral: literal\r\r\t^ self penultimateLiteral isMethodProperties and: [ \r\t\t  self pragmas anySatisfy: [ :pragma | pragma refersToLiteral: literal ] ]"},{"name":"isBigLiteralMethod","linesOfCode":4,"sourceCode":"isBigLiteralMethod\r\r\t^ self isLiteralMethod \r\t\tand: [ self literals anySatisfy: [ :literal | \r\t\t\t\tliteral class isVariable and: [ literal size > 500 ] ] ]"},{"name":"recompile","linesOfCode":2,"sourceCode":"recompile\r\t^ self methodClass recompile: self selector"},{"name":"actualClass","linesOfCode":5,"sourceCode":"actualClass\r\tself \r\t\tdeprecated: 'use #methodClass'\r\t\ttransformWith:  '`@receiver actualClass' -> '`@receiver methodClass'.\r\t^self methodClass"},{"name":"isFaulty","linesOfCode":11,"sourceCode":"isFaulty\r \t\"check if this method was compiled from syntactically wrong code\"\r\t| ast |\r\t\"fast pre-check: all methods with syntax errors reference this symbol\"\r  \t(self refersToLiteral: #signalSyntaxError:) ifFalse: [ ^false].\r\t\"we have to parse the ast here as #ast does not know that this needs optionParseErrors\"\r\tast := self methodClass compiler \r\t\t\t\tsource: self sourceCode;\r\t\t\t\toptions: #(+ optionParseErrors);\r\t\t\t\tparse.\r\t^ ast isFaulty."},{"name":"isExplicitlyRequired:","linesOfCode":2,"sourceCode":"isExplicitlyRequired: marker\r\t^ marker == self class explicitRequirementMarker"},{"name":"abstractBytecodeMessagesFrom:to:","linesOfCode":12,"sourceCode":"abstractBytecodeMessagesFrom: startpc to: endpc\r\t\"Answer an OrderedCollection of the abstract bytecodes sent in the receiver.\"\r\t| scanner abstractBytecodes |\r\tscanner := InstructionStream new method: self pc: startpc.\r\t\"now collect all the bytecode messages in the block.\"\r\tabstractBytecodes := OrderedCollection new.\r\t[scanner pc <= endpc] whileTrue:\r\t\t[[scanner interpretNextInstructionFor: nil]\r\t\t\ton: MessageNotUnderstood\r\t\t\tdo: [:ex| abstractBytecodes add: ex message]].\r\t^abstractBytecodes\r\r\t\"| m | (m := CompiledMethod >> #abstractBytecodeMessagesFrom:to:) abstractBytecodeMessagesFrom: m initialPC to: m endPC\""},{"name":"propertyAt:ifAbsent:","linesOfCode":5,"sourceCode":"propertyAt: propName ifAbsent: aBlock\r\t| propertiesOrSelector |\r\t^(propertiesOrSelector := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [propertiesOrSelector propertyAt: propName ifAbsent: aBlock]\r\t\tifFalse: [aBlock value]"},{"name":"methodReference","linesOfCode":6,"sourceCode":"methodReference\r\r\t| class selector |\r\tclass := self methodClass ifNil: [^nil].\r\tselector := self selector ifNil: [^nil].\r\t^(RGMethodDefinition realClass: class selector: selector) \r\t\tpackage: self package asRingDefinition; yourself\r\t"},{"name":"hasTemporaryVariableNamed:","linesOfCode":2,"sourceCode":"hasTemporaryVariableNamed: aName\r\t^ self tempNames includes: aName"},{"name":"methodClass","linesOfCode":3,"sourceCode":"methodClass\r\t\"answer the class that I am installed in\"\r\t^self classBinding value"},{"name":"invalidate","linesOfCode":8,"sourceCode":"invalidate\r\t| reflectiveMethod |\r\tself reflectivityDisabled ifTrue: [ ^self ].\r\t\r\treflectiveMethod := self reflectiveMethod.\r\treflectiveMethod ifNil: [^self \"do nothing\"].\r\t(self isRealPrimitive or: (reflectiveMethod ast metaLinkOptionsFromClassAndMethod includes: #optionCompileOnLinkInstallation))\r\t\t\t\t\tifTrue: [reflectiveMethod compileAndInstallCompiledMethod ] \r\t\t\t\t\tifFalse: [reflectiveMethod installReflectiveMethod]\r\t"},{"name":"metaLinkOptions","linesOfCode":10,"sourceCode":"metaLinkOptions\r\t^{\r\t#penultimateLiteral -> #( + optionCompileOnLinkInstallation).\r\t#selector -> #( + optionCompileOnLinkInstallation).\r\t#objectAt: -> #( + optionCompileOnLinkInstallation).\r\t#header -> #( + optionCompileOnLinkInstallation).\r\t#numLiterals -> #( + optionCompileOnLinkInstallation).\r\t#literalAt: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"isSubclassResponsibility","linesOfCode":2,"sourceCode":"isSubclassResponsibility\r\t^ self isSubclassResponsibility: self markerOrNil"},{"name":"putSource:class:category:withStamp:priorMethod:","linesOfCode":10,"sourceCode":"putSource: sourceStr class: class category: catName withStamp: changeStamp priorMethod: priorMethod\r\t^ self\r\t\tputSource: sourceStr\r\t\twithPreamble: [ :file | \r\t\t\tclass\r\t\t\t\tprintCategoryChunk: catName\r\t\t\t\ton: file\r\t\t\t\twithStamp: changeStamp\r\t\t\t\tpriorMethod: priorMethod.\r\t\t\tfile cr ]"},{"name":"spotterForBytecodesFor:","linesOfCode":7,"sourceCode":"spotterForBytecodesFor: aStep\r\t<spotterOrder: 15>\r\taStep listProcessor\r\t\ttitle: 'Bytecode';\r\t\tallCandidates: [ self symbolicBytecodes ];\r\t\titemName: #printString;\r\t\tfilter: GTFilterSubstring"},{"name":"asMCMethodDefinition","linesOfCode":14,"sourceCode":"asMCMethodDefinition\r   \"Creates a MCMethodDefinition from the receiver\"\r\t| cached |\r\tcached := MCMethodDefinition cachedDefinitions\r\t\tat: self\r\t\tifAbsent: [ nil ].\r\r\t\"we compare that the cached version is in sync with the version \r\tthe receiver represents because it is an identity structure and the container (here the method definition may have changed internally: different packages, protocol.... )\"\r\t(cached notNil and: [ self sameAsMCDefinition: cached ]) ifFalse: [\r\t\tcached := self basicAsMCMethodDefinition.\r\t\tMCMethodDefinition cachedDefinitions \r\t\t\tat: self \r\t\t\tput: cached ].\r\r\t^ cached"},{"name":"sourceNodeForPC:","linesOfCode":2,"sourceCode":"sourceNodeForPC: aPC\r\t^self sourceNode sourceNodeForPC: aPC"},{"name":"returnField","linesOfCode":8,"sourceCode":"returnField\r\t\"Answer the index of the instance variable returned by a quick return \r\tmethod.\"\r\t| prim |\r\tprim := self primitive.\r\tprim < 264\r\t\tifTrue: [self error: 'only meaningful for quick-return']\r\t\tifFalse: [^ prim - 264]"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitCompiledMethod: self"},{"name":"blockNodes","linesOfCode":2,"sourceCode":"blockNodes\r\t^self ast blockNodes"},{"name":"storeOn:","linesOfCode":21,"sourceCode":"storeOn: aStream\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' newMethod: '.\r\taStream store: self size - self initialPC + 1.\r\taStream nextPutAll: ' header: '.\r\taStream store: self header.\r\taStream nextPut: $).\r\tnoneYet := self storeElementsFrom: self initialPC to: self endPC on: aStream.\r\t1 to: self numLiterals do:\r\t\t[:index |\r\t\tnoneYet\r\t\t\tifTrue: [noneYet := false]\r\t\t\tifFalse: [aStream nextPut: $;].\r\t\taStream nextPutAll: ' literalAt: '.\r\t\taStream store: index.\r\t\taStream nextPutAll: ' put: '.\r\t\taStream store: (self literalAt: index)].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"populateCBMenu:","linesOfCode":12,"sourceCode":"populateCBMenu: aMenu\r\t\r\tsuper populateCBMenu: aMenu.\r\taMenu\r\t\tadd: 'Implementors of...'\r\t\ttarget: SystemNavigation new\r\t\tselector: #browseAllImplementorsOf:\r\t\targument: self selector;\r\t\t\r\t\tadd: 'Senders of...'\r\t\ttarget: SystemNavigation new\r\t\tselector: #browseAllSendersOf:\r\t\targument: self selector"},{"name":"trailer","linesOfCode":3,"sourceCode":"trailer\r\t\"Answer the receiver's trailer\"\r\t^ CompiledMethodTrailer new method: self"},{"name":"traitSource","linesOfCode":2,"sourceCode":"traitSource\r\t^ self propertyAt: #traitSource"},{"name":"implementors","linesOfCode":2,"sourceCode":"implementors\r\t^ SystemNavigation default allImplementorsOf: self selector"},{"name":"asPassiveRingDefinition","linesOfCode":11,"sourceCode":"asPassiveRingDefinition\r\t\"Retrieves a passive RGMethodDefinition object based on the data of the receiver.\r\tSource, protocol and stamp are retrieved from value assigned in creation\"\r\t\r\t^RGMethodDefinition new \r\t\t \tname: self selector;\r\t\t\tparentName: self methodClass name;\r\t\t\tisMetaSide: self methodClass isMeta;\r\t\t\tprotocol: self category;\r\t\t\tsourceCode: self sourceCode;\r\t\t\tstamp: self timeStamp;\r\t\t\tasPassive."},{"name":"firstComment","linesOfCode":3,"sourceCode":"firstComment\r\t\"Answer a string representing the first comment in the method associated with selector. Return an empty string if the method's source code does not contain a comment.\"\r\r\t^ self comments ifEmpty: [ #() ] ifNotEmpty: [ :comments | comments first ]"},{"name":"installLink:","linesOfCode":6,"sourceCode":"installLink: aMetaLink\r\tself reflectiveMethod ifNil: [ self createTwin ].\r\tself reflectiveMethod increaseLinkCount.\r\t(aMetaLink optionCompileOnLinkInstallation or: [ self isRealPrimitive ])\r\t\tifTrue: [ self reflectiveMethod compileAndInstallCompiledMethod ]\r\t\tifFalse: [ self invalidate ]"},{"name":"critiques","linesOfCode":7,"sourceCode":"critiques\r\t| critiques |\r\t\r\tcritiques := ReCriticEngine critiquesOf: self.\r\tcritiques :=\r\t\tcritiques,\r\t\t(ReCriticEngine nodeCritiquesOf: self).\r\t\r\t^ critiques"},{"name":"isDefinedInPackage:","linesOfCode":2,"sourceCode":"isDefinedInPackage: anRPackage\r\t^ anRPackage includesDefinedSelector: self selector ofClass: self methodClass"},{"name":"copyWithSource:","linesOfCode":2,"sourceCode":"copyWithSource: aString\r\t^self copyWithTrailerBytes: (CompiledMethodTrailer new sourceCode: aString) "},{"name":"tempNames","linesOfCode":3,"sourceCode":"tempNames\r\t\"on the level of the compiled method, tempNames includes argument names\"\r\t^self ast argumentNames, self ast temporaryNames"},{"name":"asActiveRingDefinition","linesOfCode":8,"sourceCode":"asActiveRingDefinition\r\t\"Retrieves an active RGMethodDefinition object based on the data of the receiver.\r\tSource, protocol and stamp are retrieved from the compiled method\"\r\t\r\t^ RGMethodDefinition new \r\t\t\tname: self selector;\r\t\t\tparentName: self methodClass name;\r\t\t\tisMetaSide: self methodClass isMeta;\r\t\t\tasActive.\r"},{"name":"isOverridden","linesOfCode":7,"sourceCode":"isOverridden\r\t| selector| \r\tselector := self selector.\r\tself methodClass allSubclassesDo: [:each | \r\t\t(each includesSelector: selector)\r\t\t\tifTrue: [ ^ true ]].\r\t^ false\r\t"},{"name":"sourcePointer","linesOfCode":4,"sourceCode":"sourcePointer\r\t\"Answer the integer which can be used to find the source file and position for this method.\r\tThe actual interpretation of this number is up to the SourceFileArray stored in the global variable SourceFiles.\"\r\r\t^ self trailer sourcePointer\r"},{"name":"temporaryVariables","linesOfCode":5,"sourceCode":"temporaryVariables\r\t\"on the level of compiledMethod, temps include the arguments\"\r\tself flag: #TODO. \"we need to revist temps vs args\"\r\t^(self sourceNode arguments collect: [ :each | each binding ]), \r\t\t(self sourceNode temporaries collect: [ :each | each binding ])"},{"name":"readsField:","linesOfCode":4,"sourceCode":"readsField: varIndex \r\t\"Answer whether the receiver loads the instance variable indexed by the argument.\"\r\tself isReturnField ifTrue: [^self returnField = (varIndex - 1)].\r\t^ super readsField: varIndex "},{"name":"spotterForMessagesFor:","linesOfCode":6,"sourceCode":"spotterForMessagesFor: aStep\r\t<spotterOrder: 12>\r\taStep listProcessor\r\t\t\ttitle: 'Messages';\r\t\t\tallCandidates: [ self messages asSortedCollection collect: [:each | GTSelector new name: each ] ];\r\t\t\tfilter: GTFilterSubstring"},{"name":"sizeWithoutTrailer","linesOfCode":2,"sourceCode":"sizeWithoutTrailer\r\t^ self trailer endPC"},{"name":"flushCache","linesOfCode":3,"sourceCode":"flushCache\r\t\"Tell the virtual machine to remove all references to this method from its method lookup caches, and to discard any optimized version \tof the method, if it has any of these.  This must be done whenever a method is modified in place, such as modifying its literals or \tmachine code, to reflect the revised code.  c.f. Behavior>>flushCache & Symbol>>flushCache.  Essential.\t See MethodDictionary class \tcomment.\"\r\r\t<primitive: 116>\r"},{"name":"cachePragmas","linesOfCode":2,"sourceCode":"cachePragmas\r\r\tself pragmas do: [ :pragma | pragma class addToCache: pragma ]"},{"name":"isExplicitlyRequired","linesOfCode":2,"sourceCode":"isExplicitlyRequired\r\t^ self isExplicitlyRequired: self markerOrNil"},{"name":"propertyValueAt:ifAbsent:","linesOfCode":6,"sourceCode":"propertyValueAt: propName ifAbsent: aBlock\r\t\"the is the old API, we unified the API over all structure (Classes, Methods, AST Nodes)\"\r\tself\r\t\tdeprecated: 'use #propertyAt:ifAbsent:'\r\t\ttransformWith: '`@receiver propertyValueAt: `@arg1 ifAbsent: `@arg2' -> '`@receiver propertyAt: `@arg1 ifAbsent: `@arg2'.\r\t^self propertyAt: propName ifAbsent: aBlock"},{"name":"copyWithTrailerBytes:","linesOfCode":15,"sourceCode":"copyWithTrailerBytes: trailer\r\"Testing:\r\t(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)\r\t\ttempNamesPut: 'copy end '\r\"\r\t| copy end start penultimateLiteral |\r\tstart := self initialPC.\r\tend := self endPC.\r\tcopy := trailer createMethod: end - start + 1 class: self class header: self header.\r\t1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].\r\t(penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue:\r\t\t[copy penultimateLiteral: (penultimateLiteral copy\r\t\t\t\t\t\t\t\t\tsetMethod: copy;\r\t\t\t\t\t\t\t\t\tyourself)].\r\tstart to: end do: [:i | copy at: i put: (self at: i)].\r\t^copy"},{"name":"hasMetaLinks","linesOfCode":3,"sourceCode":"hasMetaLinks\r\tself reflectiveMethod ifNil: [ ^false ].\r\t^self reflectiveMethod hasMetaLinks. "},{"name":"tagWith:","linesOfCode":7,"sourceCode":"tagWith: aSymbol\r\t\"Any method could be tagged with multiple symbols for user purpose. \r\tThis method should apply new tag. All existing tags should not be changed. \r\tBut now we could only implemented tags with protocols. \t\r\tSo tagging method with tag removes all existing tags and add new one. \r\tIt should not be problem with single tag scenario which are now defined by single protocol\"\r\t\r\tself protocol: aSymbol"},{"name":"isLiteralMethod","linesOfCode":2,"sourceCode":"isLiteralMethod\r\r\t^ self bytecode = self encoderClass literalMethodBytecodes"},{"name":"defaultSelector","linesOfCode":4,"sourceCode":"defaultSelector \r\t\"Invent and answer an appropriate message selector (a Symbol) for me, \r\tthat is, one that will parse with the correct number of arguments.\"\r\r\t^ #DoIt numArgs: self numArgs"},{"name":"markerOrNil","linesOfCode":2,"sourceCode":"markerOrNil\r\t^ self encoderClass markerOrNilFor: self"},{"name":"untagFrom:","linesOfCode":7,"sourceCode":"untagFrom: aSymbol\r\t\"Any method could be tagged with multiple symbols for user purpose. \r\tThis method should remove given tag from it. All other tags should not be changed. \r\tBut now we could implemented tags with protocols which allow only tag for method.\r\tAnd to remove tag from method we must change it protocol to Protocol unclassified\"\r\tself protocol = aSymbol ifTrue: [ \r\t\tself protocol: Protocol unclassified]"},{"name":"ir","linesOfCode":3,"sourceCode":"ir\r\t\"We as the AST for the IR... for decompiling ir from bytecode, look at IRBytecodeDecompiler\"\r\t^ self ast ir"},{"name":"method","linesOfCode":3,"sourceCode":"method\r\t\"polymorphic with closure\"\r\r\t^ self"},{"name":"variableWriteNodes","linesOfCode":2,"sourceCode":"variableWriteNodes\r\t^self ast variableWriteNodes"},{"name":"containsHalt","linesOfCode":2,"sourceCode":"containsHalt\r\r\t^ self hasProperty: #containsHalt"},{"name":"isDeprecated","linesOfCode":13,"sourceCode":"isDeprecated\r\t\"Object selectorsInProtocol: #deprecation\"\r\tself methodClass isDeprecated ifTrue: [ ^ true ].\r\r\t(self\r\t\tsendsAnySelectorOf:\r\t\t\t#(#deprecated: #deprecated:on:in: #deprecated:on:in:transformWith: #deprecated:transformWith:))\r\t\tifTrue: [ ^ true ].\r\t$-\r\t\tsplit: self protocol asString\r\t\tdo: [ :each | \r\t\t\teach withBlanksCondensed = 'deprecated'\r\t\t\t\tifTrue: [ ^ true ] ].\r\t^ false"},{"name":"localReadsSelf","linesOfCode":3,"sourceCode":"localReadsSelf\r\t\"methods that are compiled with FFI have a self in the source but not in the bytecode\"\r\t^self isFFIMethod or: [ super localReadsSelf ]"},{"name":"instanceVariableWriteNodes","linesOfCode":2,"sourceCode":"instanceVariableWriteNodes\r\t^self ast instanceVariableWriteNodes"},{"name":"setSourcePointer:","linesOfCode":14,"sourceCode":"setSourcePointer: srcPointer\r\t\"We can't change the trailer of existing method, since it could have completely different format. \t\r\tTherefore we need to generate a copy with new trailer, containing scrPointer, and then become it.\"\r\r\t| trailer copy |\r\ttrailer := CompiledMethodTrailer new sourcePointer: srcPointer.\r\tcopy := self copyWithTrailerBytes: trailer.\r\t\"If possible do a replace in place as an optimization\"\r\t(self trailer class == trailer class and: [ self size = copy size ])\r\t\tifTrue: [ \r\t\t\t| start |\r\t\t\tstart := self endPC + 1.\r\t\t\tself replaceFrom: start to: self size with: copy startingAt: start ]\r\t\tifFalse: [ self becomeForward: copy ].\r\t^ self\r"},{"name":"suitableRulesFrom:","linesOfCode":2,"sourceCode":"suitableRulesFrom: aReRuleManager \r\t^ aReRuleManager methodRules"},{"name":"tags","linesOfCode":9,"sourceCode":"tags\r\t\"Any method could be tagged with multiple symbols for user purpose. \r\tFor now we only define API to manage them implemented on top of method protocols.\r\tProtocol unclassified means that method is not tagged by anything\"\r\t| protocol |\r\tprotocol := self protocol.\r\tprotocol ifNil: [ ^#() ].\r\tprotocol = Protocol unclassified ifTrue: [ ^#() ].\r\t^{protocol}"},{"name":"variableNodes","linesOfCode":2,"sourceCode":"variableNodes\r\t^self ast variableNodes"},{"name":"hasPragmaNamed:","linesOfCode":2,"sourceCode":"hasPragmaNamed: aSymbol\r\t^ self pragmas anySatisfy: [ :pragma | pragma selector = aSymbol ]"},{"name":"mcWorkingCopy","linesOfCode":2,"sourceCode":"mcWorkingCopy\r\t MCWorkingCopy managersForClass: self methodClass selector: self selector do: [ :package | ^ package ]"},{"name":"isExtensionInPackage:","linesOfCode":2,"sourceCode":"isExtensionInPackage: anRPackage\r\t^ anRPackage includesExtensionSelector: self selector ofClass: self methodClass"},{"name":"isSubclassResponsibility:","linesOfCode":2,"sourceCode":"isSubclassResponsibility: marker\r\t^ marker == self class subclassResponsibilityMarker"},{"name":"removeProperty:ifAbsent:","linesOfCode":10,"sourceCode":"removeProperty: propName ifAbsent: aBlock\r\t\"Remove the property propName if it exists.\r\t Answer the evaluation of aBlock if the property is missing.\"\r\t| value |\r\tvalue := self propertyAt: propName ifAbsent: [^aBlock value].\r\tself penultimateLiteral: (self penultimateLiteral copyWithout:\r\t\t\t\t\t\t\t\t\t(Association\r\t\t\t\t\t\t\t\t\t\tkey: propName\r\t\t\t\t\t\t\t\t\t\tvalue: value)).\r\t^value"},{"name":"sendNodes","linesOfCode":2,"sourceCode":"sendNodes\r\t^self ast sendNodes"},{"name":"calypsoEnvironmentType","linesOfCode":2,"sourceCode":"calypsoEnvironmentType\r\t^ClyMethod"},{"name":"propertyAt:put:","linesOfCode":22,"sourceCode":"propertyAt: propName put: propValue\r\t\"Set or add the property with key propName and value propValue.\r\t If the receiver does not yet have a method properties create one and replace\r\t the selector with it.  Otherwise, either relace propValue in the method properties\r\t or replace method properties with one containing the new property.\"\r\t| propertiesOrSelector |\r\t(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:\r\t\t[self penultimateLiteral: ((self class methodPropertiesClass\r\t\t\t\t\t\t\t\t\tselector: propertiesOrSelector\r\t\t\t\t\t\t\t\t\twith: (Association\r\t\t\t\t\t\t\t\t\t\t\tkey: propName asSymbol\r\t\t\t\t\t\t\t\t\t\t\tvalue: propValue))\r\t\t\t\t\t\t\t\t\tsetMethod: self;\r\t\t\t\t\t\t\t\t\tyourself).\r\t\t^propValue].\r\t(propertiesOrSelector includesProperty: propName) ifTrue:\r\t\t[^propertiesOrSelector at: propName put: propValue].\r\tself penultimateLiteral: (propertiesOrSelector\r\t\t\t\t\t\t\t\tcopyWith: (Association\r\t\t\t\t\t\t\t\t\t\t\t\tkey: propName asSymbol\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: propValue)).\r\t^propValue"},{"name":"selector:","linesOfCode":11,"sourceCode":"selector: aSelector\r\t\"Set a method's selector.  This is either the penultimate literal,\r\t or, if the method has any properties or pragmas, the selector of\r\t the MethodProperties stored in the penultimate literal.\"\r\t| penultimateLiteral nl | \r\tSymbol internSelector:  aSelector.\r\t(penultimateLiteral := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [penultimateLiteral selector: aSelector]\r\t\tifFalse: [(nl := self numLiterals) < 2 ifTrue:\r\t\t\t\t\t[self error: 'insufficient literals to hold selector'].\r\t\t\t\tself literalAt: nl - 1 put: aSelector]"},{"name":"isReturnField","linesOfCode":3,"sourceCode":"isReturnField\r\t\"Answer whether the receiver is a quick return of an instance variable.\"\r\t^ self primitive between: 264 and: 519"},{"name":"getSourceFromFile","linesOfCode":5,"sourceCode":"getSourceFromFile\r\t\"PLEASE Note: clients should always call #sourceCode\"\r\t\"Read the source code from file, determining source file index and\r\tfile position from the last 3 bytes of this method.\"\r\r\t^ [ SourceFiles sourceCodeAt: self sourcePointer ] on: Error do: [ '' ]"},{"name":"isDisabled:","linesOfCode":2,"sourceCode":"isDisabled: marker\r\t^ marker == self class disabledMarker"},{"name":"usesUndeclareds","linesOfCode":6,"sourceCode":"usesUndeclareds\r\tself literalsDo: [:each | \r\t\t\t\teach class == UndeclaredVariable ifTrue: [^true].\r\t\t\t\t(each isBlock not and: [ \r\t\t\t\t\teach value isBehavior and: [ each value isObsolete ]]) ifTrue: [^true]].\r\t^false"},{"name":"getSourceReplacingSelectorWith:","linesOfCode":16,"sourceCode":"getSourceReplacingSelectorWith: newSelector\r\t| oldKeywords newKeywords source newSource oldSelector start |\r\tsource := self sourceCode.\r\t\r\tsource ifNil: [ ^ nil ].\r\t\r\toldSelector := self selector.\r\toldSelector = newSelector ifTrue: [ ^ source ].\r\t\r\toldKeywords := oldSelector keywords.\r\tnewKeywords := (newSelector ifNil: [self defaultSelector]) keywords.\r\t[oldKeywords size = newKeywords size] assert.\r\t\r\tnewSource := source.\r\tstart := 1.\r\toldKeywords with: newKeywords do: [:oldKey :newKey| |pos|\r\t\tpos := newSource findString: oldKey startingAt: start .\r\t\tnewSource := newSource copyReplaceFrom: pos to: (pos + oldKey size -1) with: newKey.\r\t\tstart := pos + newKey size ].\r\r\t^newSource"},{"name":"criticTheNonMetaclassClass","linesOfCode":3,"sourceCode":"criticTheNonMetaclassClass\r\t\"Return the class of the receiver for the critic browser. This behavior may be folded later by changing the name of this method or using another one.\"\r\t\r\t^ self methodClass instanceSide"},{"name":"reformat","linesOfCode":2,"sourceCode":"reformat\r\tself methodClass compile: self ast formattedCode classified:  self category."},{"name":"ensureRingDefinitionIn:","linesOfCode":10,"sourceCode":"ensureRingDefinitionIn: anRGEnvironment\r\r\t| parentModel |\r\t\r\tparentModel := (self methodClass ensureRingDefinitionIn: anRGEnvironment).\r\t\r\t^ parentModel methods \r\t\tdetect: [:each | each selector = self selector]\r\t\tifNone: [ \r\t\t\t| methodModel |\r\t\t\tmethodModel := self asRingMinimalDefinitionIn: anRGEnvironment.\r\t\t\tparentModel addLocalMethod: methodModel.\r\t\t\tmethodModel ]\t"},{"name":"sourceCode","linesOfCode":7,"sourceCode":"sourceCode\r\t\"Retrieve or reconstruct the source code for this method.\"\r\r\t| trailer |\r\ttrailer := self trailer.\r\ttrailer sourceCode ifNotNil: [:code | ^ code ].\r\ttrailer hasSourcePointer ifFalse: [ ^ self codeForNoSource ].\r\r\t^ self getSourceFromFile ifEmpty: [ self codeForNoSource ]"},{"name":"veryDeepCopyWith:","linesOfCode":2,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way.\""},{"name":"isFailedTest","linesOfCode":4,"sourceCode":"isFailedTest\r\t\"Is the receiver a test method that failed?\"\r\r\t^ self methodClass isTestCase\r\t\tand: [ self methodClass methodFailed: self selector ]"},{"name":"basicAsMCMethodDefinition","linesOfCode":9,"sourceCode":"basicAsMCMethodDefinition\r\r\t\"Creates a MCMethodDefinition from the receiver\"\r\r\t^ MCMethodDefinition\r\t\t  className: self methodClass instanceSide name\r\t\t  classIsMeta: self methodClass isClassSide\r\t\t  selector: self selector\r\t\t  category: self protocol\r\t\t  timeStamp: self stamp\r\t\t  source: self sourceCode"},{"name":"realClass","linesOfCode":3,"sourceCode":"realClass\r\t\"answer the class that I am installed in\"\r\t\r\t^ self methodClass"},{"name":"putSource:withPreamble:","linesOfCode":12,"sourceCode":"putSource: source withPreamble: preambleBlock\r\t\"Store the source code for the receiver on an external file.\"\r\r\tSourceFiles \r\t\twriteSource: source \r\t\tpreamble: (String streamContents: preambleBlock)\r\t\tonSuccess: [ :newSourcePointer :theChangesFileStream |\r\t\t\t\"Method chunk needs a final ! !\"\r\t\t\t(SourceChunkWriteStream on: theChangesFileStream) nextPut: ' '.\r\t\t\t\"Update with new source pointer\"\r\t\t\tself setSourcePointer: newSourcePointer ]\r\t\tonFail: [ \r\t\t\tself becomeForward: (self copyWithSource: source) ]\r"},{"name":"category","linesOfCode":3,"sourceCode":"category\r\t\"Please favor protocol instead of category. We want to have method protocol and class package and tag = a category\"\r\t^ self methodClass organization categoryOfElement: self selector"},{"name":"hasProperties","linesOfCode":2,"sourceCode":"hasProperties\r\t^ self penultimateLiteral isMethodProperties"},{"name":"name","linesOfCode":2,"sourceCode":"name\r\t^ self printString"},{"name":"comments","linesOfCode":3,"sourceCode":"comments\r\t\"Answer a collection of strings representing the comments in the method. Return an empty collection if the method's source code does not contain a comment.\"\r\r\t^ self ast allComments collect: [:c| c contents]"},{"name":"isRequired:","linesOfCode":5,"sourceCode":"isRequired: marker\r\tmarker ifNil: [^ false].\r\t(self isExplicitlyRequired: marker) ifTrue: [^ true]. \r\t(self isSubclassResponsibility: marker) ifTrue: [^ true]. \r\t^ false"},{"name":"lookupVar:","linesOfCode":2,"sourceCode":"lookupVar: aString \r\t^self ast scope lookupVar: aString"},{"name":"isShortcutDeclaration","linesOfCode":2,"sourceCode":"isShortcutDeclaration\r\t^ self pragmas anySatisfy: [ :p | p selector = #shortcut ]"},{"name":"classBinding:","linesOfCode":3,"sourceCode":"classBinding: aBinding\r       \"sets the association to the class that I am installed in\"\r       ^self literalAt: self numLiterals put: aBinding."},{"name":"linesOfCode","linesOfCode":8,"sourceCode":"linesOfCode\r\t\"An approximate measure of lines of code.\r\tIncludes method's name and comments, but excludes empty lines.\"\r\t| lines |\r\tlines := 0.\r\tself sourceCode lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tendWithoutDelimiters > start ifTrue: [lines := lines+1]].\r\t^lines"},{"name":"browse","linesOfCode":2,"sourceCode":"browse\r\r\t^ Smalltalk tools browser openOnClass: self methodClass selector: self selector"},{"name":"hasBreakpoint","linesOfCode":2,"sourceCode":"hasBreakpoint\r\t^ Breakpoint isInstalledIn: self\r\t\r\t"},{"name":"inpectionIr","linesOfCode":5,"sourceCode":"inpectionIr\r\t<inspectorPresentationOrder: 35 title: 'IR'>\r\r\t^ SpTextPresenter new \r\t\ttext: (self ir longPrintString trimmed);\r\t\tyourself\r"},{"name":"classBinding","linesOfCode":3,"sourceCode":"classBinding\r\t\"answer the association to the class that I am installed in, or nil if none.\"\r\t^self literalAt: self numLiterals"},{"name":"ast","linesOfCode":3,"sourceCode":"ast\r\t\"return an AST for this method. The AST is cached. see class comment of ASTCache\"\r\t^ ASTCache at: self"},{"name":"isDoIt","linesOfCode":2,"sourceCode":"isDoIt\r\t^self selector isDoIt."},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream \r\t\"Overrides method inherited from the byte arrayed collection.\"\r\r\taStream print: self methodClass; nextPutAll: '>>'; print: self selector."},{"name":"valueWithReceiver:arguments:","linesOfCode":4,"sourceCode":"valueWithReceiver: aReceiver arguments: anArray \r\t\"This should be changed when all the VM will support passign of extra arguments\r\t\t^self receiver: aReceiver withArguments: anArray executeMethod: self\"\r\t\r\t^ aReceiver withArgs: anArray executeMethod: self"},{"name":"spotterActDefault","linesOfCode":2,"sourceCode":"spotterActDefault\r\t^ self browse"},{"name":"isProvided:","linesOfCode":3,"sourceCode":"isProvided: marker\r\tmarker ifNil: [^ true].\r\t^ (self isRequired: marker) not and: [(self isDisabled: marker) not]"},{"name":"getPreambleFrom:at:","linesOfCode":2,"sourceCode":"getPreambleFrom: aFileStream at: position\r\t^ SourceFiles getPreambleFrom: aFileStream at: position"},{"name":"propertyValueAt:","linesOfCode":6,"sourceCode":"propertyValueAt: propName\r\r\t\"the is the old API, we unified the API over all structure (Classes, Methods, AST Nodes)\"\r\r\tself\r\t\tdeprecated: 'use #propertyAt:'\r\t\ttransformWith: '`@receiver propertyValueAt: `@arg' -> '`@receiver propertyAt: `@arg'.\r\t^ self propertyAt: propName"},{"name":"isTaggedWith:","linesOfCode":3,"sourceCode":"isTaggedWith: aSymbol\r\t\"Not methods tags implemented by protocols. Look #tags comment\"\r\t^self protocol == aSymbol"},{"name":"banChecksForValidation","linesOfCode":3,"sourceCode":"banChecksForValidation\r\"returns ban levels that have to be checked before validation\"\r\r\t^ { self . self methodClass }\r"},{"name":"asResultForDrTest","linesOfCode":2,"sourceCode":"asResultForDrTest\r\r\t^ DTTestLeaf content: self"},{"name":"senders","linesOfCode":2,"sourceCode":"senders\r\t^ SystemNavigation default allSendersOf: self selector"},{"name":"drTestsBrowse","linesOfCode":2,"sourceCode":"drTestsBrowse\r\r\tSmalltalk tools browser openOnClass: self methodClass selector: self selector"},{"name":"spotterMethodClassFor:","linesOfCode":7,"sourceCode":"spotterMethodClassFor: aStep\r\t<spotterOrder: 50>\r\taStep listProcessor\r\t\t\tallCandidates: [  {self methodClass }];\r\t\t\ttitle: 'Class';\r\t\t\tfilter: GTFilterSubstring;\r\t\t\titemIcon: #systemIcon"},{"name":"properties:","linesOfCode":8,"sourceCode":"properties: aMethodProperties\r\t\"Set the method-properties of the receiver to aMethodProperties.\"\r\tself literalAt: self numLiterals - 1\r\t\tput: (aMethodProperties isEmpty\r\t\t\t\tifTrue: [aMethodProperties selector]\r\t\t\t\tifFalse: [aMethodProperties\r\t\t\t\t\t\t\tsetMethod: self;\r\t\t\t\t\t\t\tyourself])"},{"name":"isDisabled","linesOfCode":2,"sourceCode":"isDisabled\r\t^ self isDisabled: self markerOrNil"},{"name":"isFFIMethod","linesOfCode":2,"sourceCode":"isFFIMethod\r\t\r\t^ self hasProperty: #isFFIMethod"},{"name":"hasProperty:","linesOfCode":5,"sourceCode":"hasProperty: aKey\r\r\t| extendedMethodState |\r\t^ (extendedMethodState := self penultimateLiteral) isMethodProperties\r\t\t  ifTrue: [  extendedMethodState includesProperty: aKey ]\r\t\t  ifFalse: [ false ]"},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\r\t^self methodClass notNil and: [self isDoIt not]"},{"name":"propertyAt:ifAbsentPut:","linesOfCode":3,"sourceCode":"propertyAt: aKey ifAbsentPut: aBlock\r\t\"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value.\"\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]"},{"name":"isExtension","linesOfCode":2,"sourceCode":"isExtension\r\t^ self origin package ~= self package"},{"name":"endPC","linesOfCode":3,"sourceCode":"endPC\r\t\"Answer the index of the last bytecode, as the trailer size varies we have to delegate\"\r\t^ self trailer endPC"},{"name":"isEqualRegardlessTrailerTo:","linesOfCode":2,"sourceCode":"isEqualRegardlessTrailerTo: aCompiledMethod\r\t^ (self copyWithTrailerBytes: CompiledMethodTrailer empty) = (aCompiledMethod copyWithTrailerBytes: CompiledMethodTrailer empty)"},{"name":"phlowValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"phlowValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject withArgs: aCollection executeMethod: self"},{"name":"hasLinks","linesOfCode":5,"sourceCode":"hasLinks\r\tself \r\t\tdeprecated: 'use #hasMetaLinks'\r\t\ttransformWith:  '`@receiver hasLinks' -> '`@receiver hasMetaLinks'.\r\t^self hasMetaLinks"},{"name":"isReturnSpecial","linesOfCode":3,"sourceCode":"isReturnSpecial\r\t\"Answer whether the receiver is a quick return of self or constant.\"\r\r\t^ self primitive between: 256 and: 263"},{"name":"link:toVariableNamed:option:","linesOfCode":6,"sourceCode":"link: aMetaLink toVariableNamed: vName option: accessStrategy\r\t^aMetaLink\r\t\tinstallOnVariable: (self lookupVar: vName)\r\t\tfor: self methodClass\r\t\toption: accessStrategy\r\t\tinstanceSpecific: false"},{"name":"assignmentNodes","linesOfCode":2,"sourceCode":"assignmentNodes\r\t^self ast assignmentNodes"},{"name":"hasPragma","linesOfCode":2,"sourceCode":"hasPragma\r\t^ self hasProperties and: [self pragmas isNotEmpty]"},{"name":"asHistoricalRingDefinition","linesOfCode":16,"sourceCode":"asHistoricalRingDefinition\r\r\t\"Retrieves a historical RGMethodDefinition object based on the data of the receiver.\r\tSource, protocol and stamp are retrieved from the source file method\"\r\t| ring |\r\tring := (RGMethodDefinition named: self selector)\r\t\t\t\tparentName: self methodClass name;\r\t\t\t\tisMetaSide: self methodClass isMeta.\r\r\tself sourcePointer isZero\r\t\tifTrue: [ \"this should not happen but sometimes the system looks corrupted\"\r\t\t\tring protocol: self category;\r\t\t\t\tsourceCode: self sourceCode;\r\t\t\t\tstamp: self timeStamp ]\r\t\tifFalse: [ \r\t\t\tring sourcePointer: self sourcePointer ].\r\tring asHistorical.\t\r\t\r\t^ ring"},{"name":"pragmaAt:","linesOfCode":3,"sourceCode":"pragmaAt: aKey\r\t\"Answer the first pragma with selector aKey, or nil if none.\"\r\t^ self pragmas detect: [ :pragma | pragma selector == aKey ] ifNone: nil"},{"name":"decompile","linesOfCode":6,"sourceCode":"decompile\r\t^Smalltalk globals \r\t\tat: #FBDDecompiler\r\t\tifPresent: [ :decompiler | decompiler new  decompile: self]  \r\t\tifAbsent: [ RBParser parseMethod: self selector asMethodPreamble, '\r\tself noSourceAvailable' ]"},{"name":"fuelPrepare","linesOfCode":4,"sourceCode":"fuelPrepare\r\t\"Prepare for Fuel serialization.\"\r\t\r\tself isNamedPrimitive ifTrue: [self literals first at: 4 put: 0].\r\t\r\t\"When the method is a named primitive, the first literal is an array that works as an argument for the VM. The first and second elements represent the module and the name of the primivite. The third element of the array is ignored, it used to be a session ID. The forth element is the primitive index in a externalPrimitiveTable and it is IMPORTANT to put it in zero, otherwise there can be errors. Putting a zero means that the VM will not try to directly execute the primitive from the table and it will always try to load the module. It is the safer thing to do. For more details, read the method #primitiveExternalCall in VMMaker.\""},{"name":"variableReadNodes","linesOfCode":2,"sourceCode":"variableReadNodes\r\t^self ast variableReadNodes"},{"name":"superMessages","linesOfCode":2,"sourceCode":"superMessages\r\t^self ast superMessages "},{"name":"spotterPreviewIn:","linesOfCode":10,"sourceCode":"spotterPreviewIn: aComposite\r\t<spotterPreview: 10>\r\taComposite pharoMethod\r\t\ttitle: [ self gtDisplayString ];\r\t\tdisplay: [:compiledMethod | \r\t\t\t' ', compiledMethod sourceCode];\r\t\tsmalltalkClass: [self methodClass];\r\t\tentity: self.\r\t\t\r\tself flag: 'move \"entity: self\" somewhere else, maybe'"},{"name":"instanceVariableReadNodes","linesOfCode":2,"sourceCode":"instanceVariableReadNodes\r\t^self ast instanceVariableReadNodes"},{"name":"spotterForSendersFor:","linesOfCode":7,"sourceCode":"spotterForSendersFor: aStep\r\t<spotterOrder: 11>\r\taStep listProcessor\r\t\t\ttitle: 'Senders';\r\t\t\tallCandidates: [ self senders collect: [:each | each compiledMethod] ];\r\t\t\tfilter: GTFilterSubstring;\r\t\t\tkeyBinding: $n command"},{"name":"isAbstract","linesOfCode":6,"sourceCode":"isAbstract\r\t\"Answer true if I am abstract\"\r\t\r\t| marker |\r\tmarker := self markerOrNil ifNil: [^false].\r\t\r\t^marker == self class subclassResponsibilityMarker \r\t\tor: [ marker == self class explicitRequirementMarker ]\r"},{"name":"propertyKeysAndValuesDo:","linesOfCode":5,"sourceCode":"propertyKeysAndValuesDo: aBlock\r\t\"Enumerate the receiver with all the keys and values.\"\r\r\t| propertiesOrSelector |\r\t(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue:\r\t\t[propertiesOrSelector propertyKeysAndValuesDo: aBlock]"},{"name":"asEpiceaRingDefinition","linesOfCode":9,"sourceCode":"asEpiceaRingDefinition\r\r\t^ (RGMethodDefinition named: self selector)\r\t\tparentName: self methodClass name;\r\t\tisMetaSide: self methodClass isMeta;\r\t\tprotocol: self category;\r\t\tsourceCode: self sourceCode;\r\t\tstamp: self timeStamp;\r\t\tpackage: (self package ifNotNil: [:package | package name]);\r\t\tyourself.\r"},{"name":"ffiArgumentNames","linesOfCode":7,"sourceCode":"ffiArgumentNames\r\t\"Answer the method's argument names. We using a separate method, \r\tto get arg names not from source code directly, but from method properties, collected at\r\tcompile time. Useful, when there is no source code available (for some reason)\"\r\r\t^ self\r\t\t  propertyAt: #ffiArgumentNames\r\t\t  ifAbsent: [ self propertyAt: #ffiArgumentNames put: self argumentNames ]"},{"name":"selector","linesOfCode":8,"sourceCode":"selector\r\t\"Answer a method's selector.  This is either the penultimate literal,\r\t or, if the method has any properties or pragmas, the selector of\r\t the MethodProperties stored in the penultimate literal.\"\r\t| penultimateLiteral | \r\t^(penultimateLiteral := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [penultimateLiteral selector]\r\t\tifFalse: [penultimateLiteral]"},{"name":"isOverriding","linesOfCode":2,"sourceCode":"isOverriding\r\r\t^(self origin superclass ifNotNil: [ :c | c lookupSelector: self selector]) notNil"},{"name":"isProvided","linesOfCode":2,"sourceCode":"isProvided\r\t^ self isProvided: self markerOrNil"},{"name":"isErrorTest","linesOfCode":4,"sourceCode":"isErrorTest\r\t\"Is the receiver a test method that raised an error?\"\r\r\t^ self methodClass isTestCase\r\t\tand: [ self methodClass methodRaisedError: self selector ]"},{"name":"fileOut","linesOfCode":2,"sourceCode":"fileOut\r\r\t^self origin fileOutMethod: self selector"},{"name":"isPassedTest","linesOfCode":4,"sourceCode":"isPassedTest\r\t\"Is the receiver a test method that passed?\"\r\r\t^ self methodClass isTestCase\r\t\tand: [ self methodClass methodPassed: self selector ]"},{"name":"isFromTrait","linesOfCode":3,"sourceCode":"isFromTrait\r\t\"Return true for methods that have been included from Traits\"\r\t^ self origin isTrait and: [ self origin ~= self methodClass ]"},{"name":"overriddenMethods","linesOfCode":7,"sourceCode":"overriddenMethods\r\t\"all the methods of my superclasses that are overriden by me\"\r\t| selector |\r\tselector := self selector.\r\t^ self methodClass allSuperclasses\r\t\tselect: [ :class | class includesSelector: selector ]\r\t\tthenCollect: [ :class | class compiledMethodAt: selector ]"},{"name":"stepIntoQuickMethods:","linesOfCode":2,"sourceCode":"stepIntoQuickMethods: aBoolean\r\t^self propertyAt: #stepIntoQuickMethod put: aBoolean"},{"name":"propertyAt:","linesOfCode":5,"sourceCode":"propertyAt: propName\r\t| propertiesOrSelector |\r\t^(propertiesOrSelector := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [propertiesOrSelector propertyAt: propName ifAbsent: [nil]]\r\t\tifFalse: [nil]"},{"name":"spotterSelectFor:","linesOfCode":2,"sourceCode":"spotterSelectFor: aStep\r\t\" ignore :) \""},{"name":"isRequired","linesOfCode":3,"sourceCode":"isRequired\r\t\"A method is required if it is a method declaring a subclass responsibility or an explicit requirement. This mean the method needs to be overriden (in case of subclass reponsibility) or implemented (in case of explicit requirement).\"\r\r\t^ self isRequired: self markerOrNil"},{"name":"hasComment","linesOfCode":3,"sourceCode":"hasComment\r\t\"check if this method has a method comment\"\r\t^self comment isEmptyOrNil not"},{"name":"removeLink:","linesOfCode":2,"sourceCode":"removeLink: aLink\r\r\tself reflectiveMethod ifNotNil: [:rm | rm removeLink: aLink]."},{"name":"hasSourceCode","linesOfCode":12,"sourceCode":"hasSourceCode\r\r\t\"Retrieve or reconstruct the source code for this method.\"\r\t| trailer source |\r\ttrailer := self trailer.\r\ttrailer sourceCode ifNotNil: [:code | ^ true ].\r\ttrailer hasSourcePointer ifFalse: [^ false].\r\r\t\"Situation normal;  read the sourceCode from the file\"\r\tsource := [self getSourceFromFile]\r\t\t\t\ton: Error\r\t\t\t\tdo: [ :ex | ex return: nil].\r\tsource isEmptyOrNil ifTrue: [^ false].\t\t\t\r\t^ true"},{"name":"printPrimitiveOn:","linesOfCode":21,"sourceCode":"printPrimitiveOn: aStream\r\t\"Print the primitive on aStream\"\r\t| primDecl |\r\tself isPrimitive ifFalse: [ ^self ].\r\r\tself isExternalCallPrimitive ifTrue:\r\t\t[^aStream print: (self literalAt: 1); cr].\r\taStream nextPutAll: '<primitive: '.\r\tself isNamedPrimitive\r\t\tifTrue:\r\t\t\t[primDecl := self literalAt: 1.\r\t\t\t (primDecl at: 2) asString printOn: aStream.\r\t\t\t (primDecl at: 1) ifNotNil:\r\t\t\t\t[:moduleName|\r\t\t\t\taStream nextPutAll:' module: '.\r\t\t\t\tmoduleName asString printOn: aStream]]\r\t\tifFalse:\r\t\t\t[aStream print: self primitive].\r\tself primitiveErrorVariableName ifNotNil:\r\t\t[:primitiveErrorVariableName|\r\t\t aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].\r\taStream nextPut: $>; cr"},{"name":"properties","linesOfCode":6,"sourceCode":"properties\r\t\"Answer the method properties of the receiver.\"\r\t| propertiesOrSelector |\r\t^(propertiesOrSelector := self penultimateLiteral) isMethodProperties\r\t\tifTrue: [propertiesOrSelector]\r\t\tifFalse: [self class methodPropertiesClass forMethod: self selector: propertiesOrSelector]"},{"name":"codeForNoSource","linesOfCode":5,"sourceCode":"codeForNoSource\r\t\"if everything fails, decompile the bytecode\"\r\t\"If there is no compiler, we cannot decompile it\"\t\r\tSmalltalk hasCompiler ifFalse: [ ^ nil ].\r\t\r\t ^(self compiler decompileMethod: self) formattedCode"},{"name":"newBreakpointForVariable:","linesOfCode":8,"sourceCode":"newBreakpointForVariable: aVariableName\r\t^ (self tempNames includes: aVariableName)\r\t\tifTrue: [ VariableBreakpoint\r\t\t\t\tnewBreakpointForVariable: aVariableName\r\t\t\t\tforMethod: self ]\r\t\tifFalse: [ VariableBreakpoint\r\t\t\t\tnewBreakpointForVariable: aVariableName\r\t\t\t\tinClass: self methodClass ]"},{"name":"protocol","linesOfCode":3,"sourceCode":"protocol\r\t\"Return in which protocol (conceptual groups of methods) the receiver is grouped into.\"\r\r\t^ self category"},{"name":"embeddSourceInTrailer","linesOfCode":8,"sourceCode":"embeddSourceInTrailer\r\t\"When receiver is deinstalled from its class, its not managed anymore by development tools\r\tand it's hard to predict, how long a method could stay in the image, because if it contains blocks,\r\tthey could still reference it. \r\tTherefore we trying to preserve as much as we can , actually by embedding the method's source code into its trailer\r\t\"\r\tself trailer hasSourcePointer ifTrue: [\r\t\t^self becomeForward: (self copyWithSource: self sourceCode)]\r"},{"name":"brickValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"brickValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject withArgs: aCollection executeMethod: self"},{"name":"isInstalled","linesOfCode":7,"sourceCode":"isInstalled\r\tself methodClass ifNotNil:\r\t\t[:class|\r\t\tself selector ifNotNil:\r\t\t\t[:selector|\r\t\t\t^self == (class compiledMethodAt: selector ifAbsent: nil)]].\r\t^false"},{"name":"primitive","linesOfCode":7,"sourceCode":"primitive\r\t\"Answer the primitive index associated with the receiver.\r\t Zero indicates that this is not a primitive method.\"\r\t| initialPC |\r\t^(self header anyMask: 65536) \"Is the hasPrimitive? flag set?\"\r\t\tifTrue: [(self at: (initialPC := self initialPC) + 1) + ((self at: initialPC + 2) bitShift: 8)]\r\t\tifFalse: [0]"},{"name":"referencedClasses","linesOfCode":11,"sourceCode":"referencedClasses\r\r\t\"Return classes that are directly referenced by this method. \r\tWe only take globals into account, class vars are skipped.\r\tIt traverses all the compiled methods to get the classes\"\r\r\t| result |\r\tresult := IdentitySet new.\r\tself withAllNestedLiteralsDo: [ :each | \r\t\t(each isVariableBinding and: [ \r\t\t\t each isGlobalVariable and: [ each read isClass ] ]) ifTrue: [ \r\t\t\tresult add: each value ] ].\r\t^ result"},{"name":"propertyValueAt:put:","linesOfCode":6,"sourceCode":"propertyValueAt: propName put: propValue\r\t\"the is the old API, we unified the API over all structure (Classes, Methods, AST Nodes)\"\r\tself\r\t\tdeprecated: 'use #propertyAt:put:'\r\t\ttransformWith: '`@receiver propertyValueAt: `@arg1 put: `@arg2' -> '`@receiver propertyAt: `@arg1 put: `@arg2'.\r\t^self propertyAt: propName put: propValue"},{"name":"irPrimitive","linesOfCode":6,"sourceCode":"irPrimitive\r\r\t| primNode n |\r\tprimNode := IRPrimitive new num: (n := self primitive).\r\t(n = 117 or: [n = 120]) ifTrue: [\r\t\tprimNode spec: (self literalAt: 1)].\r\t^ primNode"},{"name":"methodNode","linesOfCode":3,"sourceCode":"methodNode\r\t\"returns an AST for this method, do not cache it. (see #ast for the cached alternative)\"\r\t^self parseTree"},{"name":"isConflict","linesOfCode":2,"sourceCode":"isConflict\r\t^ self markerOrNil == self class conflictMarker"},{"name":"isBinarySelector","linesOfCode":3,"sourceCode":"isBinarySelector\r\t^self selector\r\t\tallSatisfy: [:each | each isSpecial]"},{"name":"removeProperty:","linesOfCode":10,"sourceCode":"removeProperty: propName\r\t\"Remove the property propName if it exists.\r\t Do _not_ raise an error if the property is missing.\"\r\t| value |\r\tvalue := self propertyAt: propName ifAbsent: [^nil].\r\tself penultimateLiteral: (self penultimateLiteral copyWithout:\r\t\t\t\t\t\t\t\t\t(Association\r\t\t\t\t\t\t\t\t\t\tkey: propName\r\t\t\t\t\t\t\t\t\t\tvalue: value)).\r\t^value"},{"name":"criticClass","linesOfCode":3,"sourceCode":"criticClass\r\t\"Return the class of the receiver for the critic browser. This behavior may be folded later by changing the name of this method or using another one.\"\r\t\r\t^ self methodClass"},{"name":"postCopy","linesOfCode":8,"sourceCode":"postCopy\r\t| penultimateLiteral |\r\t(penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue:\r\t\t[self penultimateLiteral: (penultimateLiteral copy\r\t\t\t\t\t\t\t\t\tmethod: self;\r\t\t\t\t\t\t\t\t\tyourself).\r\t\t self penultimateLiteral pragmas do:\r\t\t\t[:p| p method: self]]\r"},{"name":"parseTree","linesOfCode":9,"sourceCode":"parseTree\r\t\"returns an AST for this method, do not cache it. (see #ast for the cached alternative)\"\r\t| ast |\r\tast := self methodClass compiler \r\t\tsource: self sourceCode;\r\t\tfailBlock: [^ self decompile ];\r\t\tparse.\r\tast compilationContext compiledMethod: self.\r\t^ast"},{"name":"gtDisplayOn:","linesOfCode":2,"sourceCode":"gtDisplayOn: aStream\r\taStream print: self methodClass; nextPutAll: '>>'; store: self selector."},{"name":"sameAsMCDefinition:","linesOfCode":12,"sourceCode":"sameAsMCDefinition: anMCMethodDefinition\r\t^ anMCMethodDefinition selector = self selector\r\t\tand:\r\t\t\t[ \r\t\t\tanMCMethodDefinition className = self className\r\t\t\t\tand:\r\t\t\t\t\t[ \r\t\t\t\t\tanMCMethodDefinition classIsMeta = self methodClass isClassSide\r\t\t\t\t\t\tand:\r\t\t\t\t\t\t\t[ \r\t\t\t\t\t\t\tanMCMethodDefinition category = self protocol\r\t\t\t\t\t\t\t\tand: [ anMCMethodDefinition source = self sourceCode ] ] ] ]"},{"name":"penultimateLiteral","linesOfCode":7,"sourceCode":"penultimateLiteral\r\t\"Answer the penultimate literal of the receiver, which holds either\r\t the receiver's selector or its properties (which will hold the selector).\"\r\t| pIndex |\r\t^(pIndex := self numLiterals - 1) > 0 \r\t\tifTrue: [self literalAt: pIndex]\r\t\tifFalse: [nil]"},{"name":"decompileIR","linesOfCode":2,"sourceCode":"decompileIR\r\t\r\t^ IRBytecodeDecompiler new decompile: self"},{"name":"reflectiveMethod:","linesOfCode":2,"sourceCode":"reflectiveMethod: aReflectiveMethod\r\tself propertyAt: #reflectiveMethod put: aReflectiveMethod"},{"name":"pharoDocCommentNodes","linesOfCode":5,"sourceCode":"pharoDocCommentNodes\r\t\"we try to avoid to have to create the AST if we are sure that we do not need it\"\r\t^ (self sourceCode includesSubstring: '>>>')\r\t\t  ifTrue: [ self ast pharoDocCommentNodes ]\r\t\t  ifFalse: [ ^ #(  ) ]"},{"name":"reBanName","linesOfCode":2,"sourceCode":"reBanName\r\r\t^ self name, ' (Method)'"},{"name":"temporaryVariableNamed:","linesOfCode":3,"sourceCode":"temporaryVariableNamed: aName\r\t(self hasTemporaryVariableNamed: aName) ifFalse: [ ^nil ].\r\t^self sourceNode scope lookupVar: aName\r\r"},{"name":"methodClass:","linesOfCode":4,"sourceCode":"methodClass: aClass\r\t\"set the class binding in the last literal to aClass\"\r\t^self numLiterals > 0\r\t\tifTrue: [ self literalAt: self numLiterals put: aClass binding ]\t"},{"name":"removeFromSystem","linesOfCode":2,"sourceCode":"removeFromSystem\r\t^ self methodClass removeSelector: self selector"},{"name":"hasSourcePointer","linesOfCode":2,"sourceCode":"hasSourcePointer\r\t^ self trailer hasSourcePointer"},{"name":"reflectivityDisabled","linesOfCode":2,"sourceCode":"reflectivityDisabled\r\t^self hasPragmaNamed: #disableReflectivity"},{"name":"manifestBuilderForRuleChecker:","linesOfCode":3,"sourceCode":"manifestBuilderForRuleChecker: aRuleChecker\r\t\"Return the manifestsince the rulechecker is keeping a cache, we ask it back\"\r\r\t^ aRuleChecker manifestBuilderOfMethod: self"},{"name":"classIsMeta","linesOfCode":5,"sourceCode":"classIsMeta\r\tself \r\t\tdeprecated: 'use methodClass isClassSide'\r\t\ttransformWith:  '`@receiver classIsMeta' -> '`@receiver methodClass isClassSide'.\r\t^self methodClass isClassSide"},{"name":"isTestMethod","linesOfCode":2,"sourceCode":"isTestMethod\r\r\t^ self methodClass isTestCase and: [ self selector isTestSelector ]"},{"name":"penultimateLiteral:","linesOfCode":7,"sourceCode":"penultimateLiteral: anObject\r\t\"Answer the penultimate literal of the receiver, which holds either\r\t the receiver's selector or its properties (which will hold the selector).\"\r\t| pIndex |\r\t(pIndex := self numLiterals - 1) > 0 \r\t\tifTrue: [self literalAt: pIndex put: anObject]\r\t\tifFalse: [self error: 'insufficient literals']"},{"name":"compiledMethod","linesOfCode":2,"sourceCode":"compiledMethod\r\t^self"}],"meta":{"name":"CompiledMethod class","instanceVariables":[],"methods":[{"name":"methodPropertiesClass","linesOfCode":6,"sourceCode":"methodPropertiesClass\r\t\"Answer the class to use to create a method's properties, which can be a poor man's way\r\t to add instance variables to subclassses of CompiledMethod.  Subclasses of CompiledMethod\r\t should define a corresponding subclass of AdditionalMethodState that adds any instance variables\r\t required, and override this method to answer that class.\"\r\t^AdditionalMethodState"},{"name":"explicitRequirementMarker","linesOfCode":2,"sourceCode":"explicitRequirementMarker\r\t^ #explicitRequirement"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCompiledMethodInspector"},{"name":"basicNew:","linesOfCode":2,"sourceCode":"basicNew: size\r\r\tself error: 'CompiledMethods may only be created with newMethod:header:' "},{"name":"basicNew","linesOfCode":2,"sourceCode":"basicNew\r\r\tself error: 'CompiledMethods may only be created with newMethod:header:' "},{"name":"headerFlagForEncoder:","linesOfCode":4,"sourceCode":"headerFlagForEncoder: anEncoderClass\r\tanEncoderClass == PrimaryBytecodeSetEncoderClass ifTrue: [ ^ 0 ].\r\tanEncoderClass == SecondaryBytecodeSetEncoderClass ifTrue: [ ^ SmallInteger minVal ].\r\tself error: 'The encoder is not one of the two installed bytecode sets'"},{"name":"primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:","linesOfCode":17,"sourceCode":"primitive: primNum numArgs: numArgs numTemps: numTemps stackSize: stackSize literals: literals bytecodes: bytecodes trailer: trailerBytes\r\t\"Create method with given attributes.  numTemps includes numArgs.  stackSize does not include numTemps.\"\r\r\t| compiledMethod |\r\tcompiledMethod := self\r\t\tnewBytes: bytecodes size\r\t\ttrailerBytes: trailerBytes \r\t\tnArgs: numArgs\r\t\tnTemps: numTemps\r\t\tnStack: 0\r\t\tnLits: literals size\r\t\tprimitive: primNum.\r\t(WriteStream with: compiledMethod)\r\t\tposition: compiledMethod initialPC - 1;\r\t\tnextPutAll: bytecodes.\r\tliterals withIndexDo: [:obj :i | compiledMethod literalAt: i put: obj].\r\tcompiledMethod needsFrameSize: stackSize.\r\t^ compiledMethod"},{"name":"smallFrameSize","linesOfCode":2,"sourceCode":"smallFrameSize\r\r\t^ SmallFrame"},{"name":"newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:flag:","linesOfCode":26,"sourceCode":"newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag\r\t\"Answer an instance of me. The header is specified by the message \r\t arguments. The remaining parts are not as yet determined.\"\r\t| method pc |\r\tnArgs > 15 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many arguments'].\r\tnTemps > 63 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many temporary variables'].\t\r\tnLits > 65535 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many literals'].\r\r\tmethod := trailer\r\t\t\t\tcreateMethod: numberOfBytes\r\t\t\t\tclass: self\r\t\t\t\theader:    (nArgs bitShift: 24)\r\t\t\t\t\t\t+ (nTemps bitShift: 18)\r\t\t\t\t\t\t+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])\r\t\t\t\t\t\t+ nLits\r\t\t\t\t\t\t+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])\r\t\t\t\t\t\t+ (flag ifTrue: [1 bitShift: 29] ifFalse: [0]).\r\tprimitiveIndex > 0 ifTrue:\r\t\t[pc := method initialPC.\r\t\t method\r\t\t\tat: pc + 0 put: method encoderClass callPrimitiveCode;\r\t\t\tat: pc + 1 put: (primitiveIndex bitAnd: 16rFF);\r\t\t\tat: pc + 2 put: (primitiveIndex bitShift: -8)].\r\t^method"},{"name":"cleanUpSourceInTrailers","linesOfCode":4,"sourceCode":"cleanUpSourceInTrailers\r\r\tself allInstances do: [:e | e isInstalled ifFalse: [e embeddSourceInTrailer]].  \r\t\"pay attention since embeddSourceInTrailer creates a new compiled method. So iterating while\r\tchanging it is a bad idea. This is why we use allInstances do and not allInstancesDo:\""},{"name":"newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:","linesOfCode":25,"sourceCode":"newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex\r\t\"Answer an instance of me. The header is specified by the message \r\t arguments. The remaining parts are not as yet determined.\"\r\t| method pc |\r\tnArgs > 15 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many arguments'].\r\tnTemps > 63 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many temporary variables'].\t\r\tnLits > 65535 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many literals'].\r\r\tmethod := trailer\r\t\t\t\tcreateMethod: numberOfBytes\r\t\t\t\tclass: self\r\t\t\t\theader:    (nArgs bitShift: 24)\r\t\t\t\t\t\t+ (nTemps bitShift: 18)\r\t\t\t\t\t\t+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])\r\t\t\t\t\t\t+ nLits\r\t\t\t\t\t\t+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).\r\tprimitiveIndex > 0 ifTrue:\r\t\t[pc := method initialPC.\r\t\t method\r\t\t\tat: pc + 0 put: method encoderClass callPrimitiveCode;\r\t\t\tat: pc + 1 put: (primitiveIndex bitAnd: 16rFF);\r\t\t\tat: pc + 2 put: (primitiveIndex bitShift: -8)].\r\t^method"},{"name":"toReturnSelf","linesOfCode":3,"sourceCode":"toReturnSelf\r\t\"Answer an instance of me that is a quick return of the instance (^self).\"\r\r\t^ self toReturnSelfTrailerBytes: CompiledMethodTrailer empty"},{"name":"subclassResponsibilityMarker","linesOfCode":2,"sourceCode":"subclassResponsibilityMarker\r\t^ #subclassResponsibility"},{"name":"conflictMarker","linesOfCode":2,"sourceCode":"conflictMarker\r\t^ #traitConflict"},{"name":"sortBlock","linesOfCode":6,"sourceCode":"sortBlock\r\t\"Return a sort block that orders methods by class name and then by selector\"\r\t^  [ :a :b| \r\t\t\ta methodClass = b methodClass\r\t\t\t\tifTrue: [ a selector <= b selector ]\r\t\t\t\tifFalse: [ a methodClass name <= b methodClass name ]]"},{"name":"newFrom:","linesOfCode":6,"sourceCode":"newFrom: aCompiledMethod\r\t| inst |\r\tinst := super basicNew: aCompiledMethod size.\r\t1 to: aCompiledMethod size do: [:index |\r\t\tinst at: index put: (aCompiledMethod at: index)].\r\t^ inst."},{"name":"toReturnSelfTrailerBytes:","linesOfCode":3,"sourceCode":"toReturnSelfTrailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the instance (^self).\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256"},{"name":"checkBytecodeSetConflictsInMethodsWith:","linesOfCode":4,"sourceCode":"checkBytecodeSetConflictsInMethodsWith: aBlock\r\r\tself allSubInstances\r\t\tdetect: aBlock\r\t\tifFound: [ Warning signal: 'There are existing CompiledMethods with a different encoderClass.' ]"},{"name":"installPrimaryBytecodeSet:","linesOfCode":7,"sourceCode":"installPrimaryBytecodeSet: aBytecodeEncoderSubclass\r\tPrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:\r\t\t[ ^self ].\r\tself checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass.\r\tself checkBytecodeSetConflictsInMethodsWith: [:m| \r\t\tm usesPrimaryBytecodeSet and: [m encoderClass ~~ aBytecodeEncoderSubclass]].\r\tPrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass"},{"name":"installSecondaryBytecodeSet:","linesOfCode":7,"sourceCode":"installSecondaryBytecodeSet: aBytecodeEncoderSubclass\r\tPrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:\r\t\t[ ^ self ].\r\tself checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass.\r\tself checkBytecodeSetConflictsInMethodsWith: [ :m | \r\t\tm usesSecondaryBytecodeSet and: [ m encoderClass ~~ aBytecodeEncoderSubclass ] ].\r\tSecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass"},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize    \"CompiledMethod initialize\"\r\t\"Initialize class variables specifying the size of the temporary frame\r\tneeded to run instances of me.\"\r\r\tSmallFrame := 16.\t\"Context range for temps+stack\"\r\tLargeFrame := 56.\r\tPrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures.\r\tSecondaryBytecodeSetEncoderClass := EncoderForSistaV1"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\t\"This will not make a meaningful method, but it could be used\r\tto invoke some otherwise useful method in this class.\"\r\t^self newMethod: 2 header: 1024"},{"name":"disabledMarker","linesOfCode":2,"sourceCode":"disabledMarker\r\t^ #shouldNotImplement"},{"name":"toReturnField:trailerBytes:","linesOfCode":4,"sourceCode":"toReturnField: field trailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the instance variable \r\tindexed by the argument, field.\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 264 + field"},{"name":"abstractMarker","linesOfCode":2,"sourceCode":"abstractMarker\r\t^ #subclassResponsibility"},{"name":"handleFailingNewMethod:header:","linesOfCode":19,"sourceCode":"handleFailingNewMethod: numberOfBytes header: headerWord\r\t\"This newMethod:header: gets sent after newMethod:header: has failed\r\t and allowed a scavenging garbage collection to occur.  The scavenging\r\t collection will have happened as the VM is activating the (failing) basicNew:.\r\t If handleFailingBasicNew: fails then the scavenge failed to reclaim sufficient\r\t space and a global garbage collection is required.  Retry after garbage\r\t collecting and growing memory if necessary.\r\r\t Primitive. Answer an instance of this class with the number of indexable variables\r\t specified by the argument, headerWord, and the number of bytecodes specified\r\t by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes\r\t is negative, or if the receiver is not a CompiledMethod class, or if there is not enough\r\t memory available. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 79>\r\t| bytesRequested |\r\tbytesRequested := (headerWord bitAnd: 16rFFFF) + 1 * Smalltalk wordSize + numberOfBytes + 16.\r\tSmalltalk garbageCollect < bytesRequested ifTrue:\r\t\t[Smalltalk growMemoryByAtLeast: bytesRequested].\r\t\"retry after global garbage collect and possible grow\"\r\t^self handleFailingFailingNewMethod: numberOfBytes header: headerWord"},{"name":"toReturnConstant:trailerBytes:","linesOfCode":4,"sourceCode":"toReturnConstant: index trailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the constant\r\tindexed in (true false nil -1 0 1 2).\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256 + index"},{"name":"fullFrameSize","linesOfCode":2,"sourceCode":"fullFrameSize  \"CompiledMethod fullFrameSize\"\r\t^ LargeFrame"},{"name":"checkIsValidBytecodeEncoder:","linesOfCode":3,"sourceCode":"checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass\r\t(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:\r\t\t[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder']."},{"name":"handleFailingFailingNewMethod:header:","linesOfCode":14,"sourceCode":"handleFailingFailingNewMethod: numberOfBytes header: headerWord\r\t\"This newMethod:header: gets sent after handleFailingBasicNew: has done a full\r\t garbage collection and possibly grown memory.  If this basicNew: fails then the\r\t system really is low on space, so raise the OutOfMemory signal.\r\r\t Primitive. Answer an instance of this class with the number of indexable variables\r\t specified by the argument, headerWord, and the number of bytecodes specified\r\t by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes\r\t is negative, or if the receiver is not a CompiledMethod class, or if there is not enough\r\t memory available. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 79>\r\t\"space must be low.\"\r\tOutOfMemory signal.\r\t\"retry if user proceeds\"\r\t^self newMethod: numberOfBytes header: headerWord"},{"name":"newInstanceFrom:variable:size:map:","linesOfCode":11,"sourceCode":"newInstanceFrom: oldInstance variable: variable size: instSize map: map\r\t\"Create a new instance of the receiver based on the given old instance.\r\tThe supplied map contains a mapping of the old instVar names into\r\tthe receiver's instVars\"\r\t| new |\r\tnew := self newFrom: oldInstance.\r\t1 to: instSize do: \r\t\t[:offset |  (map at: offset) > 0 ifTrue:\r\t\t\t[new instVarAt: offset\r\t\t\t\t\tput: (oldInstance instVarAt: (map at: offset))]].\r\t^new"}],"meta":null}},{"name":"FFICallbackReturnValue","instanceVariables":[],"methods":[{"name":"returnInteger:","linesOfCode":3,"sourceCode":"returnInteger: n\r\tself signedLongAt: self typeOffset put: 0.\r\tself signedLongAt: self valueOffset put: n asInteger"},{"name":"returnDouble:","linesOfCode":3,"sourceCode":"returnDouble: f\r\tself signedLongAt: self typeOffset put: 2.\r\tself doubleAt: self valueOffset put: f asFloat"},{"name":"primReturnFromContext:through:","linesOfCode":8,"sourceCode":"primReturnFromContext: callbackContext \"<ContextPart>\" through: jmpbuf \"<Integer>\" \"^not reached\"\r\t\"Return a value, as described by the receiver, to some C callee that has made a\r\tcallback.   Reestablish the interpreter's state prior to the callback so that either\r\tthe callout can return or subsequent callbacks can occur.  callbackContext is an\r\tactivation of invokeCallback:stack:registers:jmpbuf:.  Its sender is the interpreter's\r\tstate prior to the callback\"\r\t<primitive: 'primReturnFromContextThrough' module: 'IA32ABI' error: errorCode>\r\tself primitiveFailed"},{"name":"typeOffset","linesOfCode":2,"sourceCode":"typeOffset\r\t^1 \"0\""},{"name":"valueOffset","linesOfCode":2,"sourceCode":"valueOffset\r\t^9 \"8\""}],"meta":{"name":"FFICallbackReturnValue class","instanceVariables":[],"methods":[{"name":"dataSize","linesOfCode":3,"sourceCode":"dataSize\r\t\"See class comment\"\r\t^16"}],"meta":null}},{"name":"FFICallbackThunk","instanceVariables":[],"methods":[{"name":"initializeX64","linesOfCode":32,"sourceCode":"initializeX64\r\t\"Initialize the receiver with a __ccall thunk.  The thunk calls thunkEntry in the Alien/IA32ABI plugin,\r\t whose source is in platforms/Cross/plugins/IA32ABI/x64sysvabicc.c.  thunkEntry is the entry point\r\t for Callbacks. The objective of the thunk is to call thunkEntry with all arguments to the call of the\r\t thunk (registers and stack) as well as a pointer to the thunk itself.  thunkEntry is as follows:\r\r\t\tlong\r\t\tthunkEntry(long a0, long a1, long a2, long a3, long a4, long a5,\r\t\t            double d0, double d1, double d2, double d3,\r\t\t            double d4, double d5, double d6, double d7,\r\t\t            void *thunkp, sqIntptr_t *stackp)\r\r\tthunkEntry then collects the various arguments (thunk, integer register arguments, floating-point\r\tregister arguments, stack pointer) in a VMCallbackContext and invokes the callback via invokeCallbackContext:.\"\r\r\t\"thunk+0x0:\tpushq  %rsp\t\t\t\t\t\t\t54\r\t thunk+0x1:\tpushq  %rsp\t\t\t\t\t\t\t54\r\t thunk+0x4:\tmovabsq $thunk, %rax\t\t\t\t\t48 b8 b0..b7 eight bytes of thunk address a.k.a. addressField\r\t thunk+0xc:\tpushq  %rax\t\t\t\t\t\t\t50\r\t thunk+0xd:\tmovabsq $thunkEntry, %rax\t\t\t48 b8 b0..b7 eight bytes of the thunkEntry address\r\t thunk+0x17:\tcallq  *%rax\t\t\t\t\t\t\tff d0\r\t thunk+0x19:\taddq   $0x18, %rsp\t\t\t\t\t48 83 c4 18\r\t thunk+0x1d:\tretq\t\t\t\t\t\t\t\t\tc3\r\t thunk+0x1e:\tnop\t\t\t\t\t\t\t\t\t\t90\r\t thunk+0x1f:\tnop\t\t\t\t\t\t\t\t\t\t90\"\r\tself\r\t\tunsignedLongAt:\t\t  1 put: 16rb8485454;\r\t\tunsignedLongLongAt:\t  5 put: self addressField;\r\t\tunsignedLongAt:\t\t13 put: 16r00b84850; \"00 is the first byte of the 64-bit constant the movabsq/0x48 opcode moves\"\r\t\tunsignedLongLongAt:\t16 put: self primThunkEntryAddress;\r\t\tunsignedByteAt:\t\t24 put: 16rff;\r\t\tunsignedLongAt:\t\t25 put: 16rc48348d0;\r\t\tunsignedLongAt:\t\t29 put: 16r9090c318.\r\tself primThunkEntryAddress\r\r\t\"self newCCall\""},{"name":"initializeX64Win64","linesOfCode":33,"sourceCode":"initializeX64Win64\r\t\"Initialize the receiver with a __ccall thunk.  The thunk calls thunkEntry in the Alien/IA32ABI plugin,\r\t whose source is in platforms/Cross/plugins/IA32ABI/x64win64abicc.c.  thunkEntry is the entry point\r\t for Callbacks. The objective of the thunk is to call thunkEntry with all arguments to the call of the\r\t thunk (registers and stack) as well as a pointer to the thunk itself.  thunkEntry is as follows:\r\r\t\tlong long\r\t\tthunkEntry(long long rcx, long long rdx,\r\t\t      \t\tlong long r8, long long r9,\r\t\t\t\t\tvoid *thunkp, sqIntptr_t *stackp)\r\r\tthunkEntry then collects the various arguments (thunk, integer register arguments, stack pointer)\r\tin a VMCallbackContext and invokes the callback via invokeCallbackContext:.\"\r\r\t\"thunk+0x0:\tpushq  %rsp\t\t\t\t\t\t\t54\r\t thunk+0x1:\tpushq  %rsp\t\t\t\t\t\t\t54\r\t thunk+0x4:\tmovabsq $thunk, %rax\t\t\t\t\t48 b8 b0..b7 eight bytes of thunk address a.k.a. addressField\r\t thunk+0xc:\tpushq  %rax\t\t\t\t\t\t\t50\r\t thunk+0xd:\tsubq   $0x20, %rsp\t\t\t\t\t\t48 83 c4 e0 (this is addq -20 since the immediate is signed extended)\r\t thunk+0x11:\tmovabsq $thunkEntry, %rax\t\t\t48 b8 b0..b7 eight bytes of the thunkEntry address\r\t thunk+0x1b:\tcallq  *%rax\t\t\t\t\t\t\tff d0\r\t thunk+0x1d:\taddq   $0x38, %rsp\t\t\t\t\t48 83 c4 38\r\t thunk+0x21:\tretq\t\t\t\t\t\t\t\t\tc3\r\t thunk+0x22:\tnop\t\t\t\t\t\t\t\t\t\t90\r\t thunk+0x23:\tnop\t\t\t\t\t\t\t\t\t\t90\"\r\tself\r\t\tunsignedLongAt:\t\t  1 put: 16rb8485454;\r\t\tunsignedLongLongAt:\t  5 put: self addressField;\r\t\tunsignedLongAt:\t\t13 put: 16rc4834850; \r\t\tunsignedLongAt:\t\t17 put: 16r00b848e0; \"00 is the first byte of the 64-bit constant the movabsq/0x48 opcode moves\"\r\t\tunsignedLongLongAt:\t20 put: self primThunkEntryAddress;\r\t\tunsignedByteAt:\t\t28 put: 16rff;\r\t\tunsignedLongAt:\t\t29 put: 16rc48348d0;\r\t\tunsignedLongAt:\t\t33 put: 16r9090c338.\r\tself primThunkEntryAddress\r\r\t\"self newCCall\""},{"name":"initializeStdcall:","linesOfCode":4,"sourceCode":"initializeStdcall: bytes\r\t\"Initialize the receiver with a __stdcall thunk with bytes argument bytes.\"\r\tCallback abi caseOf: {\r\t['IA32']\t\t->\t[self initializeX86Stdcall: bytes] }"},{"name":"initializeARM32","linesOfCode":34,"sourceCode":"initializeARM32\r\t\"Initialize the receiver with a __ccall thunk.  The thunk calls thunkEntry in the Alien/IA32ABI plugin,\r\t whose source is in platforms/Cross/plugins/IA32ABI/arm32abicc.c.  thunkEntry is the entry point\r\t for Callbacks. The objective of the thunk is to call thunkEntry with all arguments to the call of the\r\t thunk (registers and stack) as well as a pointer to the thunk itself.  thunkEntry is as follows:\r\t\r\t\tlong long\r\t\tthunkEntry(long r0, long r1, long r2, long r3,\r\t\t            double d0, double d1, double d2, double d3,\r\t\t            double d4, double d5, double d6, double d7,\r\t\t            void *thunkpPlus16, sqIntptr_t *stackp)\r\r\tthunkEntry then collects the various arguments (thunk, integer register arguments, floating-point\r\tregister arguments, stack pointer) in a VMCallbackContext and invokes the callback via invokeCallbackContext:.\"\r\r\t\"0x0 <thunk+0>:\t\tmov     r12, sp\t\t\t; 0xe1a0c00d\r \t 0x4 <thunk+4>:\t\tsub     sp, sp, #16\t\t; 0xe24dd010\r \t 0x8 <thunk+8>:\t\tstr     pc, [sp, #0]\t\t; 0xe58df000 N.B. passes thunk+16; thunkEntry compensates\r \t 0xc <thunk+12>:\t\tstr     r12, [sp,#4]\t\t; 0xe58dc004\r \t 0x10 <thunk+16>:\tstr     lr, [sp, #12]\t\t; 0xe58de00c\r \t 0x14 <thunk+20>:\tldr     r12, [pc, #8]\t\t; 0xe59fc008\r \t 0x18 <thunk+24>:\tblx     r12\t\t\t\t; 0xe12fff3c\r \t 0x1c <thunk+28>:\tadd     sp, sp, #12\t\t; 0xe28dd00c\r \t 0x20 <thunk+32>:\tldr     pc, [sp], #4!\t\t; 0xe49df004 ; pop     {pc}\r \t 0x24 <thunk+36>:     .word thunkEntry\"\r\tself\r\t\tunsignedLongAt:   1 put: 16re1a0c00d;\r\t\tunsignedLongAt:   5 put: 16re24dd010;\r\t\tunsignedLongAt:   9 put: 16re58df000;\r\t\tunsignedLongAt: 13 put: 16re58dc004;\r\t\tunsignedLongAt: 17 put: 16re58de00c;\r\t\tunsignedLongAt: 21 put: 16re59fc008;\r\t\tunsignedLongAt: 25 put: 16re12fff3c;\r\t\tunsignedLongAt: 29 put: 16re28dd00c;\r\t\tunsignedLongAt: 33 put: 16re49df004;\r\t\tunsignedLongAt: 37 put: self primThunkEntryAddress\r\r\t\"self newCCall\""},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize\r\t\"Initialize the receiver with a __ccall thunk.\"\r\tCallback abi caseOf: {\r\t['IA32']\t\t->\t[self initializeX86].\r\t['ARM32']\t->\t[self initializeARM32].\r\t['X64']\t\t->\t[self initializeX64].\r\t['X64Win64']\t->\t[self initializeX64Win64] }"},{"name":"free","linesOfCode":11,"sourceCode":"free\r\t\"Recycle the memory in the executable page containing the receiver's thunk.\r\t Since the receiver is a derived pointer to a block in an executable page this\r\t requires returning the block to the free pool.\"\r\tAllocatedThunks remove: self.\r\tAccessProtect critical:\r\t\t[| address |\r\t\taddress := self addressField.\r\t\taddress ~= 0 ifTrue:\r\t\t\t[self addressFieldPut: 0.\r\t\t\t self class freeBlockInExecutablePage: address]]"},{"name":"initializeX86","linesOfCode":29,"sourceCode":"initializeX86\r\t\"Initialize the receiver with a __ccall thunk.  The thunk calls thunkEntry in the Alien/IA32ABI plugin,\r\t whose source is in platforms/Cross/plugins/IA32ABI/x64win64abicc.c.  thunkEntry is the entry point\r\t for Callbacks. The objective of the thunk is to call thunkEntry with all arguments to the call of the\r\t thunk (registers and stack) as well as a pointer to the thunk itself.  thunkEntry is as follows:\r\r\t\tlong\r\t\tthunkEntry(void *thunkp, sqIntptr_t *stackp)\r\r\tthunkEntry then collects the various arguments (thunk, stack pointer) in a VMCallbackContext and\r\tinvokes the callback via invokeCallbackContext:.\"\r\r\t\"thunk:\t\tpush   %esp\t\t\t\t0x54\t\t\t\t\t\t\t0xa1905454\r\t thunk+01:\tpush   %esp\t\t\t\t0x54\r\t thunk+02:\tnop   \t\t\t\t\t\t0x90\r\t thunk+03:\tmov    $thunkEntry,%eax\t0xb8 0x00 0x00 0x00 0x00\t0x00000000 - entry\r\t thunk+08:\tnop   \t\t\t\t\t\t0x90\t\t\t\t\t\t\t0x68909090\r\t thunk+09:\tnop   \t\t\t\t\t\t0x90\r\t thunk+10:\tnop   \t\t\t\t\t\t0x90\r\t thunk+11:\tpush   $thunk\t\t\t\t0x68 0x00 0x00 0x00 0x00\t0x00000000 - thunk\r\t thunk+16:\tcall   *%eax\t\t\t\t\t0xff 0xd0\t\t\t\t\t\t0xc483d0ff\r\t thunk+18:\tadd    $0xC,%esp\t\t\t0x83 0xc4 0x0C\t\t\t\t0x9090c30C\r\t thunk+21:\tret\t\t\t\t\t\t\t0xc3\r\t thunk+22:\tnop\t\t\t\t\t\t\t0x90\r\t thunk+23:\tnop\t\t\t\t\t\t\t0x90\"\r\tself\r\t\tunsignedLongAt:  1 put: 16rB8905454;\r\t\tunsignedLongAt:  5 put: self primThunkEntryAddress;\r\t\tunsignedLongAt:  9 put: 16r68909090;\r\t\tunsignedLongAt: 13 put: self addressField;\r\t\tunsignedLongAt: 17 put: 16rC483D0FF;\r\t\tunsignedLongAt: 21 put: 16r9090C30C"},{"name":"address","linesOfCode":3,"sourceCode":"address\r\t\"Thunks are hacked - again they need to be indirect objects with a 0 size field.\"\r\t^self addressField"},{"name":"primFree","linesOfCode":2,"sourceCode":"primFree\r\tself shouldNotImplement"},{"name":"initializeX86Stdcall:","linesOfCode":21,"sourceCode":"initializeX86Stdcall: bytes\r\t\"Initialize the receiver with a __stdcall thunk with bytes argument bytes. (See initializeX86 fort more info)\"\r\t\"thunk:\t\tpush   %esp\t\t\t\t0x54\t\t\t\t\t\t\t0xa1905454\r\t thunk+01:\tpush   %esp\t\t\t\t0x54\r\t thunk+02:\tnop   \t\t\t\t\t\t0x90\r\t thunk+03:\tmov    $thunkEntry,%eax\t0xb8 0x00 0x00 0x00 0x00\t0x00000000 - entry\r\t thunk+08:\tnop   \t\t\t\t\t\t0x90\t\t\t\t\t\t\t0x68909090\r\t thunk+09:\tnop   \t\t\t\t\t\t0x90\r\t thunk+10:\tnop   \t\t\t\t\t\t0x90\r\t thunk+11:\tpush   $thunk\t\t\t\t0x68 0x00 0x00 0x00 0x00\t0x00000000 - thunk\r\t thunk+16:\tcall   *%eax\t\t\t\t\t0xff 0xd0\t\t\t\t\t\t0xc483d0ff\r\t thunk+18:\tadd    $0xC,%esp\t\t\t0x83 0xc4 0x0C\t\t\t\t0xBYTSc20C\r\t thunk+21:\tret    $bytes\t\t\t\t0xc2 0xBY 0xTS\"\r\r\tself\r\t\tunsignedLongAt:  1 put: 16rB8905454;\r\t\tunsignedLongAt:  5 put: self primThunkEntryAddress;\r\t\tunsignedLongAt:  9 put: 16r68909090;\r\t\tunsignedLongAt: 13 put: self addressField;\r\t\tunsignedLongAt:  17 put: 16rC483D0FF;\r\t\tunsignedShortAt: 21 put: 16rC20C;\r\t\tunsignedShortAt: 23 put: bytes"},{"name":"primThunkEntryAddress","linesOfCode":15,"sourceCode":"primThunkEntryAddress \"^<Integer>\"\r\t\"Answer the address of the entry-point for thunk callbacks:\r\t\tx86: long thunkEntry(void *thunkp, long *stackp);\r\t\tx64: long thunkEntry(long a, long b, long c, long d, long, e, long f,\r\t\t\t\t\t\t\t\tdouble d0, double d1, double d2, double d3,\r\t\t\t\t\t\t\t\tdouble d4, double d5, double d6, double d7,\r\t\t\t\t\t\t\t\tvoid *thunkp, long *stackp);\r\t\tARM: long thunkEntry(long a, long b, long c, long d,\r\t\t\t\t\t\t\t\tdouble d0, double d1, double d2, double d3,\r\t\t\t\t\t\t\t\tdouble d4, double d5, double d6, double d7,\r\t\t\t\t\t\t\t\tvoid *thunkp, long *stackp);\r\t etc.\r\t This is the function a callback thunk/trampoline should call to initiate a callback.\"\r\t<primitive: 'primThunkEntryAddress' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"}],"meta":{"name":"FFICallbackThunk class","instanceVariables":[],"methods":[{"name":"privateFinalizingNew","linesOfCode":7,"sourceCode":"privateFinalizingNew\r\t\"Answer a new instance that will free its page when garbage collected.\"\r\t| address |\r\taddress := self unusedBlockInExecutablePage.\r\t^AllocatedThunks\r\t\tadd: (self forPointer: address)\r\t\tfinalizing: address "},{"name":"finalize:","linesOfCode":2,"sourceCode":"finalize: address\r\tself freeBlockInExecutablePage: address"},{"name":"freeBlockInExecutablePage:","linesOfCode":9,"sourceCode":"freeBlockInExecutablePage: address\r\tExecutablePages do:\r\t\t[:alienPage| | alienAddress |\r\t\talienAddress := alienPage address.\r\t\t(address >= alienAddress\r\t\t and: [alienAddress + alienPage dataSize >= address]) ifTrue:\r\t\t\t[alienPage unsignedByteAt: address - alienAddress + 1 put: 0.\r\t\t\t ^self]]\r\t\t\t"},{"name":"newCCall","linesOfCode":3,"sourceCode":"newCCall\r\t\"Answer a new instance for the C calling-convention.\"\r\t^self privateFinalizingNew initialize"},{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\t\"FFICallbackThunk initialize\"\r\tAccessProtect := Semaphore forMutualExclusion.\r\tAllocatedThunks := AlienWeakTable newForOwner: self.\r\tExecutablePages := Set new.\r\tself ensureNotifiedAtStartup"},{"name":"newStdCall:","linesOfCode":4,"sourceCode":"newStdCall: argBytes\r\t\"Answer a new instance for Windows' StdCall (Pascal) convention, given the\r\t size of the arguments in bytes (bytes to cut-back from the stack on return).\"\r\t^self privateFinalizingNew initializeStdcall: argBytes"},{"name":"ensureNotifiedAtStartup","linesOfCode":6,"sourceCode":"ensureNotifiedAtStartup\r\t\"FFICallbackThunk needs to be notified at system startup to clear the ExecutablePages table.\"\r\r\tself ~~ FFICallbackThunk ifTrue: [ ^ self ].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: self name\r\t\tatPriority: 60"},{"name":"startUp:","linesOfCode":5,"sourceCode":"startUp: inANewImageSession\r\t\"Any thunks in the finalization registry at the time the image comes up in a new session MUST NOT be finalized and should  immediately be discarded. Their thunk pointers are no longer valid.\"\r\tinANewImageSession ifTrue:\r\t\t[AllocatedThunks removeAll.\r\t\tExecutablePages := Set new]"},{"name":"unusedBlockInExecutablePage","linesOfCode":12,"sourceCode":"unusedBlockInExecutablePage\r\tAccessProtect critical:\r\t\t[ExecutablePages do:\r\t\t\t[:alien|\r\t\t\t1 to: alien dataSize - self dataSize by: self dataSize do:\r\t\t\t\t[:i|\r\t\t\t\t(alien unsignedByteAt: i) = 0 ifTrue:\r\t\t\t\t\t[alien unsignedByteAt: i put: 1.\r\t\t\t\t\t ^alien address + i - 1]]]].\r\t^(AccessProtect critical: [ExecutablePages add: self allocateExecutablePage])\r\t\tunsignedByteAt: 1 put: 1;\r\t\taddress"},{"name":"allocateExecutablePage","linesOfCode":6,"sourceCode":"allocateExecutablePage \"^<Alien>\"\r\t\"Answer an Alien around a piece of (probably malloced) memory, of some multiple\r\t of the pagesize, that has execute permissions set.  This memory can be parcelled\r\t out to individual FFICallbackThunks to hold their thunk/trampoline machine code.\"\r\t<primitive: 'primAllocateExecutablePage' module: 'IA32ABI' error: errorCode>\r\t^self primitiveFailed"},{"name":"dataSize","linesOfCode":2,"sourceCode":"dataSize\r\t^40 \"see FFICallbackThunk initialize & initializeStdcall:; must be big enough for the largest thunk created.\""}],"meta":null}},{"name":"VMCallbackContext32","instanceVariables":[],"methods":[{"name":"primReturnAs:fromContext:","linesOfCode":3,"sourceCode":"primReturnAs: typeCode \"<SmallInteger>\" fromContext: context \"<MethodContext>\"\r\t<primitive: 'primReturnAsFromContextThrough' module: 'IA32ABI' error: ec>\r\t^self primitiveFailed"},{"name":"floatregargsp","linesOfCode":2,"sourceCode":"floatregargsp\r\t^Alien forPointer: (self unsignedLongAt: 13)"},{"name":"thunkp","linesOfCode":2,"sourceCode":"thunkp\r\t^self unsignedLongAt: 1"},{"name":"returnInteger:","linesOfCode":2,"sourceCode":"returnInteger: n\r\t^self wordResult: n"},{"name":"stackp","linesOfCode":2,"sourceCode":"stackp\r\t^Alien forPointer: (self unsignedLongAt: 5)"},{"name":"singleFloatResult:","linesOfCode":3,"sourceCode":"singleFloatResult: aFloat\r\tself floatAt: 25 put: aFloat.\r\t^3"},{"name":"primSignal:andReturnAs:fromContext:","linesOfCode":3,"sourceCode":"primSignal: aSemaphore \"<Semaphore>\" andReturnAs: typeCode \"<SmallInteger>\" fromContext: context \"<MethodContext>\"\r\t<primitive: 'primReturnAsFromContextThrough' module: 'IA32ABI' error: ec>\r\t^ self primitiveFailed"},{"name":"returnDouble:","linesOfCode":2,"sourceCode":"returnDouble: f\r\t^self floatResult: f"},{"name":"wordResult:","linesOfCode":11,"sourceCode":"wordResult: aValue\r\t\"Accept any value in the -2^31 to 2^32-1 range or booleans.\"\r\t| anInteger |\r\tanInteger := aValue isInteger\r\t\t\t\t\t\tifTrue: [aValue]\r\t\t\t\t\t\tifFalse:  \"Will provoke a mustBeBoolean error if not a boolean.\"\r\t\t\t\t\t\t\t[aValue ifTrue: [1] ifFalse: [0]].\r\tanInteger >= 0\r\t\tifTrue: [self unsignedLongAt: 25 put: anInteger]\r\t\tifFalse: [self signedLongAt: 25 put: anInteger].\r\t^1"},{"name":"wordSize","linesOfCode":2,"sourceCode":"wordSize\r\t^4"},{"name":"intregargsp","linesOfCode":2,"sourceCode":"intregargsp\r\t^Alien forPointer: (self unsignedLongAt: 9)"},{"name":"floatResult:","linesOfCode":3,"sourceCode":"floatResult: aFloat\r\tself doubleAt: 25 put: aFloat.\r\t^3"},{"name":"rawStackp","linesOfCode":2,"sourceCode":"rawStackp\r\t^self unsignedLongAt: 5"}],"meta":{"name":"VMCallbackContext32 class","instanceVariables":[],"methods":[{"name":"dataSize","linesOfCode":3,"sourceCode":"dataSize\r\t\"We only access the fields before trampoline, so this is fine.\"\r\t^32"}],"meta":null}},{"name":"VMCallbackContext64","instanceVariables":[],"methods":[{"name":"primReturnAs:fromContext:","linesOfCode":3,"sourceCode":"primReturnAs: typeCode \"<SmallInteger>\" fromContext: context \"<MethodContext>\"\r\t<primitive: 'primReturnAsFromContextThrough' module: 'IA32ABI' error: ec>\r\t^self primitiveFailed"},{"name":"floatregargsp","linesOfCode":2,"sourceCode":"floatregargsp\r\t^Alien forPointer: (self unsignedLongLongAt: 25)"},{"name":"thunkp","linesOfCode":2,"sourceCode":"thunkp\r\t^self unsignedLongLongAt: 1"},{"name":"returnInteger:","linesOfCode":2,"sourceCode":"returnInteger: n\r\t^self wordResult: n"},{"name":"stackp","linesOfCode":2,"sourceCode":"stackp\r\t^Alien forPointer: (self unsignedLongLongAt: 9)"},{"name":"singleFloatResult:","linesOfCode":3,"sourceCode":"singleFloatResult: aFloat\r\tself floatAt: 49 put: aFloat.\r\t^3"},{"name":"primSignal:andReturnAs:fromContext:","linesOfCode":3,"sourceCode":"primSignal: aSemaphore \"<Semaphore>\" andReturnAs: typeCode \"<SmallInteger>\" fromContext: context \"<MethodContext>\"\r\t<primitive: 'primReturnAsFromContextThrough' module: 'IA32ABI' error: ec>\r\t^ self primitiveFailed"},{"name":"returnDouble:","linesOfCode":2,"sourceCode":"returnDouble: f\r\t^self floatResult: f"},{"name":"wordResult:","linesOfCode":11,"sourceCode":"wordResult: aValue\r\t\"Accept any value in the -2^63 to 2^64-1 range or booleans.\"\r\t| anInteger |\r\tanInteger := aValue isInteger\r\t\t\t\t\t\tifTrue: [aValue]\r\t\t\t\t\t\tifFalse:  \"Will provoke a mustBeBoolean error if not a boolean.\"\r\t\t\t\t\t\t\t[aValue ifTrue: [1] ifFalse: [0]].\r\tanInteger >= 0\r\t\tifTrue: [self unsignedLongLongAt: 49 put: anInteger]\r\t\tifFalse: [self signedLongLongAt: 49 put: anInteger].\r\t^1"},{"name":"wordSize","linesOfCode":2,"sourceCode":"wordSize\r\t^8"},{"name":"intregargsp","linesOfCode":2,"sourceCode":"intregargsp\r\t^Alien forPointer: (self unsignedLongLongAt: 17)"},{"name":"floatResult:","linesOfCode":3,"sourceCode":"floatResult: aFloat\r\tself doubleAt: 49 put: aFloat.\r\t^3"},{"name":"rawStackp","linesOfCode":2,"sourceCode":"rawStackp\r\t^self unsignedLongAt: 9"}],"meta":{"name":"VMCallbackContext64 class","instanceVariables":[],"methods":[{"name":"dataSize","linesOfCode":3,"sourceCode":"dataSize\r\t\"We only access the fields before trampoline, so this is fine.\"\r\t^64"}],"meta":null}},{"name":"ByteSymbol","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t| ba sz |\r\tsz := self byteSize.\r\tba := ByteArray new: sz.\r\tba replaceFrom: 1 to: sz with: self startingAt: 1.\r\t^ba"},{"name":"asOctetString","linesOfCode":2,"sourceCode":"asOctetString\r\t^ self"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^(self at: index) asciiValue"},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\r\tanEncoder encodeString: self"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":3,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Use double dispatching for speed\"\r\t^aCollection findFirstInByteString: self startingAt: start"},{"name":"isByteString","linesOfCode":3,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t^true"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":4,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\"\r\t<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>\r\t^super findSubstring: key in: body startingAt: start matchTable: matchTable"},{"name":"isOctetString","linesOfCode":5,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t^ true.\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":6,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a byte char string, I know that we have to scan single-byte characters and don't have to handle encodings etc\"\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\t^aFont scanByteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX"},{"name":"beginsWith:","linesOfCode":14,"sourceCode":"beginsWith: prefix\r\t\"Answer whether the receiver begins with the given prefix string.\r\tThe comparison is case-sensitive.\"\r\r\t\"IMPLEMENTATION NOTE:\r\tfollowing algorithm is optimized in primitive only in case self and prefix are bytes like.\r\tOtherwise, if self is wide, then super outperforms,\r\tOtherwise, if prefix is wide, primitive is not correct\"\r\r\t\"(#pharo beginsWith: #pharoProject) >>> false\"\r\t\"(#pharo beginsWith: #phuro) >>> false\"\r\t\"(#pharo beginsWith: #pha) >>> true\"\r\t\r\tprefix class isBytes ifFalse: [^super beginsWith: prefix].\r\t\r\tself size < prefix size ifTrue: [^ false].\r\t^ (self findSubstring: prefix in: self startingAt: 1\r\t\t\tmatchTable: CaseSensitiveOrder) = 1"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitHookPrimitive: self"},{"name":"at:","linesOfCode":6,"sourceCode":"at: index \r\t\"Primitive. Answer the Character stored in the field of the receiver\r\tindexed by the argument. Fail if the index argument is not an Integer or\r\tis out of bounds. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^ Character value: (super at: index)"},{"name":"asKmCategoryIn:","linesOfCode":2,"sourceCode":"asKmCategoryIn: aKmRepository\r\t^aKmRepository categoryForName: self"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"species","linesOfCode":3,"sourceCode":"species\r\t\"Answer the preferred class for reconstructing the receiver.\"\r\t^ByteString\r"},{"name":"string:","linesOfCode":4,"sourceCode":"string: aString\r\t1 to: aString size do: [:j | \r\t\tself privateAt: j put: (aString at: j)].\r\t^self"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock\r\t\"Use double dispatching for speed\"\r\t| index |\r\t^(index := aCollection findFirstInByteString: self startingAt: start) = 0\r\t\tifTrue: [aBlock value]\r\t\tifFalse: [index]"},{"name":"byteAt:put:","linesOfCode":3,"sourceCode":"byteAt: anInteger put: anObject \r\t\"You cannot modify the receiver.\"\r\t^ self modificationForbiddenFor: #byteAt:put: index: anInteger value: anObject"},{"name":"privateAt:put:","linesOfCode":14,"sourceCode":"privateAt: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter \r\t\tifFalse:[^self errorImproperStore].\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index] ]\r\t\tifFalse: [self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #privateAt:put: index: index value: aCharacter ].\r"},{"name":"hasWideCharacterFrom:to:","linesOfCode":3,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Always false because I only contains byte characters\"\r\t^false"}],"meta":{"name":"ByteSymbol class","instanceVariables":[],"methods":[{"name":"stringHash:initialHash:","linesOfCode":2,"sourceCode":"stringHash: aString initialHash: speciesHash\r\t^ByteString stringHash: aString initialHash: speciesHash"},{"name":"materializeFrom:","linesOfCode":2,"sourceCode":"materializeFrom: aDecoder\r\r\t^ aDecoder nextEncodedString asSymbol"},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":2,"sourceCode":"findFirstInString: aString inSet: inclusionMap startingAt: start\r\t^ByteString findFirstInString: aString  inSet: inclusionMap startingAt: start"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":2,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\r\t^ByteString indexOfAscii: anInteger inString: aString startingAt: start"},{"name":"translate:from:to:table:","linesOfCode":2,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t^ByteString translate: aString from: start  to: stop  table: table"}],"meta":null}},{"name":"WideSymbol","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\r\t^ self size * 4.\r"},{"name":"byteAt:","linesOfCode":5,"sourceCode":"byteAt: index\r\r\t| d r |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\t^ (self wordAt: d) byteAt: ((4 - r) + 1).\r"},{"name":"wordAt:","linesOfCode":3,"sourceCode":"wordAt: index\r\t<primitive: 60>\r\t^ (self basicAt: index).\r"},{"name":"wordAt:put:","linesOfCode":2,"sourceCode":"wordAt: index put: anInteger\r\t^ self modificationForbiddenFor: #wordAt:put: index: index value: anInteger "},{"name":"mutateJISX0208StringToUnicode","linesOfCode":9,"sourceCode":"mutateJISX0208StringToUnicode\r\r\t| c |\r\t1 to: self size do: [:i |\r\t\tc := self at: i.\r\t\t(c leadingChar = JISX0208 leadingChar or: [\r\t\t\tc leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [\r\t\t\tself basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.\r\t\t]\r\t].\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":8,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a wide char string, I know that we have to scan multi-byte characters and handle encodings etc\"\r\t| charSet |\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\tcharSet := self encodedCharSetAt: startIndex.\r\t^charSet scanMultibyteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX font: aFont\t"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index \r\t\"Answer the Character stored in the field of the receiver indexed by the argument.\"\r\t^ Character value: (self wordAt: index).\r"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^true"},{"name":"species","linesOfCode":3,"sourceCode":"species\r\t\"Answer the preferred class for reconstructing the receiver.\"\r\t^WideString\r"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ self."},{"name":"string:","linesOfCode":4,"sourceCode":"string: aString\r\t1 to: aString size do: [:j | \r\t\tself privateAt: j put: (aString at: j) asInteger].\r\t^ self"},{"name":"byteAt:put:","linesOfCode":2,"sourceCode":"byteAt: index put: aByte\r\t^ self modificationForbiddenFor: #byteAt:put: index: index value: aByte"},{"name":"privateAt:put:","linesOfCode":12,"sourceCode":"privateAt: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 61>\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\tifFalse: [ ^ self errorSubscriptBounds: index] ]\r\t\tifFalse: [^ self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #privateAt:put: index: index value: aCharacter ].\r"},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstring: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"WideSymbol class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FFITypeArray","instanceVariables":[],"methods":[],"meta":{"name":"FFITypeArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LGitExternalCommitArray","instanceVariables":[],"methods":[{"name":"at:","linesOfCode":2,"sourceCode":"at: anIndex\r\t^ LGitCommit fromHandle: (super at: anIndex)"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: anIndex put: aLGitCommit\r\t^ super at: anIndex put: aLGitCommit getHandle"}],"meta":{"name":"LGitExternalCommitArray class","instanceVariables":[],"methods":[{"name":"fromCollection:","linesOfCode":6,"sourceCode":"fromCollection: aCollection\r\t| instance |\r\tinstance := self externalNew: aCollection size.\r\taCollection withIndexDo: [ :commit :index |\r\t\tinstance at: index put: commit ].\r\t\r\t^ instance"},{"name":"type","linesOfCode":2,"sourceCode":"type \r\t^ LGitCommit"}],"meta":null}},{"name":"LGitExternalStringArray","instanceVariables":[],"methods":[{"name":"free","linesOfCode":4,"sourceCode":"free\r\t1 to: self size do: [ :index | \r\t\t(self primAt: index) free ].\r\t\r\tsuper free"},{"name":"primAt:","linesOfCode":2,"sourceCode":"primAt: anInteger\r\t^ super at: anInteger"},{"name":"at:","linesOfCode":2,"sourceCode":"at: anInteger\r\t^ (self primAt: anInteger) readStringUTF8"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: aString\r\t^ super at: index put: aString asLGitExternalString getHandle"}],"meta":{"name":"LGitExternalStringArray class","instanceVariables":[],"methods":[{"name":"fromCollection:","linesOfCode":6,"sourceCode":"fromCollection: aCollection\r\t| instance |\r\tinstance := self externalNew: aCollection size.\r\taCollection withIndexDo: [ :element :index |\r\t\tinstance at: index put: element ].\r\t\r\t^ instance"},{"name":"type","linesOfCode":2,"sourceCode":"type\r\t^ 'char*'"}],"meta":null}},{"name":"LGitExternalUInt8Array","instanceVariables":[],"methods":[{"name":"type","linesOfCode":2,"sourceCode":"type \r\t^ FFIUInt8"}],"meta":{"name":"LGitExternalUInt8Array class","instanceVariables":[],"methods":[{"name":"type","linesOfCode":2,"sourceCode":"type\r\t^ FFIUInt32"}],"meta":null}},{"name":"LLVMBlockRefArray","instanceVariables":[],"methods":[],"meta":{"name":"LLVMBlockRefArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LLVMMetadataRefArray","instanceVariables":[],"methods":[],"meta":{"name":"LLVMMetadataRefArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"MyCompiledMethodForTesting","instanceVariables":[],"methods":[],"meta":{"name":"MyCompiledMethodForTesting class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Collection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":6,"sourceCode":"copyWith: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\r\t^ self copy\r\t\tadd: newElement;\r\t\tyourself"},{"name":"reject:thenCollect:","linesOfCode":3,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self reject: rejectBlock) collect: collectBlock"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"For collections we chose to write a list of elements as delivered by #do:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution\"\r\t\r\tstonWriter writeObject: self do: [\r\t\tstonWriter encodeList: self ]\r"},{"name":"collect:thenDo:","linesOfCode":4,"sourceCode":"collect: collectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\"\r\t\r\t^ self do: [ :each|\r\t\tdoBlock value: (collectBlock value: each)]"},{"name":"flatCollect:","linesOfCode":7,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t\"( #((3 4) (1 2)) flatCollect: [:each | each ] )>>> #(3 4 1 2)\"\r\t\"( #(3 4 1 2) flatCollect: [:each | { each } ] ) >>> #(3 4 1 2)\"\r\t\r\t^ self flatCollect: aBlock as: self species"},{"name":"cos","linesOfCode":2,"sourceCode":"cos\r\t^self collect: [:each | each cos]"},{"name":"removeFromMetacelloRepositories:","linesOfCode":2,"sourceCode":"removeFromMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"asCharacterSet","linesOfCode":4,"sourceCode":"asCharacterSet\r\t\"Answer a CharacterSet whose elements are the unique elements of the receiver.\r\tThe reciever should only contain characters.\"\r\r\t^ CharacterSet newFrom: self"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aCollection \r\t\"Include all the elements of aCollection as the receiver's elements. Answer \r\taCollection. Actually, any object responding to #do: can be used as argument.\"\r\r\taCollection do: [:each | self add: each].\r\t^ aCollection"},{"name":"removeAllFoundIn:","linesOfCode":6,"sourceCode":"removeAllFoundIn: aCollection \r\t\"Remove each element of aCollection which is present in the receiver \r\tfrom the receiver. Answer aCollection. No error is raised if an element\r\tisn't found. ArrayedCollections cannot respond to this message.\"\r\r\taCollection do: [:each | self remove: each ifAbsent: []].\r\t^ aCollection"},{"name":"-","linesOfCode":2,"sourceCode":"- arg\r\r\t^ arg adaptToCollection: self andSend: #-"},{"name":"asDraggableMorph","linesOfCode":5,"sourceCode":"asDraggableMorph\r\t^ (String streamContents: [ :s| \r\t\tself \r\t\t\tdo: [ :each | s print: each ]\r\t\t\tseparatedBy: [ s space ]]) asStringMorph"},{"name":"gtDebuggerSUnitPrint","linesOfCode":3,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ String streamContents: [ :s | \r\t\t  self asStringOn: s delimiter: String cr ]"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tself subclassResponsibility"},{"name":"raisedTo:","linesOfCode":2,"sourceCode":"raisedTo: arg\r\r\t^ arg adaptToCollection: self andSend: #raisedTo:"},{"name":"asOrderedCollection","linesOfCode":7,"sourceCode":"asOrderedCollection\r\t\"Answer an OrderedCollection whose elements are the elements of the\r\treceiver. The order in which elements are added depends on the order\r\tin which the receiver enumerates its elements. In the case of unordered\r\tcollections, the ordering is not necessarily the same for multiple \r\trequests for the conversion.\"\r\r\t^ self as: OrderedCollection"},{"name":"sum","linesOfCode":11,"sourceCode":"sum\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\tself emptyCheck.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [:accum :each | accum + each].\r\t^ sum - sample"},{"name":"gtInspectorInterestingObject","linesOfCode":4,"sourceCode":"gtInspectorInterestingObject\r\t^ self size = 1\r\t\tifTrue: [ self anyOne ]\r\t\tifFalse: [ self ]"},{"name":"copyWithoutDuplicates","linesOfCode":6,"sourceCode":"copyWithoutDuplicates\r\t\"Answer a copy of the receiver without any duplicated elements\"\r\t\"(#(2 3 4 4  5 6) copyWithoutDuplicates)  >>> #(2 3 4 5 6)\"\r\t\"(#('do' 'la' 'si' 'do' 'la') copyWithoutDuplicates) >>> #('la' 'do' 'si')\"\r\t\"(#(#do #la #si #do #la) copyWithoutDuplicates) >>> #(#la #do #si)\"\r\t^ self asSet asArray"},{"name":"//","linesOfCode":2,"sourceCode":"// arg\r\r\t^ arg adaptToCollection: self andSend: #//"},{"name":"copyWithout:","linesOfCode":6,"sourceCode":"copyWithout: oldElement \r\t\"Answer a copy of the receiver that does not contain any\r\telements equal to oldElement.\"\r\t\"('fred the bear' copyWithout: $e) >>> 'frd th bar'\"\r\t\"(#(2 3 4 5 5 6) copyWithout: 5) >>> #(2 3 4 6)\"\r\t\r\t\r\t^ self reject: [:each | each = oldElement]"},{"name":"floor","linesOfCode":2,"sourceCode":"floor\r\t^ self collect: [:a | a floor]"},{"name":"negated","linesOfCode":4,"sourceCode":"negated\r\t\"Negated value of all elements in the collection\"\r\t\"#(1 2 3) negated >>> #(-1 -2 -3)\"\r\t^ self collect: [:a | a negated]"},{"name":"do:separatedBy:","linesOfCode":12,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\"(String streamContents: [:s | #(1 2 3) do: [:each | s << each asString] separatedBy: [s << ', ']]) >>> '1, 2, 3'\"\r\r\t| beforeFirst | \r\tbeforeFirst := true.\r\tself do:\r\t\t[:each |\r\t\tbeforeFirst\r\t\t\tifTrue: [beforeFirst := false]\r\t\t\tifFalse: [separatorBlock value].\r\t\telementBlock value: each]"},{"name":"reject:thenDo:","linesOfCode":6,"sourceCode":"reject: rejectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\t\r\tself do: [ :each |\r\t\t(rejectBlock value: each)\r\t\t\tifFalse: [ doBlock value: each ] ]."},{"name":"collect:thenSelect:","linesOfCode":3,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) select: selectBlock"},{"name":"asStringOn:delimiter:","linesOfCode":6,"sourceCode":"asStringOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c'\r\tUses #asString instead of #print:.\"\r\r\tself do: [:elem | aStream nextPutAll: elem asString]\r\t\tseparatedBy: [aStream nextPutAll: delimString]"},{"name":"errorSizeMismatch","linesOfCode":3,"sourceCode":"errorSizeMismatch\r\t\"Signal a SizeMismatch exception\"\r\r\tSizeMismatch signal"},{"name":"asStringOn:delimiter:last:","linesOfCode":14,"sourceCode":"asStringOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'.\r\tUses #asString instead of #print:\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream nextPutAll: elem asString]\r\tseparatedBy: [\r\t\taStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":7,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\t\"Include anObject as one of the receiver's elements and then value aBlock, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) \r\t\tifFalse: [ self add: anObject ]\r\t\tifTrue: [ aBlock value ].\r\t^ anObject"},{"name":"averageIfEmpty:","linesOfCode":5,"sourceCode":"averageIfEmpty: aBlock \r\t\"This method return the average of the collection if it is not empty. In the other case,\r\tit return the value of the block. It means the user the user of this method decide of the return value. #() averageIfEmpty: [ 0 ]\"\r\tself ifEmpty: [ ^ aBlock value ].\r\t^ self average"},{"name":"difference:","linesOfCode":9,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important.\"\r\r\t\"(#(a b c d e f) difference:  #(a b z k))>>> #(#f #d #e #c)\"\r\r\t\"(#(a b z k) difference: #(a b c d e f)) >>> #(#k #z)\"\r\r\t| set |\r\tset := self asSet\r\t\tremoveAllFoundIn: aCollection;\r\t\tyourself.\r\t^ self species withAll: set asArray"},{"name":"adaptToCollection:andSend:","linesOfCode":7,"sourceCode":"adaptToCollection: rcvr andSend: selector\r\t\"If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t(rcvr isSequenceable and: [ self isSequenceable ]) ifFalse:\r\t\t[self error: 'Only sequenceable collections may be combined arithmetically'].\r\t^ rcvr with: self collect:\r\t\t[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]"},{"name":"includesAny:","linesOfCode":4,"sourceCode":"includesAny: aCollection \r\t\"Answer whether any element of aCollection is one of the receiver's elements.\"\r\taCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].\r\t^ false"},{"name":"inspectionItems:","linesOfCode":15,"sourceCode":"inspectionItems: aBuilder\r\t<inspectorPresentationOrder: 0 title: 'Items'> \r\t\r\t^ aBuilder newTable\t\t\r\t\taddColumn: (SpIndexTableColumn new \r\t\t\ttitle: 'Index';\r\t\t\tsortFunction: #yourself ascending;\r\t\t\tbeNotExpandable;\r\t\t\tyourself);\r\t\taddColumn: (SpStringTableColumn new  \r\t\t\ttitle: 'Value'; \r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each ];\r\t\t\tsortFunction: #printString ascending;\r\t\t\tyourself);\r\t\titems: self asOrderedCollection;\r\t\tyourself"},{"name":"flattened","linesOfCode":5,"sourceCode":"flattened\r\t\"Flattens a collection of collections (no matter how many levels of collections exist). Strings are considered atoms and, as such, won't be flattened\"\r\t\"( #(1 #(2 3) #(4 #(5))) flattened ) >>> #(1 2 3 4 5)\" \r\t\"( #('string1' #('string2' 'string3')) flattened ) >>> #('string1' 'string2' 'string3')\"\r\t\r\t^ Array streamContents: [ :stream | self flattenOn: stream]."},{"name":"max","linesOfCode":6,"sourceCode":"max\r\t\"Return the maximum value of the collection\r\t\r\tExample of use:\r\t#(1 5 10 -4) max >>> 10\r\t\"\r\t^ self inject: self anyOne into: [:max :each | max max: each]"},{"name":"detect:ifNone:","linesOfCode":5,"sourceCode":"detect: aBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the first element for which aBlock evaluates to true. If none  \r\tevaluate to true, then evaluate the argument, exceptionBlock.\"\r\r\t^ self detect: aBlock ifFound: [ :element | element ] ifNone: exceptionBlock"},{"name":"asCommaString","linesOfCode":5,"sourceCode":"asCommaString\r    \"Return collection printed as 'a, b, c' \"\r    \"#( 'a' 'b' 'c') asCommaString >>> 'a, b, c'\"\r    \r    ^String streamContents: [:s | self asStringOn: s delimiter: ', ']"},{"name":"remove:ifAbsent:","linesOfCode":7,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"Remove oldObject from the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject. ArrayedCollections cannot \r\trespond to this message.\"\r\r\tself subclassResponsibility"},{"name":"errorEmptyCollection","linesOfCode":3,"sourceCode":"errorEmptyCollection\r\t\"Signal a CollectionIsEmpty exception\"\r\r\tCollectionIsEmpty signalWith: self"},{"name":"removeFromMetacelloPackages:","linesOfCode":2,"sourceCode":"removeFromMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"min","linesOfCode":2,"sourceCode":"min\r\t^ self inject: self anyOne into: [:min :each | min min: each]"},{"name":"asGCoordinates","linesOfCode":2,"sourceCode":"asGCoordinates\r\t^ GCoordinates withCollection: self"},{"name":"tan","linesOfCode":2,"sourceCode":"tan\r\t^self collect: [:each | each tan]"},{"name":"gtCollectionSizeThreshold","linesOfCode":4,"sourceCode":"gtCollectionSizeThreshold\r\t\"Return the maximum collection size that GT supports while showing all elements.\r\tWhen this threshold is reached, we no longer show certain views that would take too much resources.\"\r\r\t^ 16rFFFF \"65535\""},{"name":"gather:","linesOfCode":3,"sourceCode":"gather: aBlock\r\t\"This method is kept for compatibility reasons, use flatCollect: instead.\"\r\t\r\t^ self flatCollect: aBlock."},{"name":"sign","linesOfCode":5,"sourceCode":"sign\r\t\"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.\"\r\t\"5 sign >>> 1\"\r\t\"-3 sign >>> -1\"\r\t^self collect: [:each | each sign]"},{"name":"printOn:delimiter:","linesOfCode":5,"sourceCode":"printOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c' \"\r\r\tself do: [:elem | aStream print: elem] separatedBy: [aStream nextPutAll: delimString]\r\t\t"},{"name":"isCollection","linesOfCode":3,"sourceCode":"isCollection\r\t\"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:\"\r\t^true"},{"name":"storeOn:","linesOfCode":16,"sourceCode":"storeOn: aStream \r\t\"Refer to the comment in Object|storeOn:.\"\r\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself do: \r\t\t[:each | \r\t\tnoneYet\r\t\t\tifTrue: [noneYet := false]\r\t\t\tifFalse: [aStream nextPut: $;].\r\t\taStream nextPutAll: ' add: '.\r\t\taStream store: each].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeCollection: self do: projectSpecBlock"},{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver, only those elements for which aBlock evaluates to true. Answer the new collection.\"\r\t\"(#(1 2 3 4 5) select: #even) >>> #(2 4)\"\r\t\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"do:without:","linesOfCode":4,"sourceCode":"do: aBlock without: anItem \r\t\"Enumerate all elements in the receiver. \r\tExecute aBlock for those elements that are not equal to the given item\"\r\r\t^ self do: [:each | anItem = each ifFalse: [aBlock value: each]]"},{"name":"arcTan","linesOfCode":2,"sourceCode":"arcTan\r\t^self collect: [:each | each arcTan]"},{"name":"detectSum:","linesOfCode":9,"sourceCode":"detectSum: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tReturn the sum of the answers.\"\r\t| sum |\r\tself deprecated: 'Use #sum: instead'.\r\tsum := 0.\r\tself do: [:each | \r\t\tsum := (aBlock value: each) + sum].  \r\t^ sum"},{"name":"sqrt","linesOfCode":2,"sourceCode":"sqrt\r\t^ self collect: [:each | each sqrt]"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\t\"The original code used #skip:, but some streams do not support that,\r\t and we don't really need it.\"\r\r\taStream nextPut: $(.\r\tself do: [:element | aStream print: element] separatedBy: [aStream space].\r\taStream nextPut: $)"},{"name":"printOn:delimiter:last:","linesOfCode":15,"sourceCode":"printOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream print: elem]\r\tseparatedBy: [\r\t\tn = sz\r\t\t\tifTrue: [aStream print: lastDelimString]\r\t\t\tifFalse: [aStream print: delimString]]"},{"name":"flatCollectAsSet:","linesOfCode":5,"sourceCode":"flatCollectAsSet: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t^ self flatCollect: aBlock as: Set"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\r\tself do: [ :each | each flattenOn: aStream ]"},{"name":"includesAllOf:","linesOfCode":5,"sourceCode":"includesAllOf: aCollection \r\r\tself\r\t\tdeprecated: 'Please use #includesAll: instead'\r\t\ttransformWith: '`@receiver includesAllOf: `@statements' -> '`@receiver includesAll: `@statements'.\r\t\r\t^ self includesAll: aCollection"},{"name":"asSet","linesOfCode":3,"sourceCode":"asSet\r\t\"Answer a Set whose elements are the unique elements of the receiver.\"\r\r\t^ Set withAll: self"},{"name":"addToMetacelloRepositories:","linesOfCode":2,"sourceCode":"addToMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:","linesOfCode":4,"sourceCode":"resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock\r    ^ aMetacelloMCVersion\r        allPackagesForSpecs: (self collect: [ :ea | aMetacelloMCVersion packageNamed: ea ifAbsent: aBlock ])\r        visited: visited"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new"},{"name":"sumNumbers","linesOfCode":9,"sourceCode":"sumNumbers\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. The receiver should include only numbers.\r\t\r\tDifferent from the sum implementation, the default value is zero. While sum is \r\tmore general, sumNumbers is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + each ]"},{"name":"ifNotEmpty:ifEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\r\t If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"addedToZnUrl:","linesOfCode":2,"sourceCode":"addedToZnUrl: url \r\t^ url withPathSegments: self"},{"name":"ln","linesOfCode":2,"sourceCode":"ln\r\t^self collect: [:each | each ln]"},{"name":"asOrderedDictionary","linesOfCode":2,"sourceCode":"asOrderedDictionary\r\r\t^ self as: OrderedDictionary"},{"name":"inject:into:","linesOfCode":7,"sourceCode":"inject: thisValue into: binaryBlock \r\t\"Accumulate a running value associated with evaluating the argument, binaryBlock, with the current value of the argument, thisValue, and the receiver as block arguments.\"\r\t\r\t\"( #(1 2 3) inject: 0 into: [ :sum :each | sum + each ] ) >>> 6\"\r\r\t| nextValue |\r\tnextValue := thisValue.\r\tself do: [:each | nextValue := binaryBlock value: nextValue value: each].\r\t^nextValue"},{"name":"capacity","linesOfCode":3,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t^ self size"},{"name":"squared","linesOfCode":2,"sourceCode":"squared\r\t^ self collect: [:each | each * each]"},{"name":"reduce:","linesOfCode":6,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\t\"( #(1 2 3) asSet reduce: [ :a :b | a + b ] ) >>> 1 + 2 + 3\"\r\t\"( #(1 2 3 4 5) asSet reduce: [ :a :b :c | a + b + c ] ) >>> 1 + 2 + 3 + 4 + 5\"\r\t\t\r\t^self asOrderedCollection reduce: aBlock"},{"name":"removeAll:","linesOfCode":7,"sourceCode":"removeAll: aCollection \r\t\"Remove each element of aCollection from the receiver. If successful for \r\teach, answer aCollection. Otherwise create an error notification.\r\tArrayedCollections cannot respond to this message.\"\r\r\taCollection == self ifTrue: [^self removeAll].\r\taCollection do: [:each | self remove: each].\r\t^ aCollection"},{"name":"gtInspectorItemsIn:","linesOfCode":18,"sourceCode":"gtInspectorItemsIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\t^ composite fastList\r\t\ttitle: 'Items';\r\t\tdisplay: [ \"The FastTable renderer needs to access elements by index so we transform\r\t\t\tthe collection to an OrderedCollection. Subclasses can override the #display\r\t\t\tblock to provide a different behaviour. The previous renderer had this behaviour\r\t\t\timplemented in the renderer.\" self asOrderedCollection ];\r\t\tbeMultiple;\r\t\tformat: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\t\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult\r\t\t\t\tifNotNil: [ result size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] ] ]"},{"name":"doWithIndex:","linesOfCode":6,"sourceCode":"doWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\r\t\r\tExample of use:\r\t(#('hello' 'world' 'bonjour') doWithIndex: [ :element :index |  ])\r\t\"\r\r\t^ self withIndexDo: elementAndIndexBlock"},{"name":"collectAll:","linesOfCode":8,"sourceCode":"collectAll: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect all the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection addAll: (aBlock value: each)].\r\t^ newCollection"},{"name":"atRandom","linesOfCode":11,"sourceCode":"atRandom\r\t\"Answer a random element of the receiver.  Uses a shared random \r\tnumber generator owned by class Collection.  If you use this a lot, \r\tdefine your own instance of Random and use #atRandom:.  Causes \r\tan error if self has no elements.\"\r\r\t^ self atRandom: SharedRandom globalGenerator.\r\r\"Examples:\r\t#('one' 'or' 'the' 'other') atRandom\r\t(1 to: 10) atRandom\r\t'Just pick one of these letters at random' atRandom\r\t#(3 7 4 9 21) asSet atRandom\t\t(just to show it also works for Sets)\r\""},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted\"\r\t\r\t^self asArray sorted"},{"name":"detect:ifFound:","linesOfCode":14,"sourceCode":"detect: aBlock ifFound: foundBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock. \r\tIf no element matches the criteria then do nothing.\r\tAlways returns self to avoid misuse and a potential isNil check on the sender.\"\r\t\"(#(1 2) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> 'yay'\"\r\t\"(#(1 3) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> #(1 3)\"\r\r\tself\r\t\tdetect: aBlock\r\t\tifFound: foundBlock\r\t\tifNone: [ \r\t\t\t\"Do nothing on purpose\"\r\t\t\t ]"},{"name":"rounded","linesOfCode":2,"sourceCode":"rounded\r\t^ self collect: [:a | a rounded]"},{"name":"anyOne","linesOfCode":8,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t\r\tself emptyCheck.\r\tself do: [:each | ^ each]"},{"name":"add:","linesOfCode":4,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject. \r\tArrayedCollections cannot respond to this message.\"\r\r\tself subclassResponsibility"},{"name":",","linesOfCode":4,"sourceCode":", aCollection\r\t\"Concatenate the receiver with the argument.\"\r\t\"#(1 2 3) , #(4 5 6) >>> #(1 2 3 4 5 6)\"\r\t\r\t^self copy addAll: aCollection; yourself"},{"name":"stdev","linesOfCode":9,"sourceCode":"stdev\r\t| avg sample sum |\r\t\"In statistics, the standard deviation is a measure that is used to quantify the amount of variation or dispersion of a set of data values.\r\tFor details about implementation see comment in self sum.\"\r\tavg := self average.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [ :accum :each | accum + (each - avg) squared ].\r\tsum := sum - sample.\r\t^ (sum / (self size - 1)) sqrt"},{"name":"asSortedCollection:","linesOfCode":7,"sourceCode":"asSortedCollection: aSortBlock \r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is defined by the argument, aSortBlock. Note that it is better to use #sorted: if you don't really need a SortedCollection, but a sorted collection!!\"\r\r\t| aSortedCollection |\r\taSortedCollection := SortedCollection new: self size.\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"detect:ifFound:ifNone:","linesOfCode":10,"sourceCode":"detect: aBlock ifFound: foundBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock and answer the result of this evaluation. \r\tIf none evaluate to true, then evaluate exceptionBlock.\"\r\r\tself\r\t\tdo: [ :each | \r\t\t\t(aBlock value: each)\r\t\t\t\tifTrue: [ ^ foundBlock cull: each ] ].\r\t^ exceptionBlock value\t"},{"name":"recordRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"recordRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doRecordRequiredFromArray: self."},{"name":"sin","linesOfCode":2,"sourceCode":"sin\r\t^self collect: [:each | each sin]"},{"name":"notEmpty","linesOfCode":4,"sourceCode":"notEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\t\"use isNotEmpty for consistency with isEmpty\"\r\r\t^ self isEmpty not"},{"name":"mergeIntoMetacelloPackages:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"loadRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"loadRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doLoadRequiredFromArray: self."},{"name":"allSatisfy:","linesOfCode":8,"sourceCode":"allSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns false for any element return false.\r\tOtherwise return true.\"\r\t\"#(1 2) allSatisfy: [ :each | each even ] >>> false\"\r\t\"#(2 4) allSatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifFalse: [^ false]].\r\t^ true"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self asArray"},{"name":"removeAll","linesOfCode":7,"sourceCode":"removeAll\r\t\"Remove each element from the receiver and leave it empty.\r\tArrayedCollections cannot respond to this message.\r\tThere are two good reasons why a subclass should override this message:\r\t1) the subclass does not support being modified while being iterated\r\t2) the subclass provides a much faster way than iterating through each element\"\r\r\tself do: [:each | self remove: each]."},{"name":"setRequiresInMetacelloPackage:","linesOfCode":2,"sourceCode":"setRequiresInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setRequires: self asArray."},{"name":"sumNumbers:","linesOfCode":10,"sourceCode":"sumNumbers: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. aBlock is expected to return a number\r\tfor every element in the collection.\r\t\r\tDifferent from the sum: implementation, the default value is zero. While sum: is \r\tmore general, sumNumbers: is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + (aBlock value: each) ]"},{"name":"do:displayingProgress:every:","linesOfCode":33,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock every: msecs\r\t\"Enumerate aBlock displaying progress information.\r \t If the argument is a string, use a static label for the process.\r\t If the argument is a block, evaluate it with the element to retrieve the label.\r \t The msecs argument ensures that updates happen at most every msecs.\r       Example:\r               Smalltalk allClasses\r                       do:[:aClass| (Delay forMilliseconds: 1) wait]\r                       displayingProgress:[:aClass| 'Processing ', aClass name]\r                       every: 0.\"\r\r\t| size labelBlock count oldLabel lastUpdate |\r\tself isEmpty ifTrue: [ ^ self ].\r\toldLabel := nil.\r\tcount := lastUpdate := 0.\r\tsize := self size.\r\t'' displayProgressFrom: 0 to: size during: [:bar |\r\t\tlabelBlock := aStringOrBlock isString\r\t\t\tifTrue: [\r\t\t\t\tbar label: aStringOrBlock.\r\t\t\t\t[ :dummyItem | aStringOrBlock] ]\r\t\t\tifFalse: [ aStringOrBlock ].\r\r\t\tself do: [ :each | | newLabel |\r\t\t\t\"Special handling for first and last element\"\r\t\t\t(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) \r\t\t\t\tifTrue: [ \r\t\t\t\t\tbar current: count.\r\t\t\t\t\toldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) \r\t\t\t\t\t\tifFalse: [\r\t\t\t\t\t\t\tbar label: newLabel.\r\t\t\t\t\t\t\toldLabel := newLabel ].\r\t\t\t\tlastUpdate := Time millisecondClockValue ].\r\t\t\taBlock value: each.\r\t\t\tcount := count + 1 ] ]"},{"name":"contents","linesOfCode":2,"sourceCode":"contents\r\t^ self"},{"name":"addIfNotPresent:","linesOfCode":5,"sourceCode":"addIfNotPresent: anObject\r\t\"Include anObject as one of the receiver's elements, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) ifFalse: [self add: anObject].\r\t^ anObject"},{"name":"asSequenceParser","linesOfCode":2,"sourceCode":"asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"fold:","linesOfCode":4,"sourceCode":"fold: binaryBlock\r\t\"Evaluate the block with the first two elements of the receiver, then with the result of the first evaluation and the next element, and so on.  Answer the result of the final evaluation. If the receiver is empty, raise an error. If the receiver has a single element, answer that element.\"\r\t\"( #('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b] ) >>> 'if it is to be it is up to me'\"\r\r\t^self reduce: binaryBlock"},{"name":"roundTo:","linesOfCode":2,"sourceCode":"roundTo: quantum\r\t^self collect: [ :ea | ea roundTo: quantum ]"},{"name":"asChoiceParser","linesOfCode":2,"sourceCode":"asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"anySatisfy:","linesOfCode":8,"sourceCode":"anySatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns true for any element return true.\r\tOtherwise return false.\"\r\t\"#(1 3) anySatisfy: [ :each | each even ] >>> false\"\r\t\"#(1 2) anySatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [^ true]].\r\t^ false"},{"name":"selectEveryFirst","linesOfCode":5,"sourceCode":"selectEveryFirst\r\t\"#(1 2 3 4) selectEveryFirst asArray \r\t>>> #(1 3)\r\t\"\r\t^ self selectEvery: [ :i | (i+1 \\\\ 2) = 0 ]"},{"name":"findFirstInByteString:startingAt:","linesOfCode":8,"sourceCode":"findFirstInByteString: aByteString startingAt: start\r\t\"Find the index of first character starting at start in aByteString that is included in the receiver.\r\tDefault is to use a naive algorithm.\r\tSubclasses might want to implement a more efficient scheme\"\r\r\tstart to: aByteString size do:\r\t\t[:index |\r\t\t(self includes: (aByteString at: index)) ifTrue: [^ index]].\r\t^ 0"},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\r\t^self size = 0"},{"name":"asParser","linesOfCode":12,"sourceCode":"asParser    \r\t\"Create a range of characters between start and stop.\"\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.\r\t].\r\r\r\t^ super asParser\r\t\"\r\t\t($a to:$f) asParser parse:'a'\r\t\t($a to:$f) asParser parse:'g'\r\t\"\r"},{"name":"arcSin","linesOfCode":2,"sourceCode":"arcSin\r\t^self collect: [:each | each arcSin]"},{"name":"emptyCheck","linesOfCode":2,"sourceCode":"emptyCheck\r\r\tself isEmpty ifTrue: [self errorEmptyCollection]"},{"name":"occurrencesOf:","linesOfCode":6,"sourceCode":"occurrencesOf: anObject \r\t\"Answer how many of the receiver's elements are equal to anObject.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | anObject = each ifTrue: [tally := tally + 1]].\r\t^tally"},{"name":"union:","linesOfCode":6,"sourceCode":"union: aCollection\r\t\"Answer the set theoretic union of two collections.\"\r\t\"(#(1 2 3) union: #(4 5 6 2)) >>> #(1 2 3 4 5 6)\"\r\t\r\t| set |\r\tset := self asSet addAll: aCollection; yourself.\r\t^ self species withAll: set asArray"},{"name":"unzip","linesOfCode":18,"sourceCode":"unzip\r\t\"Given a collection returns in one pass two collections containing each odd and even elements in respective subcollections\"\r\t\"\r\t#(1 2 3 4) unzip first asArray \r\t>>> #(1 3)\r\t#(1 2 3 4) unzip second asArray \r\t>>> #(2 4)\r\t\"\r\t\r\t| odd even s |\r\ts := self size // 2.\r\todd := OrderedCollection new: s.\r\teven := OrderedCollection new: s.\r\t1 \r\t\tto: self size \r\t\tdo: [ :i | (i \\\\ 2) = 0\t\r\t\t\t\t\t\tifTrue: [ even add: (self at: i) ]\r\t\t\t\t\t\tifFalse: [ odd add: (self at: i) ] ].\r\t^ { odd . even }"},{"name":"fetchRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doFetchRequiredFromArray: self."},{"name":"collect:as:","linesOfCode":4,"sourceCode":"collect: aBlock as: aClass\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into an instance of aClass. Answer the resulting collection.\"\r\r\t^(aClass new: self size) fillFrom: self with: aBlock"},{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ MetacelloMethodSectionPath withAll: self"},{"name":"reject:","linesOfCode":4,"sourceCode":"reject: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver only those elements for which aBlock evaluates to false. Answer the new collection.\"\r\t\"#(1 2 3 4 5) reject: #even >>>  #(1 3 5)\"\r\r\t^ self select: [ :element | (aBlock value: element) == false ]"},{"name":"|","linesOfCode":4,"sourceCode":"| aCollection\r\t\"Return all the elements that appear in self or in aCollection\"\r\t\"'abc' | 'cbe' >>> 'bcea'\"\r\t\r\t^ self union: aCollection"},{"name":"degreeCos","linesOfCode":2,"sourceCode":"degreeCos\r\t^self collect: [:each | each degreeCos]"},{"name":"noneSatisfy:","linesOfCode":4,"sourceCode":"noneSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver. If aBlock returns false for all elements return true. Otherwise return false\"\r\r\tself do: [:item | (aBlock value: item) ifTrue: [^ false]].\r\t^ true"},{"name":"addToMetacelloPackages:","linesOfCode":2,"sourceCode":"addToMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"asDictionary","linesOfCode":2,"sourceCode":"asDictionary\r\r\t^ self as: Dictionary"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream \r\t\"Append a sequence of characters that identify the receiver to aStream.\"\r\r\tself printNameOn: aStream.\r\tself printElementsOn: aStream"},{"name":"nodesDo:","linesOfCode":2,"sourceCode":"nodesDo: aBlock\r\tself do: aBlock"},{"name":"fillFrom:with:","linesOfCode":5,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\taCollection do: [ :each |\r\t\tself add: (aBlock value: each) ]"},{"name":"isNotEmpty","linesOfCode":7,"sourceCode":"isNotEmpty\r\t\"Answer whether the receiver contains any elements.\r\t\r\tExample of use:\r\t\r\t#() isNotEmpty >>> false\r\t#(1 2 3) isNotEmpty >>> true\r\t\"\r\r\t^ self isEmpty not"},{"name":"setIncludesInMetacelloPackage:","linesOfCode":2,"sourceCode":"setIncludesInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setIncludes: self asArray."},{"name":"asGVector","linesOfCode":2,"sourceCode":"asGVector\r\t^ GVector withCollection: self"},{"name":"asCommaStringAnd","linesOfCode":4,"sourceCode":"asCommaStringAnd\r\t\"Return collection printed as 'a, b and c' \"\r\t\"#( 'a' 'b' 'c') asCommaStringAnd >>> 'a, b and c'\"\r\r\t^String streamContents: [:s | self asStringOn: s delimiter: ', ' last: ' and ']"},{"name":"printNameOn:","linesOfCode":2,"sourceCode":"printNameOn: aStream\r\tsuper printOn: aStream"},{"name":"includesAll:","linesOfCode":4,"sourceCode":"includesAll: aCollection \r\t\"Answer whether all the elements of aCollection are in the receiver.\"\r\taCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].\r\t^ true"},{"name":"arcCos","linesOfCode":2,"sourceCode":"arcCos\r\t^self collect: [:each | each arcCos]"},{"name":"select:thenCollect:","linesOfCode":3,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self select: selectBlock) collect: collectBlock"},{"name":"&","linesOfCode":3,"sourceCode":"& aCollection\r\t\"#(1 2 3 4) & #(1 2 4 6 7) >>> #(1 2 4)\"\r\t\r\t^ self intersection: aCollection"},{"name":"detectMin:","linesOfCode":21,"sourceCode":"detectMin: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the lowest number.\r\tIf collection empty, return nil.\r\t\r\tExample of use:\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p x ]) >>> (-4@6)\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p y ]) >>> (10@ -3)\r\t\"\r\r\t| minElement minValue |\r\tself do: [:each | | val | \r\t\tminValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) < minValue ifTrue: [\r\t\t\t\t\tminElement := each.\r\t\t\t\t\tminValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tminElement := each.\r\t\t\t\tminValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ minElement"},{"name":"selectEvery:","linesOfCode":7,"sourceCode":"selectEvery: aBlock\r\t\"Select elements of the receiver whose index satisfy the argument. Look at selectEveryFirst and selectEverySecond for examples.\"\r\t\r\t| res |\r\tres := OrderedCollection new.\r\t1 to: self size do: [ :i | (aBlock value: i) \r\t\t\t\t\t\t\t\t\t\t\tifTrue: [res add: (self at: i) ]].\r\t^ res"},{"name":"sum:ifEmpty:","linesOfCode":14,"sourceCode":"sum: aBlock ifEmpty: anEmptySumBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\t^ self\r\t\tifNotEmpty: [ \r\t\t\tsample := aBlock value: self anyOne.\r\t\t\tsum := self inject: sample into: [ :previousValue :each |\r\t\t\t\tpreviousValue + (aBlock value: each) ].\r\t\t\tsum - sample ]\r\t\tifEmpty: anEmptySumBlock."},{"name":"range","linesOfCode":4,"sourceCode":"range\r\t\"returns the difference between the max and min element, their positions notwithstanding\"\r\t\"#( 1 51 10 ) range >>> 50\"\r\t^ self max - self min"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).  If any non-association is within, the error is not caught now,\r\tbut later, when a key or value message is sent to it.\"\r\r\tself do: aBlock"},{"name":"gtInspectorHash","linesOfCode":2,"sourceCode":"gtInspectorHash\r\r\t^ super gtInspectorHash bitXor: self size hash"},{"name":"flatCollect:as:","linesOfCode":8,"sourceCode":"flatCollect: aBlock as: aCollectionClass\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\r\t| col |\r\tcol := OrderedCollection new: self size.\r\tself do: [ :each | col addAll: (aBlock value: each) ].\r\t^ aCollectionClass withAll: col "},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: oldObject \r\t\"Remove oldObject from the receiver's elements. Answer oldObject \r\tunless no element is equal to oldObject, in which case, raise an error.\r\tArrayedCollections cannot respond to this message.\"\r\r\t^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]"},{"name":"asBag","linesOfCode":3,"sourceCode":"asBag\r\t\"Answer a Bag whose elements are the elements of the receiver.\"\r\r\t^ Bag withAll: self"},{"name":"do:displayingProgress:","linesOfCode":12,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock\r\t\"Enumerate aBlock displaying progress information. \r \t If the argument is a string, use a static label for the process. \r\t If the argument is a block, evaluate it with the element to retrieve the label.\r\t\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress: 'Processing...'.\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress:[:aClass| 'Processing ', aClass name].\r\t\"\r\t^self do: aBlock displayingProgress: aStringOrBlock every: 20"},{"name":"/","linesOfCode":2,"sourceCode":"/ arg\r\r\t^ arg adaptToCollection: self andSend: #/"},{"name":"gtIterator","linesOfCode":2,"sourceCode":"gtIterator\r\t^ [ :filter | self do: filter ] gtIterator"},{"name":"asShortcut","linesOfCode":2,"sourceCode":"asShortcut\r\t^ self asKeyCombination"},{"name":"asRWElementList","linesOfCode":2,"sourceCode":"asRWElementList\r\t^ RWElementList withAll: self"},{"name":"ifNotEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: aBlock\r\t\"Evaluate the given block with the receiver as argument, answering its value\r    unless the receiver is empty, in which case answer the receiver.\"\r\r\t^ self isEmpty\r\t\tifTrue: [ self ]\r\t\tifFalse: [ aBlock cull: self ]"},{"name":"ifEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: aBlock\r\t\"Evaluate the given block, answering its value if the receiver is empty, otherwise answer the receiver.\"\r\r\t\"Note that the fact that this method returns its receiver in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])\"\r\r\t^ self isEmpty\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ self ]"},{"name":"adaptToNumber:andSend:","linesOfCode":4,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"collect:into:","linesOfCode":4,"sourceCode":"collect: aBlock into: aCollection\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into aCollection. Answer aCollection.\"\r\r\t^aCollection fillFrom: self with: aBlock"},{"name":"ceiling","linesOfCode":2,"sourceCode":"ceiling\r\t^ self collect: [:a | a ceiling]"},{"name":"asSortedCollection","linesOfCode":3,"sourceCode":"asSortedCollection\r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is the default less than or equal. Note that you should use #sorted: if you don't really need a SortedCollection, but a sorted collection.\"\r\r\t^ self as: SortedCollection"},{"name":"collect:thenReject:","linesOfCode":3,"sourceCode":"collect: collectBlock thenReject: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) reject: selectBlock"},{"name":"count:","linesOfCode":8,"sourceCode":"count: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the number of elements that answered true.\"\r\t\"#(1 2 3 4) count: [ :each | each even ] >>> true\"\r\r\t| sum |\r\tsum := 0.\r\tself do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].\r\t^ sum"},{"name":"\\\\","linesOfCode":2,"sourceCode":"\\\\ arg\r\r\t^ arg adaptToCollection: self andSend: #\\\\"},{"name":"asKeyCombination","linesOfCode":6,"sourceCode":"asKeyCombination\r\t| shortcut |\r\tself size = 1 ifTrue: [ ^self first asKeyCombination ].\r\r\tshortcut := KMKeyCombinationSequence new.\r\tself do: [ :each | shortcut addShortcut: each asKeyCombination ].\r\t^shortcut."},{"name":"copyWithoutAll:","linesOfCode":4,"sourceCode":"copyWithoutAll: aCollection\r\t\"Answer a copy of the receiver that does not contain any elements \r\tequal to those in aCollection.\"\r\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"exp","linesOfCode":2,"sourceCode":"exp\r\t^self collect: [:each | each exp]"},{"name":"sum:","linesOfCode":7,"sourceCode":"sum: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t^ self sum: aBlock ifEmpty: [ 0 ]"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ self anySatisfy: [:each | each = anObject]"},{"name":"intersection:","linesOfCode":6,"sourceCode":"intersection: aCollection\r\t\"Answer the set theoretic intersection of two collections.\"\r\r\t\"(#(1 2 3 4) intersection: #(3 4 5)) >>> #(3 4)\"\r\r\t\"(#(1 2 3 4) intersection: #()) >>> #()\"\r\r\t\"(#() intersection: #(1 2 3 4)) >>> #()\"\r\r\t^ self species withAll: (self asSet intersection: aCollection) asArray"},{"name":"collect:","linesOfCode":8,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection add: (aBlock value: each)].\r\t^ newCollection"},{"name":"removeAllSuchThat:","linesOfCode":5,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  Use a copy to enumerate \r\tcollections whose order changes when an element is removed (i.e. Sets).\"\r\r\tself copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"asArray","linesOfCode":10,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''Array withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| newArray index |\r\tnewArray := Array new: self size.\r\tindex := 0.\r\tself do: [:each | newArray at: (index := index + 1) put: each].\r\t^ newArray"},{"name":"groupedBy:","linesOfCode":13,"sourceCode":"groupedBy: aBlock\r\t\"Answer a dictionary whose keys are the result of evaluating aBlock for all my elements, and the value for each key is the selection of my elements that evaluated to that key. Uses species.\r\t\r\tExample of use:\r\t(#(1 2 3 4 5) groupedBy: [ :v | v odd ]) asString >>> 'an OrderedDictionary(true->#(1 3 5) false->#(2 4))'\r\t\"\r\t\r\t\r\t\r\t| groups |\r\tgroups := OrderedDictionary new.\r\tself do: [ :each |\r\t\t(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].\r\tself species ~~ OrderedCollection ifTrue: [\r\t\tgroups associationsDo: [ :association |\r\t\t\tassociation value: (self species withAll: association value) ]].\r\t^ groups\r"},{"name":"ifEmpty:ifNotEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\"\r\t\"If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"spotterItemsFor:","linesOfCode":14,"sourceCode":"spotterItemsFor: aStep\r\t<spotterOrder: 10>\r\t| processor |\r\t(self isEmpty or: [ self size > self gtCollectionSizeThreshold ]) ifTrue: [ ^ self ].\r\tprocessor := aStep previousProcessorFrom: self.\r\t^ aStep listProcessor\r\t\ttitle: processor title;\r\t\tcandidatesLimit: 100;\r\t\titems: [ self collect: [ :each | each asSpotterCandidateLink value] as: OrderedCollection ];\r\t\titemName: processor itemName;\r\t\titemIcon: processor itemIcon;\r\t\tactLogic: processor actLogic; \r\t\tfilter: processor filter gtListFilter;\r\t\twantsToDisplayOnEmptyQuery: true"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBlock thenDo: doBlock\r    \"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\r    self do: [: each |\r        ( selectBlock value: each ) \r\t\t\tifTrue: [ doBlock value: each ]\r    ]."},{"name":"selectEverySecond","linesOfCode":5,"sourceCode":"selectEverySecond\r\t\"#(1 2 3 4) selectEverySecond asArray \r\t>>> #(2 4)\r\t\"\r\t^ self selectEvery: [ :i | i \\\\ 2 = 0 ]"},{"name":"asGPoint","linesOfCode":2,"sourceCode":"asGPoint\r\t^ GPoint withCollection: self"},{"name":"degreeSin","linesOfCode":2,"sourceCode":"degreeSin\r\t^self collect: [:each | each degreeSin]"},{"name":"isEmptyOrNil","linesOfCode":3,"sourceCode":"isEmptyOrNil\r\t\"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil\"\r\r\t^ self isEmpty"},{"name":"maxValue:","linesOfCode":2,"sourceCode":"maxValue: aBlock\r\t^ self inject: (aBlock value: self anyOne) into: [ :max :each | max max: (aBlock value: each) ]"},{"name":"atRandom:","linesOfCode":9,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\r    should be kept by the user in a variable and used every time. Use\r    this instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\t| rand |\r\r\tself emptyCheck.\r\trand := aGenerator nextInteger: self size.\r\tself withIndexDo: [:each :index | index = rand ifTrue: [^each]]"},{"name":"identityIncludes:","linesOfCode":4,"sourceCode":"identityIncludes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\tself do: [:each | anObject == each ifTrue: [^true]].\r\t^false"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeList: self"},{"name":"asWBTVarSubstitution","linesOfCode":8,"sourceCode":"asWBTVarSubstitution\r\tself ifEmpty: [ ^ '' ].\r\t\r\t^ ByteString streamContents: [ :out |\r\t\tself doWithIndex: [ :each :index |\r\t\t\tindex > 1 ifTrue: [ out space ].\r\t\t\tout nextPutAll: each asWBTVarSubstitution\r\t\t]\r\t]"},{"name":"copyWithDependent:","linesOfCode":4,"sourceCode":"copyWithDependent: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\t^self copyWith: newElement"},{"name":"withIndexDo:","linesOfCode":6,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\t\"Support collection enumeration with a counter, even though not ordered\"\r\t| index |\r\tindex := 0.\r\tself do: [:item | elementAndIndexBlock value: item value: (index := index+1)]"},{"name":"addAssignToFloatArray:","linesOfCode":3,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t1 to: aFloatArray size do: [ :i | aFloatArray at: i put: (aFloatArray at: i) + (self at: i) ].\r\t^ aFloatArray"},{"name":"truncated","linesOfCode":2,"sourceCode":"truncated\r\t^ self collect: [:a | a truncated]"},{"name":"setImportInVersionSpec:","linesOfCode":2,"sourceCode":"setImportInVersionSpec: aMetacelloVersionSpec\r  aMetacelloVersionSpec setImport: self asArray"},{"name":"asByteArray","linesOfCode":10,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''ByteArray withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| array index |\r\tarray := ByteArray new: self size.\r\tindex := 0.\r\tself do: [:each | array at: (index := index + 1) put: each].\r\t^ array"},{"name":"write:","linesOfCode":6,"sourceCode":"write: anObject\r\r\tself\r\t\tdeprecated: 'Please use #add: instead'\r\t\ttransformWith: '`@receiver write: `@statements1' \r\t\t\t\t\t\t-> '`@receiver add: `@statements1'.\r\t^ self add: anObject"},{"name":"add:withOccurrences:","linesOfCode":4,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add newObject anInteger times to the receiver. Answer newObject.\"\r\r\tanInteger timesRepeat: [self add: newObject].\r\t^ newObject"},{"name":"contains:","linesOfCode":3,"sourceCode":"contains: aBlock\r\t\"For compatibility, please use #anySatisfy: instead!\"\r\t^self anySatisfy: aBlock"},{"name":"*","linesOfCode":2,"sourceCode":"* arg\r\r\t^ arg adaptToCollection: self andSend: #*"},{"name":"log","linesOfCode":2,"sourceCode":"log\r\t^ self collect: [:each | each log]"},{"name":"setForDo:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self do: aBlock"},{"name":"asEmailHeaderString","linesOfCode":5,"sourceCode":"asEmailHeaderString\r\r\t^ String streamContents: [ :str | \r\t\t\tself\r\t\t\t\tdo: [ :e | str nextPutAll: e asEmailHeaderString ]\r\t\t\t\tseparatedBy: [ str nextPutAll: ', ' ] ]"},{"name":"gtDisplayOn:","linesOfCode":11,"sourceCode":"gtDisplayOn: stream\r\tself printNameOn: stream.\r\tstream\r\t\tspace;\r\t\tnextPut: $[;\r\t\tprint: self size;\r\t\tnextPutAll: (' item' asPluralBasedOn: self size);\r\t\tnextPut: $];\r\t\tspace.\r\tself size <= self gtCollectionSizeThreshold \r\t\tifTrue: [ self printElementsOn: stream ]"},{"name":"adaptToPoint:andSend:","linesOfCode":4,"sourceCode":"adaptToPoint: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"groupedBy:having:","linesOfCode":5,"sourceCode":"groupedBy: aBlock having: aSelectionBlock\r\t\"Like in SQL operation - Split the recievers contents into collections of \r\telements for which keyBlock returns the same results, and return those \r\tcollections allowed by selectBlock.\"\r\t^ (self groupedBy: aBlock) select: aSelectionBlock\r"},{"name":"hash","linesOfCode":9,"sourceCode":"hash\r\t\"Answer an integer hash value for the receiver such that,\r\t  -- the hash value of an unchanged object is constant over time, and\r\t  -- two equal objects have equal hash values\"\r\r\t| hash |\r\r\thash := self species hash.\r\tself size <= 10 ifTrue:\r\t\t[self do: [:elem | hash := hash bitXor: elem hash]].\r\t^hash bitXor: self size hash"},{"name":"reciprocal","linesOfCode":4,"sourceCode":"reciprocal\r\t\"Return the reciever full of reciprocated elements\"\r\t\"#(1 11 0.5) reciprocal >>> {1 . 1/11 . 2.0}\"\r\t^ self collect: [:a | a reciprocal]"},{"name":"mergeIntoMetacelloRepositories:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"detect:","linesOfCode":5,"sourceCode":"detect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the first element for which aBlock evaluates to true.\"\r\t\"(#(1 2 3 4) detect: [ :each | each even ]) >>> 2\"\r\r\t^ self detect: aBlock ifNone: [self errorNotFound: aBlock]"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ false"},{"name":"errorNotFound:","linesOfCode":3,"sourceCode":"errorNotFound: anObject\r\t\"Raise a NotFound exception.\"\r\r\tNotFound signalFor: anObject"},{"name":"average","linesOfCode":7,"sourceCode":"average\r\t\"Calculate the average of a collection, return a CollectionIsEmpty exception if the collection is empty. Look averageIfEmpty: aBlock\"\r\t\r\t\" #(2 6 7) average   \r\t>>> 5 \"\r\t\r\t\" #(3 5 7 7) average \r\t>>> (11/2) \"\r\r\t^ self sum / self size"},{"name":"+","linesOfCode":2,"sourceCode":"+ arg\r\r\t^ arg adaptToCollection: self andSend: #+"},{"name":"abs","linesOfCode":3,"sourceCode":"abs\r\t\"Absolute value of all elements in the collection\"\r\t^ self collect: [:a | a abs]"},{"name":"includesSubstringAnywhere:","linesOfCode":12,"sourceCode":"includesSubstringAnywhere: testString\r\t\"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring\"\r\tself do:\r\t\t[:element |\r\t\t\t(element isString)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstring: testString) ifTrue: [^ true]].\r\t\t\t(element isCollection)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].\r\t^ false\r\r\"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'\""},{"name":"\\","linesOfCode":4,"sourceCode":"\\ aCollection\r\t\"Return all the elements in self that are not in aCollection\"\r\t\"'abc' \\ 'cbe' >>> 'a'.\"\r\t\r\t^ self difference: aCollection"},{"name":"setForVersion:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForVersion: aString withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self version: aString"},{"name":"asMetacelloAttributeList","linesOfCode":2,"sourceCode":"asMetacelloAttributeList\r    ^ self"},{"name":"detectMax:","linesOfCode":17,"sourceCode":"detectMax: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the highest magnitude.\r\tIf collection empty, return nil.  This method might also be called elect:.\"\r\r\t| maxElement maxValue |\r\tself do: [:each | | val | \r\t\tmaxValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) > maxValue ifTrue: [\r\t\t\t\t\tmaxElement := each.\r\t\t\t\t\tmaxValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tmaxElement := each.\r\t\t\t\tmaxValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ maxElement"},{"name":"median","linesOfCode":8,"sourceCode":"median\r\t\"Return the middle element, or as close as we can get.\r\t\r\tExample of use:\r\t{1 . 2 . 3 . 4 . 5} median >>> 3\r\t{1 . 2 . 4 . 5} median >>> 3\r\t{1 . 2 . 5 . 5} median >>> (7/2)\r\t\"\r\t\r\t^ self asSortedCollection median"},{"name":"--","linesOfCode":2,"sourceCode":"-- other\r\t^ self , other"},{"name":"setLoadsInMetacelloProject:","linesOfCode":2,"sourceCode":"setLoadsInMetacelloProject: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setLoads: self asArray."},{"name":"includesAnyOf:","linesOfCode":3,"sourceCode":"includesAnyOf: aCollection \r\t\r\tself flag: 'use includesAny: instead'.\r\t\r\t^ self includesAny: aCollection.\r\t"},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^(IdentitySet new: self size) addAll: self; yourself"}],"meta":{"name":"Collection class","instanceVariables":[],"methods":[{"name":"with:with:with:with:with:with:","linesOfCode":10,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t\"Answer an instance of me, containing the six arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tadd: sixthObject;\r\t\tyourself"},{"name":"with:with:with:with:","linesOfCode":8,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t\"Answer an instance of me, containing the four arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tyourself"},{"name":"fromSton:","linesOfCode":9,"sourceCode":"fromSton: stonReader\r\t\"For collections we chose to instanciate based a list of elements using #add:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution.\"\r\t\r\t| collection |\r\tcollection := self new.\r\tstonReader parseListDo: [ :each |\r\t\tcollection add: each ].\r\t^ collection"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #collectionIcon"},{"name":"with:","linesOfCode":5,"sourceCode":"with: anObject \r\t\"Answer an instance of me containing anObject.\"\r\r\t^ self empty\r\t\tadd: anObject;\r\t\tyourself"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #Collection"},{"name":"with:with:with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t\"Answer an instance of me, containing the five arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tyourself"},{"name":"with:with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t\"Answer an instance of me containing the three arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tyourself"},{"name":"with:with:","linesOfCode":6,"sourceCode":"with: firstObject with: secondObject \r\t\"Answer an instance of me containing the two arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tyourself"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aCollection'."},{"name":"approvedSelectorsForMethodFinder","linesOfCode":2,"sourceCode":"approvedSelectorsForMethodFinder\r\r\t ^ self selectors"},{"name":"withAll:","linesOfCode":5,"sourceCode":"withAll: aCollection\r\t\"Create a new collection containing all the elements from aCollection.\"\r\r\t^ (self new: aCollection size)\r\t\taddAll: aCollection;\r\t\tyourself"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self new"}],"meta":null}}],"packages":[]}