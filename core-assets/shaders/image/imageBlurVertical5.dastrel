import compute.environment;
import compute.stage;

uniform(binding = StorageImages.Images, format = rgba8, readonly) sourceImage : image2D;
uniform(binding = StorageImages.Images + 1, format = rgba8, writeonly) destImage : image2D;

shared localGroupSamples : float4[8][64];

code_block(compute, localSizeX=64, localSizeY=4) main
{
    let blockPosition = int2(ComputeStage.workgroupID.xy)*int2(64, 4);

    // Fetch the samples for the local workgroup.
    {
        let fetchGridIndex = int2(ComputeStage.localInvocationID.x, ComputeStage.localInvocationID.y*2u);
        let fetchOffset = fetchGridIndex - int2(0, 2);
        let fetchPosition = blockPosition + fetchOffset;
        localGroupSamples[fetchGridIndex.x][fetchGridIndex.y] = imageRead(sourceImage, fetchPosition);
        localGroupSamples[fetchGridIndex.x][fetchGridIndex.y + 1] = imageRead(sourceImage, fetchPosition + int2(0, 1));
    }

    // Synchronization point.
    barrier();

    // Compute the blurred sample.
    let destPosition = blockPosition + int2(ComputeStage.localInvocationID.xy);
    let samplePosition = int2(ComputeStage.localInvocationID.xy) + int2(0, 2);

    let blurredSample = (
        localGroupSamples[samplePosition.x][samplePosition.y - 2]      +
        localGroupSamples[samplePosition.x][samplePosition.y - 1]*4.0f +
        localGroupSamples[samplePosition.x][samplePosition.y    ]*6.0f +
        localGroupSamples[samplePosition.x][samplePosition.y + 1]*4.0f +
        localGroupSamples[samplePosition.x][samplePosition.y + 2]
    )*0.0625f;

    imageWrite(destImage, destPosition, blurredSample);
}
