import ambientOcclusionShaderSignature;
import compute.stage;
import procedural.noise;

uniform(binding=CameraState.ObjectState) CameraState
{
    inverseViewMatrix: float4x4;
    viewMatrix: float4x4;

    projectionMatrix: float4x4;
    inverseProjectionMatrix: float4x4;

    screenSize: float2;
    inverseScreenSize: float2;

    currentTime: float;
}

uniform(binding = ComputeBuffers.DepthBuffer) depthTexture : texture2D;
uniform(binding = ComputeBuffers.NormalBuffer) normalTexture : texture2D;
uniform(binding = ComputeBuffers.Destination, format = r8, restrict, writeonly) ssaoImage : image2D;

constant SamplingDistributionSize : int = 8;
constant SamplingDistribution : float3[8] = {
    { -0.6877715587615967f, -0.506843626499176f, 0.5196920037269592f },
    { -0.34024709463119507f, 0.2696249485015869f, 0.9008519649505615f },
    { 0.8366008996963501f, -0.2242094725370407f, 0.4998289942741394f },
    { 0.5788835287094116f, -0.8140687346458435f, 0.04675422981381416f },
    { 0.1709364503622055f, 0.9850329756736755f, 0.022153066471219063f },
    { 0.8136236667633057f, 0.519911527633667f, 0.2602085471153259f },
    { -0.8440455198287964f, 0.44032758474349976f, 0.3061026632785797f },
    { 0.1833304911851883f, -0.7002113461494446f, 0.6899957060813904f },
};

function rotationMatrixFor(s: float) -> float3x3
{
	let c = sqrt(1.0f - s*s);
    return float3x3(
        float3(c, s, 0.0f),
        float3(-s, c, 0.0f),
        float3(0.0f, 0.0f, 1.0f)
    );
}

constant vectorAxis : float3[6] = {
    {1.0f, 0.0f, 0.0f},
    {0.0f, 1.0f, 0.0f},
    {0.0f, 0.0f, 1.0f},
    {1.0f, 0.0f, 0.0f},
    {0.0f, 1.0f, 0.0f},
    {0.0f, 0.0f, 1.0f},
};

function findBestAxisFor(v: float3) -> int
{
    let bestDot = fabs(dot(v, vectorAxis[0]));
    let bestAxis = 0;

    let d = fabs(dot(v, vectorAxis[1]));
    if(d > bestDot)
    {
        bestDot = d;
        bestAxis = 1;
    }

    d = fabs(dot(v, vectorAxis[2]));
    if(d > bestDot)
        bestAxis = 2;

    return bestAxis;
}

function computeTBNForNormal(normal: float3) -> float3x3
{
    let normalAxis = findBestAxisFor(normal);

    // Axis[normalAxis + 1] and axis[normalAxis + 2] are not parallel to the
    // normal value. However, they do not necesarily form an orthogonal basis,
    // so we apply the Gram-schmidth orthogonalization.
    let tangent = vectorAxis[normalAxis + 1];
    tangent = normalize(tangent - normal*dot(normal, tangent));

    let bitangent = vectorAxis[normalAxis + 2];
    bitangent = normalize(bitangent - normal*dot(normal, bitangent) - tangent*dot(tangent, bitangent));

    return float3x3(tangent, bitangent, normal);
}

function sampleAmbientOcclusionAt(eyeDepth: float, position: float3) -> float
{
    let projectedPosition = CameraState.projectionMatrix * float4(position, 1.0f);
    let samplePoint = projectedPosition.xyz / projectedPosition.w;
    let sampleDepth = aoDepthSampler.sampleLod(depthTexture, samplePoint.xy*0.5f + 0.5f, 0.0f).r;

    // Large variations of depth can introduce some false positives.
    let threshold = fabs(eyeDepth - samplePoint.z)*10.0f;
    let attenuation = 1.0f - smoothstep(threshold, threshold*2.0f, fabs(sampleDepth - samplePoint.z));
    return (sampleDepth - 0.00001f < samplePoint.z ? 0.0f : 1.0f)*attenuation;
}

code_block(compute, localSizeX=32, localSizeY=16) main
{
	let st = int2(ComputeStage.globalInvocationID.xy);
	let size = getImageSize(ssaoImage);
	let inverseSize = 1.0f / float2(size);
    let uv = float2(st)*inverseSize;

    // Compute the eye position, in view space.
    let eyeDepth = aoDepthSampler.sampleLod(depthTexture, uv, 0.0f).r;
    let screenPosition = float4(uv*2.0f - 1.0f, eyeDepth, 1.0f);

    let eyePosition4 = CameraState.inverseProjectionMatrix *screenPosition;
    let eyePosition = eyePosition4.xyz/eyePosition4.w;

    // Read the normal
    let eyeNormal = normalize(aoNormalSampler.sampleLod(normalTexture, uv, 0.0f).rgb*2.0f - 1.0f);

    // Compute the TBN matrix.
    let normalAxis = findBestAxisFor(eyeNormal);
    let TBN = computeTBNForNormal(eyeNormal);

    // Compute a noise rotation matrix
    let noiseRotation = rotationMatrixFor(signedRandomNoise(uv));

    // Compute the full sample tangent to view matrix.
    let sampleTangentToView = TBN*noiseRotation;

	let outSampleCount = 0.0f;

    for(let i = 0; i < SamplingDistributionSize; i += 1)
    {
        let delta = sampleTangentToView*(SamplingDistribution[i]*0.1f);
        outSampleCount += sampleAmbientOcclusionAt(eyeDepth, eyePosition + delta);
    }

	let value = 1.0f - outSampleCount / float(SamplingDistributionSize);
	imageWrite(ssaoImage, st, float4(value, 0.0f, 0.0f, 0.0f));
}
